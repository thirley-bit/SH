{"version":3,"sources":["index.js","components/index.js","components/virtual-list/index.js","components/virtual-list/vue/index.js","components/virtual-list/vue/list.js","utils/convert.js","utils/lodash.js","utils/timer.js","components/virtual-list/constants.js","components/virtual-list/dom-helpers.js","components/virtual-list/preset.js","utils/index.js","utils/math.js","components/virtual-list/list-set.js","components/virtual-list/utils.js","components/virtual-list/vue/render.js","components/virtual-list/react/index.js","components/virtual-list/react/list.js","components/virtual-list/react/validate.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,ACHA,ALeA,ACHA,ACHA,ACHA;ACFA,ACHA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,AENA;AELA,ACHA,ANkBA,ACHA,AENA;AELA,ACHA,ANkBA,ACHA,AENA;AELA,ACHA,ANkBA,ACHA,AENA;AELA,ACHA,ANkBA,ACHA,AMlBA,AJYA;AELA,ACHA,ANkBA,ACHA,AMlBA,AJYA;AELA,ACHA,ANkBA,ACHA,AMlBA,AJYA;AELA,ACHA,ANkBA,AOrBA,ACHA,ALeA;AELA,ACHA,ANkBA,AOrBA,ACHA,ALeA;AELA,ACHA,ANkBA,AOrBA,ACHA,ALeA;AELA,AIZA,AHSA,ANkBA,AQxBA,ALeA;AELA,AIZA,AHSA,ANkBA,AQxBA,ALeA;AELA,AIZA,AHSA,ANkBA,AQxBA,ALeA;AELA,AIZA,AHSA,AIZA,AV8BA,AQxBA,ALeA;AELA,AIZA,AHSA,AIZA,AV8BA,AQxBA,ALeA;AELA,AIZA,AHSA,AIZA,AV8BA,AQxBA,ALeA;AELA,AIZA,AHSA,AIZA,AV8BA,AWjCA,AHSA,ALeA;AELA,AIZA,AHSA,AIZA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AIZA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AMlBA,AFMA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AMlBA,AFMA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AMlBA,AFMA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AMlBA,ACHA,AHSA,AV8BA,AWjCA,AHSA;AHUA,AIZA,AHSA,AMlBA,ACHA,AHSA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,AHSA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA,AWjCA;ANmBA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AKdA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AKdA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AKdA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AKdA,AIZA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,AJYA,AV8BA;AS1BA,AHSA,AMlBA,ACHA,ACHA,Ad0CA;AS1BA,AHSA,AMlBA,ACHA,ACHA,Ad0CA;AS1BA,AHSA,AMlBA,ACHA,ACHA,Ad0CA;AS1BA,AHSA,AMlBA,ACHA,ACHA,Ad0CA;AS1BA,AHSA,AMlBA,ACHA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,ACHA,Ad0CA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AHSA,AOrBA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AS1BA,AIZA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AatCA,AbuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./components/index.js');\nvar __TEMP__ = require('./utils/index.js');\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./components/virtual-list/index.js');Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualList; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/convert.js');Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertPX2Int; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/lodash.js');Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return __TEMP__.omit; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/math.js');Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return __TEMP__.getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return __TEMP__.isCosDistributing; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./utils/timer.js');Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.requestTimeout; } });\n//# sourceMappingURL=index.js.map\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./virtual-list/index.js');Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return __TEMP__.VirtualList; } });\n//# sourceMappingURL=index.js.map\n","const VirtualList = (process.env.FRAMEWORK === 'vue' || process.env.FRAMEWORK === 'vue3')\n    ? require('./vue').default\n    : require('./react').default;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return VirtualList; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualList; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('./list.js');var List = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst VirtualList = List;\nfunction install(Vue) {\n    Vue.component('virtual-list', VirtualList);\n}\nvar index = {\n    install\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'VirtualList', { enumerable: true, configurable: true, get: function() { return VirtualList; } });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return index; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../dom-helpers.js');var getRTLOffsetType = __TEMP__['getRTLOffsetType'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];var getRectSize = __TEMP__['getRectSize'];var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('./render.js');var render = __REQUIRE_DEFAULT__(__TEMP__);\n\nvar List = {\n    props: {\n        height: {\n            type: [String, Number],\n            required: true\n        },\n        width: {\n            type: [String, Number],\n            required: true\n        },\n        itemCount: {\n            type: Number,\n            required: true\n        },\n        itemData: {\n            type: Array,\n            required: true\n        },\n        itemSize: {\n            type: [Number, Function],\n            required: true\n        },\n        unlimitedSize: {\n            type: Boolean,\n            default: false\n        },\n        position: {\n            type: String,\n            default: 'absolute'\n        },\n        initialScrollOffset: {\n            type: Number,\n            default: 0\n        },\n        innerElementType: {\n            type: String,\n            default: process.env.TARO_ENV === 'h5' ? 'taro-view-core' : 'view'\n        },\n        direction: {\n            type: String,\n            default: 'ltr'\n        },\n        layout: {\n            type: String,\n            default: 'vertical'\n        },\n        overscanCount: {\n            type: Number,\n            default: 1\n        },\n        placeholderCount: {\n            type: Number\n        },\n        useIsScrolling: {\n            type: Boolean,\n            default: false\n        },\n        item: {\n            required: true\n        },\n        itemKey: String,\n        itemTagName: {\n            type: String,\n            default: process.env.TARO_ENV === 'h5' ? 'taro-view-core' : 'view'\n        },\n        innerTagName: {\n            type: String,\n            default: process.env.TARO_ENV === 'h5' ? 'taro-view-core' : 'view'\n        },\n        outerTagName: {\n            type: String,\n            default: process.env.TARO_ENV === 'h5' ? 'taro-scroll-view-core' : 'scroll-view'\n        },\n        itemElementType: String,\n        outerElementType: String,\n        innerRef: String,\n        outerRef: String,\n        onItemsRendered: Function,\n        onScrollNative: Function,\n        shouldResetStyleCacheOnItemSizeChange: {\n            type: Boolean,\n            default: true\n        },\n    },\n    data() {\n        const preset = new Preset(this.$props, this.refresh);\n        return {\n            itemList: preset.itemList,\n            preset,\n            id: this.$props.id || preset.id,\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.$props.initialScrollOffset === 'number'\n                ? this.$props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            resetIsScrollingTimeoutId: null,\n            refreshCount: 0\n        };\n    },\n    methods: {\n        refresh() {\n            this.refreshCount = this.refreshCount + 1;\n        },\n        scrollTo(scrollOffset) {\n            const { enhanced } = this.$props;\n            scrollOffset = Math.max(0, scrollOffset);\n            if (this.scrollOffset === scrollOffset)\n                return;\n            if (enhanced) {\n                const isHorizontal = this.preset.isHorizontal;\n                const option = {\n                    animated: true,\n                    duration: 500\n                };\n                if (isHorizontal) {\n                    option.left = scrollOffset;\n                }\n                else {\n                    option.top = scrollOffset;\n                }\n                return getScrollViewContextNode(`#${this.$data.id}`).then((node) => node.scrollTo(option));\n            }\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = true;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        scrollToItem(index, align = 'auto') {\n            const { itemCount } = this.$props;\n            const { scrollOffset } = this.$data;\n            index = Math.max(0, Math.min(index, itemCount - 1));\n            this.scrollTo(this.itemList.getOffsetForIndexAndAlignment(this.$props, index, align, scrollOffset));\n        },\n        _callOnItemsRendered: memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n            return this.$props.onItemsRendered({\n                overscanStartIndex,\n                overscanStopIndex,\n                visibleStartIndex,\n                visibleStopIndex\n            });\n        }),\n        _callOnScroll: memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) {\n            this.$emit('scroll', {\n                scrollDirection,\n                scrollOffset,\n                scrollUpdateWasRequested,\n                detail\n            });\n        }),\n        _callPropsCallbacks() {\n            if (typeof this.$props.onItemsRendered === 'function') {\n                const { itemCount } = this.$props;\n                if (itemCount > 0) {\n                    const [overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex] = this._getRangeToRender();\n                    this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex);\n                }\n            }\n            this._callOnScroll(this.scrollDirection, this.scrollOffset, this.scrollUpdateWasRequested, this.preset.field);\n            setTimeout(() => {\n                const [startIndex, stopIndex] = this._getRangeToRender();\n                const isHorizontal = this.preset.isHorizontal;\n                for (let index = startIndex; index <= stopIndex; index++) {\n                    this._getSizeUploadSync(index, isHorizontal);\n                }\n            }, 0);\n        },\n        _getSizeUploadSync(index, isHorizontal) {\n            const ID = `#${this.$data.id}-${index}`;\n            return new Promise((resolve) => {\n                const success = ({ width, height }) => {\n                    const size = isHorizontal ? width : height;\n                    if (!this.itemList.compareSize(index, size)) {\n                        this.itemList.setSize(index, size);\n                        resolve(this.itemList.getSize(index));\n                    }\n                };\n                const fail = () => {\n                    const [startIndex, stopIndex] = this._getRangeToRender();\n                    if (index >= startIndex && index <= stopIndex) {\n                        setTimeout(() => {\n                            getRectSize(ID, success, fail);\n                        }, 100);\n                    }\n                };\n                getRectSize(ID, success, fail);\n            });\n        },\n        _getRangeToRender() {\n            return this.itemList.getRangeToRender(this.$data.scrollDirection, this.$data.scrollOffset, this.$data.isScrolling);\n        },\n        _onScrollHorizontal(event) {\n            const { clientWidth, scrollTop, scrollLeft, scrollHeight, scrollWidth } = event.currentTarget;\n            this.preset.field = {\n                scrollHeight: scrollHeight,\n                scrollWidth: this.itemList.getOffsetSize(),\n                scrollTop: scrollTop,\n                scrollLeft: scrollLeft,\n                clientHeight: scrollHeight,\n                clientWidth: scrollWidth\n            };\n            if (this.$props.onScrollNative) {\n                this.$props.onScrollNative(event);\n            }\n            const diffOffset = this.preset.field.scrollLeft - scrollLeft;\n            if (this.scrollOffset === scrollLeft || this.preset.isShaking(diffOffset)) {\n                return;\n            }\n            let scrollOffset = scrollLeft;\n            if (this.preset.isRtl) {\n                // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                switch (getRTLOffsetType()) {\n                    case 'negative':\n                        scrollOffset = -scrollLeft;\n                        break;\n                    case 'positive-descending':\n                        scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                        break;\n                }\n            }\n            // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n            scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n            this.preset.field = {\n                scrollWidth: scrollOffset,\n            };\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < scrollLeft ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = false;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        _onScrollVertical(event) {\n            const { clientHeight, scrollHeight, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n            if (this.$props.onScrollNative) {\n                this.$props.onScrollNative(event);\n            }\n            const diffOffset = this.preset.field.scrollTop - scrollTop;\n            if (this.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                return;\n            }\n            // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n            const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n            this.preset.field = {\n                scrollHeight: this.itemList.getOffsetSize(),\n                scrollWidth: scrollWidth,\n                scrollTop: scrollOffset,\n                scrollLeft: scrollLeft,\n                clientHeight: clientHeight,\n                clientWidth: scrollWidth,\n                diffOffset: this.preset.field.scrollTop - scrollOffset,\n            };\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < scrollOffset ? 'forward' : 'backward';\n            this.scrollOffset = scrollOffset;\n            this.scrollUpdateWasRequested = false;\n            this.$nextTick(this._resetIsScrollingDebounced);\n        },\n        _outerRefSetter(ref) {\n            const { outerRef } = this.$props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('value')) {\n                outerRef.value = ref;\n            }\n        },\n        _resetIsScrollingDebounced() {\n            if (this.resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this.resetIsScrollingTimeoutId);\n            }\n            this.resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        },\n        _resetIsScrolling() {\n            this.resetIsScrollingTimeoutId = null;\n            this.isScrolling = false;\n            this.$nextTick(() => {\n                this.preset.getItemStyleCache(-1, null);\n            });\n        }\n    },\n    mounted() {\n        const { initialScrollOffset } = this.$props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                outerRef.scrollLeft = initialScrollOffset;\n            }\n            else {\n                outerRef.scrollTop = initialScrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n    },\n    updated() {\n        this.preset.update(this.$props);\n        const { scrollOffset, scrollUpdateWasRequested } = this.$data;\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // So we need to determine which browser behavior we're dealing with, and mimic it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            outerRef.scrollLeft = -scrollOffset;\n                            break;\n                        case 'positive-ascending':\n                            outerRef.scrollLeft = scrollOffset;\n                            break;\n                        default: {\n                            const { clientWidth, scrollWidth } = outerRef;\n                            outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    outerRef.scrollLeft = scrollOffset;\n                }\n            }\n            else {\n                outerRef.scrollTop = scrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n    },\n    beforeDestroy() {\n        if (this.resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this.resetIsScrollingTimeoutId);\n        }\n    },\n    render() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const { item, direction, height, innerRef, itemCount, itemData, itemKey = defaultItemKey, layout, useIsScrolling, width, enhanced = false } = omit(this.$props, ['innerElementType', 'innerTagName', 'itemElementType', 'itemTagName', 'outerElementType', 'outerTagName', 'position']);\n        const { id, isScrolling, scrollOffset, scrollUpdateWasRequested } = this.$data;\n        const isHorizontal = this.preset.isHorizontal;\n        const placeholderCount = this.preset.placeholderCount;\n        const onScroll = isHorizontal\n            ? this._onScrollHorizontal\n            : this._onScrollVertical;\n        const [startIndex, stopIndex] = this._getRangeToRender();\n        const items = [];\n        if (itemCount > 0) {\n            const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n            items.push(new Array(prevPlaceholder).fill(-1).map((_, index) => render(this.preset.itemTagName, {\n                key: itemKey(index + startIndex - prevPlaceholder, itemData),\n                style: { display: 'none' }\n            })));\n            for (let index = startIndex; index <= stopIndex; index++) {\n                const style = this.preset.getItemStyle(index);\n                items.push(render(this.preset.itemTagName, {\n                    key: itemKey(index, itemData),\n                    style\n                }, [\n                    render(item, {\n                        id: `${id}-${index}`,\n                        props: {\n                            id: `${id}-${index}`,\n                            data: itemData,\n                            index,\n                            isScrolling: useIsScrolling ? isScrolling : undefined\n                        }\n                    })\n                ]));\n            }\n            let restCount = itemCount - stopIndex;\n            restCount = restCount > 0 ? restCount : 0;\n            const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n            items.push(new Array(postPlaceholder).fill(-1).map((_, index) => render(this.preset.itemTagName, {\n                key: itemKey(1 + index + stopIndex, itemData),\n                style: { display: 'none' }\n            })));\n        }\n        // Read this value AFTER items have been created,\n        // So their actual sizes (if variable) are taken into consideration.\n        const estimatedTotalSize = convertNumber2PX(this.itemList.getOffsetSize());\n        const outerElementProps = {\n            id,\n            ref: this._outerRefSetter,\n            layout,\n            enhanced,\n            style: {\n                position: 'relative',\n                height: convertNumber2PX(height),\n                width: convertNumber2PX(width),\n                overflow: 'auto',\n                WebkitOverflowScrolling: 'touch',\n                willChange: 'transform',\n                direction\n            },\n            attrs: {\n                scrollY: layout === 'vertical',\n                scrollX: layout === 'horizontal'\n            },\n            on: {\n                scroll: onScroll\n            }\n        };\n        if (!enhanced) {\n            if (isHorizontal) {\n                outerElementProps.scrollLeft = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollLeft;\n            }\n            else {\n                outerElementProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n            }\n        }\n        if (this.preset.isRelative) {\n            const pre = convertNumber2PX(this.itemList.getOffsetSize(startIndex));\n            return render(this.preset.outerTagName, outerElementProps, [\n                process.env.FRAMEWORK === 'vue3' ? (_b = (_a = this.$slots).top) === null || _b === void 0 ? void 0 : _b.call(_a) : this.$slots.top,\n                render(this.preset.itemTagName, {\n                    key: `${id}-pre`,\n                    id: `${id}-pre`,\n                    style: {\n                        height: isHorizontal ? '100%' : pre,\n                        width: !isHorizontal ? '100%' : pre\n                    }\n                }),\n                render(this.preset.innerTagName, {\n                    ref: innerRef,\n                    key: `${id}-inner`,\n                    id: `${id}-inner`,\n                    style: {\n                        pointerEvents: isScrolling ? 'none' : 'auto',\n                        position: 'relative',\n                    }\n                }, items),\n                process.env.FRAMEWORK === 'vue3' ? (_d = (_c = this.$slots).bottom) === null || _d === void 0 ? void 0 : _d.call(_c) : this.$slots.bottom,\n            ]);\n        }\n        else {\n            return render(this.preset.outerTagName, outerElementProps, [\n                process.env.FRAMEWORK === 'vue3' ? (_f = (_e = this.$slots).top) === null || _f === void 0 ? void 0 : _f.call(_e) : this.$slots.top,\n                render(this.preset.innerTagName, {\n                    ref: innerRef,\n                    key: `${id}-inner`,\n                    id: `${id}-inner`,\n                    style: {\n                        height: isHorizontal ? '100%' : estimatedTotalSize,\n                        pointerEvents: isScrolling ? 'none' : 'auto',\n                        position: 'relative',\n                        width: !isHorizontal ? '100%' : estimatedTotalSize\n                    }\n                }, items),\n                process.env.FRAMEWORK === 'vue3' ? (_h = (_g = this.$slots).bottom) === null || _h === void 0 ? void 0 : _h.call(_g) : this.$slots.bottom,\n            ]);\n        }\n    }\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return List; } });\n//# sourceMappingURL=list.js.map\n","/** 将距离值根据单位转换为 Number 类型\n * TODO: 未来可以考虑支持更多单位\n */\nfunction convertPX2Int(distance) {\n    if (typeof distance === 'string') {\n        const str = distance.toLowerCase();\n        if (/px$/.test(str)) {\n            return Number(str.replace(/px$/, ''));\n        }\n    }\n    return distance;\n}\nfunction convertNumber2PX(styleValue) {\n    if (!styleValue && styleValue !== 0)\n        return '';\n    return typeof styleValue === 'number' ? styleValue + 'px' : styleValue;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return convertPX2Int; } });\n//# sourceMappingURL=convert.js.map\n","function omit(obj = {}, fields = []) {\n    const shallow = Object.assign({}, obj);\n    fields.forEach((key) => {\n        delete shallow[key];\n    });\n    return shallow;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return omit; } });\n//# sourceMappingURL=lodash.js.map\n","var __TEMP__ = require('@tarojs/runtime');var cancelAnimationFrame = __TEMP__['cancelAnimationFrame'];var now = __TEMP__['now'];var requestAnimationFrame = __TEMP__['requestAnimationFrame'];\n\nfunction cancelTimeout(timeoutID) {\n    cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay = 0) {\n    const start = now();\n    const timeoutID = {\n        id: requestAnimationFrame(tick)\n    };\n    function tick() {\n        if (now() - start >= delay) {\n            // eslint-disable-next-line no-useless-call\n            callback.call(null);\n        }\n        else {\n            timeoutID.id = requestAnimationFrame(tick);\n        }\n    }\n    return timeoutID;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return requestTimeout; } });\n//# sourceMappingURL=timer.js.map\n","const IS_SCROLLING_DEBOUNCE_INTERVAL = 200;\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'IS_SCROLLING_DEBOUNCE_INTERVAL', { enumerable: true, configurable: true, get: function() { return IS_SCROLLING_DEBOUNCE_INTERVAL; } });\n//# sourceMappingURL=constants.js.map\n","// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n    if (cachedRTLResult === null || recalculate) {\n        const outerDiv = document.createElement('div');\n        const outerStyle = outerDiv.style;\n        outerStyle.width = '50px';\n        outerStyle.height = '50px';\n        outerStyle.overflow = 'scroll';\n        outerStyle.direction = 'rtl';\n        const innerDiv = document.createElement('div');\n        const innerStyle = innerDiv.style;\n        innerStyle.width = '100px';\n        innerStyle.height = '100px';\n        outerDiv.appendChild(innerDiv);\n        document.body.appendChild(outerDiv);\n        if (outerDiv.scrollLeft > 0) {\n            cachedRTLResult = 'positive-descending';\n        }\n        else {\n            outerDiv.scrollLeft = 1;\n            if (outerDiv.scrollLeft === 0) {\n                cachedRTLResult = 'negative';\n            }\n            else {\n                cachedRTLResult = 'positive-ascending';\n            }\n        }\n        document.body.removeChild(outerDiv);\n        return cachedRTLResult;\n    }\n    return cachedRTLResult;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'getRTLOffsetType', { enumerable: true, configurable: true, get: function() { return getRTLOffsetType; } });\n//# sourceMappingURL=dom-helpers.js.map\n","var __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../utils/index.js');\nvar __TEMP__ = require('./list-set.js');var ListSet = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./utils.js');var isHorizontalFunc = __TEMP__['isHorizontalFunc'];var isRtlFunc = __TEMP__['isRtlFunc'];\nvar __TEMP__ = require('../../utils/math.js');var isCosDistributing = __TEMP__['isCosDistributing'];\nvar __TEMP__ = require('../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\n\nlet INSTANCE_ID = 0;\nclass Preset {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this.wrapperField = {\n            scrollLeft: 0,\n            scrollTop: 0,\n            scrollHeight: 0,\n            scrollWidth: 0,\n            clientHeight: 0,\n            clientWidth: 0,\n            diffOffset: 0\n        };\n        this.diffList = [0, 0, 0];\n        this.getItemStyleCache = memoizeOne((_itemSize, _layout, _direction) => {\n            // TODO: Cache of item styles, keyed by item index.\n            return {};\n        });\n        this.init(this.props);\n        this.itemList = new ListSet(props, refresh);\n    }\n    init(props) {\n        this.props = props;\n    }\n    update(props) {\n        this.props = props;\n        this.itemList.update(props);\n    }\n    get id() {\n        return `virtual-list-${INSTANCE_ID++}`;\n    }\n    get isHorizontal() {\n        return isHorizontalFunc(this.props);\n    }\n    get isRtl() {\n        return isRtlFunc(this.props);\n    }\n    get isRelative() {\n        return this.props.position === 'relative';\n    }\n    get placeholderCount() {\n        return this.props.placeholderCount >= 0 ? this.props.placeholderCount : this.props.overscanCount;\n    }\n    get outerTagName() {\n        return this.props.outerElementType || this.props.outerTagName || 'div';\n    }\n    get innerTagName() {\n        return this.props.innerElementType || this.props.innerTagName || 'div';\n    }\n    get itemTagName() {\n        return this.props.itemElementType || this.props.itemTagName || 'div';\n    }\n    get field() {\n        return this.wrapperField;\n    }\n    set field(o) {\n        Object.assign(this.wrapperField, o);\n        // Object.keys(o).forEach(key => {\n        //   if (typeof o[key] === 'number' && typeof this.wrapperField[key] === 'number') {\n        //     this.wrapperField[key] = o[key]\n        //   }\n        // })\n    }\n    isShaking(diff) {\n        const list = this.diffList.slice(-3);\n        this.diffList.push(diff);\n        return list.findIndex(e => Math.abs(e) === Math.abs(diff)) !== -1 || isCosDistributing(this.diffList.slice(-4));\n    }\n    getItemStyle(index) {\n        const { direction, itemSize, layout, shouldResetStyleCacheOnItemSizeChange } = this.props;\n        const itemStyleCache = this.getItemStyleCache(shouldResetStyleCacheOnItemSizeChange ? itemSize : false, shouldResetStyleCacheOnItemSizeChange ? layout : false, shouldResetStyleCacheOnItemSizeChange ? direction : false);\n        let style;\n        const offset = convertNumber2PX(this.itemList.getOffsetSize(index));\n        const size = convertNumber2PX(this.itemList.getSize(index));\n        const isHorizontal = this.isHorizontal;\n        const isRtl = this.isRtl;\n        if (itemStyleCache.hasOwnProperty(index)) {\n            // Note: style is frozen.\n            style = Object.assign({}, itemStyleCache[index]);\n            if (isHorizontal) {\n                style.width = size;\n                if (!this.isRelative) {\n                    if (isRtl) {\n                        style.right = offset;\n                    }\n                    else {\n                        style.left = offset;\n                    }\n                }\n            }\n            else {\n                style.height = size;\n                if (!this.isRelative) {\n                    style.top = offset;\n                }\n            }\n        }\n        else {\n            if (this.isRelative) {\n                itemStyleCache[index] = style = {\n                    height: !isHorizontal ? size : '100%',\n                    width: isHorizontal ? size : '100%'\n                };\n            }\n            else {\n                const offsetHorizontal = isHorizontal ? offset : 0;\n                itemStyleCache[index] = style = {\n                    position: 'absolute',\n                    left: !isRtl ? offsetHorizontal : undefined,\n                    right: isRtl ? offsetHorizontal : undefined,\n                    top: !isHorizontal ? offset : 0,\n                    height: !isHorizontal ? size : '100%',\n                    width: isHorizontal ? size : '100%'\n                };\n            }\n        }\n        for (const k in style) {\n            if (style.hasOwnProperty(k)) {\n                style[k] = convertNumber2PX(style[k]);\n            }\n        }\n        return style;\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return Preset; } });\n//# sourceMappingURL=preset.js.map\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./convert.js');Object.defineProperty(exports, 'convertNumber2PX', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertNumber2PX; } });Object.defineProperty(exports, 'convertPX2Int', { enumerable: true, configurable: true, get: function() { return __TEMP__.convertPX2Int; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./lodash.js');Object.defineProperty(exports, 'omit', { enumerable: true, configurable: true, get: function() { return __TEMP__.omit; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./math.js');Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return __TEMP__.getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return __TEMP__.isCosDistributing; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./timer.js');Object.defineProperty(exports, 'cancelTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.cancelTimeout; } });Object.defineProperty(exports, 'requestTimeout', { enumerable: true, configurable: true, get: function() { return __TEMP__.requestTimeout; } });\n//# sourceMappingURL=index.js.map\n","function getMiddleNumber(...list) {\n    return list.sort((a, b) => a - b)[Math.floor(list.length / 2)];\n}\nfunction isCosDistributing(list, datum = 0) {\n    let flags = 0;\n    for (let i = 0; i < list.length - 1; i++) {\n        if (getMiddleNumber(list[i], datum, list[i + 1]) === datum) {\n            flags++;\n        }\n    }\n    return flags === list.length - 1;\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'getMiddleNumber', { enumerable: true, configurable: true, get: function() { return getMiddleNumber; } });Object.defineProperty(exports, 'isCosDistributing', { enumerable: true, configurable: true, get: function() { return isCosDistributing; } });\n//# sourceMappingURL=math.js.map\n","var __TEMP__ = require('@tarojs/shared');var isFunction = __TEMP__['isFunction'];\nvar __TEMP__ = require('./utils.js');var isHorizontalFunc = __TEMP__['isHorizontalFunc'];\n\nclass ListSet {\n    constructor(props, refresh) {\n        this.props = props;\n        this.refresh = refresh;\n        this.list = [];\n        this.defaultSize = 1;\n        this.update(props);\n        // Note: 不考虑列表模式切换情况，可能会导致列表抖动体验过差\n        if (this.props.unlimitedSize) {\n            this.mode = 'unlimited';\n        }\n        else if (isFunction(this.props.itemSize)) {\n            this.mode = 'function';\n        }\n        else {\n            this.mode = 'normal';\n        }\n        this.defaultSize = (isFunction(this.props.itemSize) ? this.props.itemSize() : this.props.itemSize) || 1;\n        if (!this.isNormalMode) {\n            this.list = new Array(this.length).fill(-1);\n        }\n    }\n    get isNormalMode() {\n        return this.mode === 'normal';\n    }\n    get isFunctionMode() {\n        return this.mode === 'function';\n    }\n    get isUnlimitedMode() {\n        return this.mode === 'unlimited';\n    }\n    get length() {\n        return this.props.itemCount || 100;\n    }\n    get overscan() {\n        return this.props.overscanCount || 0;\n    }\n    get wrapperSize() {\n        const { height, width } = this.props;\n        const isHorizontal = isHorizontalFunc(this.props);\n        const size = (isHorizontal ? width : height);\n        if (process.env.NODE_ENV !== 'production' && typeof size !== 'number') {\n            console.warn(`In mode ${isHorizontal ? 'horizontal, width' : 'vertical, height'} parameter should be a number, but got ${typeof size}.`);\n        }\n        return size;\n    }\n    update(props) {\n        this.props = props;\n        if (this.length > this.list.length) {\n            const arr = new Array(this.length - this.list.length).fill(-1);\n            this.list.push(...arr);\n        }\n        else if (this.length < this.list.length) {\n            this.list.length = this.length;\n        }\n    }\n    setSize(i = 0, size = this.defaultSize) {\n        var _a;\n        this.list[i] = size;\n        (_a = this.refresh) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    getSize(i = 0) {\n        const size = this.props.itemSize;\n        const item = this.list[i];\n        if (item >= 0)\n            return item;\n        if (this.isFunctionMode && isFunction(size)) {\n            const itemSize = size(i, this.props.itemData);\n            this.setSize(i, itemSize);\n            return itemSize;\n        }\n        return this.defaultSize;\n    }\n    getOffsetSize(i = this.list.length) {\n        if (this.isNormalMode)\n            return i * this.defaultSize;\n        return this.list.slice(0, i).reduce((sum, _, idx) => sum + this.getSize(idx), 0);\n    }\n    getSizeCount(offset = 0) {\n        if (offset === 0) {\n            return 0;\n        }\n        // if (this.isNormalMode) {\n        //   return Math.min(this.length - 1, Math.floor(offset / this.length))\n        // }\n        let offsetSize = 0;\n        const count = this.list.reduce((sum, _, idx) => {\n            if (offsetSize < offset) {\n                offsetSize += this.getSize(idx);\n                return ++sum;\n            }\n            return sum;\n        }, 0);\n        return count - 1;\n    }\n    getStartIndex(scrollOffset = 0) {\n        return Math.max(0, this.getSizeCount(scrollOffset) - 1);\n    }\n    getStopIndex(wrapperSize = 0, scrollOffset = 0, startIndex = 0) {\n        // const visibleOffset = this.getOffsetSize(startIndex)\n        // if (this.isNormalMode) {\n        //   const numVisibleItems = Math.ceil((wrapperSize + scrollOffset - visibleOffset) / this.length)\n        //   /** -1 is because stop index is inclusive */\n        //   return Math.max(startIndex, Math.min(this.length - 1, startIndex + numVisibleItems - 1))\n        // }\n        return Math.max(startIndex, Math.min(this.length - 1, this.getSizeCount(wrapperSize + scrollOffset)));\n    }\n    getRangeToRender(direction, scrollOffset = 0, block = false) {\n        if (this.length === 0) {\n            return [0, 0, 0, 0];\n        }\n        const wrapperSize = this.wrapperSize;\n        const startIndex = this.getStartIndex(scrollOffset);\n        const stopIndex = this.getStopIndex(wrapperSize, scrollOffset, startIndex);\n        // Overscan by one item in each direction so that tab/focus works. If there isn't at least one extra item, tab loops back around.\n        const overscanBackward = !block || direction === 'backward' ? Math.max(1, this.overscan) : 1;\n        const overscanForward = !block || direction === 'forward' ? Math.max(1, this.overscan) : 1;\n        return [\n            Math.max(0, startIndex - overscanBackward),\n            Math.max(0, Math.min(this.length - 1, stopIndex + overscanForward)),\n            startIndex,\n            stopIndex\n        ];\n    }\n    getOffsetForIndexAndAlignment(index, align, scrollOffset) {\n        const wrapperSize = this.wrapperSize;\n        const itemSize = this.getSize(index);\n        const lastItemOffset = Math.max(0, this.getOffsetSize(this.props.itemCount) - wrapperSize);\n        const maxOffset = Math.min(lastItemOffset, this.getOffsetSize(index));\n        const minOffset = Math.max(0, this.getOffsetSize(index) - wrapperSize + itemSize);\n        if (align === 'smart') {\n            if (scrollOffset >= minOffset - wrapperSize && scrollOffset <= maxOffset + wrapperSize) {\n                align = 'auto';\n            }\n            else {\n                align = 'center';\n            }\n        }\n        switch (align) {\n            case 'start':\n                return maxOffset;\n            case 'end':\n                return minOffset;\n            case 'center':\n                {\n                    // \"Centered\" offset is usually the average of the min and max.\n                    // But near the edges of the list, this doesn't hold true.\n                    const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                    if (middleOffset < Math.ceil(wrapperSize / 2)) {\n                        return 0; // near the beginning\n                    }\n                    else if (middleOffset > lastItemOffset + Math.floor(wrapperSize / 2)) {\n                        return lastItemOffset; // near the end\n                    }\n                    else {\n                        return middleOffset;\n                    }\n                }\n            case 'auto':\n            default:\n                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                    return scrollOffset;\n                }\n                else if (scrollOffset < minOffset) {\n                    return minOffset;\n                }\n                else {\n                    return maxOffset;\n                }\n        }\n    }\n    compareSize(i = 0, size = 0) {\n        if (this.isNormalMode)\n            return true;\n        return this.getSize(i) === size;\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return ListSet; } });\n//# sourceMappingURL=list-set.js.map\n","var __TEMP__ = require('@tarojs/taro');var Taro = __REQUIRE_DEFAULT__(__TEMP__);\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nconst defaultItemKey = (index, _itemData) => index;\nfunction isHorizontalFunc({ direction, layout }) {\n    return direction === 'horizontal' || layout === 'horizontal';\n}\nfunction isRtlFunc({ direction }) {\n    return direction === 'rtl';\n}\nfunction getRectSize(id, success, fail, retryMs = 500) {\n    const query = Taro.createSelectorQuery();\n    try {\n        query.select(id).boundingClientRect((res) => {\n            if (res) {\n                success === null || success === void 0 ? void 0 : success(res);\n            }\n            else {\n                fail === null || fail === void 0 ? void 0 : fail();\n            }\n        }).exec();\n    }\n    catch (err) {\n        setTimeout(() => {\n            getRectSize(id, success, fail, retryMs);\n        }, retryMs);\n    }\n}\nasync function getScrollViewContextNode(id) {\n    const query = Taro.createSelectorQuery();\n    return new Promise((resolve) => query.select(id).node(({ node }) => resolve(node)).exec());\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'defaultItemKey', { enumerable: true, configurable: true, get: function() { return defaultItemKey; } });Object.defineProperty(exports, 'getRectSize', { enumerable: true, configurable: true, get: function() { return getRectSize; } });Object.defineProperty(exports, 'getScrollViewContextNode', { enumerable: true, configurable: true, get: function() { return getScrollViewContextNode; } });Object.defineProperty(exports, 'isHorizontalFunc', { enumerable: true, configurable: true, get: function() { return isHorizontalFunc; } });Object.defineProperty(exports, 'isRtlFunc', { enumerable: true, configurable: true, get: function() { return isRtlFunc; } });\n//# sourceMappingURL=utils.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('vue');var h = __TEMP__['h'];\n\nfunction render (componentName, options, children) {\n    const { attrs = {}, on = {}, props = {}, slots = {} } = options, el = __rest(options, [\"attrs\", \"on\", \"props\", \"slots\"]);\n    if (process.env.FRAMEWORK === 'vue3') {\n        // Events\n        Object.keys(on).forEach(key => {\n            const name = `on${key.charAt(0).toUpperCase()}${key.slice(1)}`;\n            el[name] = on[key];\n        });\n        return h(componentName, Object.assign(Object.assign(Object.assign(Object.assign({}, attrs), props), slots), el), children);\n    }\n    return h(componentName, options, children);\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return render; } });\n//# sourceMappingURL=render.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('@tarojs/components');var ScrollView = __TEMP__['ScrollView'];var View = __TEMP__['View'];\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/convert.js');var convertPX2Int = __TEMP__['convertPX2Int'];\nvar __TEMP__ = require('./list.js');var List = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst OuterScrollView = React.forwardRef(function OuterScrollView(props, ref) {\n    const _a = props, { style, onScroll, onScrollNative, layout } = _a, rest = __rest(_a, [\"style\", \"onScroll\", \"onScrollNative\", \"layout\"]);\n    const handleScroll = (event) => {\n        onScroll(Object.assign(Object.assign({}, event), { currentTarget: Object.assign(Object.assign({}, event.detail), { clientWidth: convertPX2Int(style.width), clientHeight: convertPX2Int(style.height) }) }));\n        if (typeof onScrollNative === 'function') {\n            onScrollNative(event);\n        }\n    };\n    return React.createElement(ScrollView, Object.assign({ ref,\n        style, scrollY: layout === 'vertical', scrollX: layout === 'horizontal', onScroll: handleScroll }, rest));\n});\nconst VirtualList = React.forwardRef(function VirtualList(props, ref) {\n    const _a = props, { direction = 'ltr', innerElementType = View, itemElementType = View, initialScrollOffset = 0, overscanCount = 1 } = _a, rest = __rest(_a, [\"direction\", \"innerElementType\", \"itemElementType\", \"initialScrollOffset\", \"overscanCount\"]);\n    if ('children' in rest) {\n        console.warn('Taro(VirtualList): children props have been deprecated. ' + 'Please use the item props instead.');\n        rest.item = rest.children;\n    }\n    if (rest.item instanceof Array) {\n        console.warn('Taro(VirtualList): item should not be an array');\n        rest.item = rest.item[0];\n    }\n    return React.createElement(List, Object.assign(Object.assign({ ref }, rest), { itemElementType,\n        innerElementType, outerElementType: OuterScrollView, direction,\n        initialScrollOffset,\n        overscanCount }));\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return VirtualList; } });\n//# sourceMappingURL=index.js.map\n","var __TEMP__ = require('tslib');var __rest = __TEMP__['__rest'];\nvar __TEMP__ = require('memoize-one');var memoizeOne = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('react');var React = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../../../utils/convert.js');var convertNumber2PX = __TEMP__['convertNumber2PX'];\nvar __TEMP__ = require('../../../utils/lodash.js');var omit = __TEMP__['omit'];\nvar __TEMP__ = require('../../../utils/timer.js');var cancelTimeout = __TEMP__['cancelTimeout'];var requestTimeout = __TEMP__['requestTimeout'];\nvar __TEMP__ = require('../constants.js');var IS_SCROLLING_DEBOUNCE_INTERVAL = __TEMP__['IS_SCROLLING_DEBOUNCE_INTERVAL'];\nvar __TEMP__ = require('../dom-helpers.js');var getRTLOffsetType = __TEMP__['getRTLOffsetType'];\nvar __TEMP__ = require('../preset.js');var Preset = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils.js');var getRectSize = __TEMP__['getRectSize'];var getScrollViewContextNode = __TEMP__['getScrollViewContextNode'];var defaultItemKey = __TEMP__['defaultItemKey'];\nvar __TEMP__ = require('./validate.js');var validateListProps = __TEMP__['validateListProps'];\n\nclass List extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        // FIXME Warning: Cannot update during an existing state transition (such as within `render`).\n        this.refresh = () => {\n            if (process.env.FRAMEWORK === 'preact') {\n                this.forceUpdate();\n            }\n            else {\n                this.setState(({ refreshCount }) => ({\n                    refreshCount: ++refreshCount\n                }));\n            }\n        };\n        this._outerRef = undefined;\n        this._resetIsScrollingTimeoutId = null;\n        this._callOnItemsRendered = memoizeOne((overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) => this.props.onItemsRendered({\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n        }));\n        // FIXME 优化事件信息\n        this._callOnScroll = memoizeOne((scrollDirection, scrollOffset, scrollUpdateWasRequested, detail) => this.props.onScroll({\n            scrollDirection,\n            scrollOffset,\n            scrollUpdateWasRequested,\n            detail\n        }));\n        this._getSizeUploadSync = (index, isHorizontal) => {\n            const ID = `#${this.state.id}-${index}`;\n            return new Promise((resolve) => {\n                const success = ({ width, height }) => {\n                    const size = isHorizontal ? width : height;\n                    if (!this.itemList.compareSize(index, size)) {\n                        this.itemList.setSize(index, size);\n                        resolve(this.itemList.getSize(index));\n                    }\n                };\n                const fail = () => {\n                    const [startIndex, stopIndex] = this._getRangeToRender();\n                    if (index >= startIndex && index <= stopIndex) {\n                        setTimeout(() => {\n                            getRectSize(ID, success, fail);\n                        }, 100);\n                    }\n                };\n                getRectSize(ID, success, fail);\n            });\n        };\n        this._onScrollHorizontal = event => {\n            const { clientWidth, scrollTop, scrollLeft, scrollHeight, scrollWidth } = event.currentTarget;\n            this.preset.field = {\n                scrollHeight: scrollHeight,\n                scrollWidth: this.itemList.getOffsetSize(),\n                scrollTop: scrollTop,\n                scrollLeft: scrollLeft,\n                clientHeight: scrollHeight,\n                clientWidth: scrollWidth\n            };\n            this.setState((prevState) => {\n                const diffOffset = this.preset.field.scrollLeft - scrollLeft;\n                if (prevState.scrollOffset === scrollLeft || this.preset.isShaking(diffOffset)) {\n                    // Scroll position may have been updated by cDM/cDU,\n                    // In which case we don't need to trigger another render,\n                    // And we don't want to update state.isScrolling.\n                    return null;\n                }\n                let scrollOffset = scrollLeft;\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                    // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            scrollOffset = -scrollLeft;\n                            break;\n                        case 'positive-descending':\n                            scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                            break;\n                    }\n                } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                this.preset.field = {\n                    scrollWidth: scrollOffset,\n                };\n                return {\n                    isScrolling: true,\n                    scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n                    scrollOffset,\n                    scrollUpdateWasRequested: false\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        this._onScrollVertical = event => {\n            const { clientHeight, scrollHeight, scrollWidth, scrollTop, scrollLeft } = event.currentTarget;\n            this.setState((prevState) => {\n                const diffOffset = this.preset.field.scrollTop - scrollTop;\n                if (prevState.scrollOffset === scrollTop || this.preset.isShaking(diffOffset)) {\n                    // Scroll position may have been updated by cDM/cDU,\n                    // In which case we don't need to trigger another render,\n                    // And we don't want to update state.isScrolling.\n                    return null;\n                }\n                // FIXME preact 中使用时，该组件会出现触底滚动事件重复触发导致的抖动问题，后续修复\n                // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                this.preset.field = {\n                    scrollHeight: this.itemList.getOffsetSize(),\n                    scrollWidth: scrollWidth,\n                    scrollTop: scrollOffset,\n                    scrollLeft: scrollLeft,\n                    clientHeight: clientHeight,\n                    clientWidth: scrollWidth,\n                    diffOffset: this.preset.field.scrollTop - scrollOffset,\n                };\n                return {\n                    isScrolling: true,\n                    scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                    scrollOffset,\n                    scrollUpdateWasRequested: false\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        this._outerRefSetter = ref => {\n            const { outerRef } = this.props;\n            this._outerRef = ref;\n            if (typeof outerRef === 'function') {\n                outerRef(ref);\n            }\n            else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n                // @ts-ignore\n                outerRef.current = ref;\n            }\n        };\n        this._resetIsScrollingDebounced = () => {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n            this._resetIsScrollingTimeoutId = requestTimeout(this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n        };\n        this._resetIsScrolling = () => {\n            this._resetIsScrollingTimeoutId = null;\n            this.setState({\n                isScrolling: false\n            }, () => {\n                // Clear style cache after state update has been committed.\n                // This way we don't break pure sCU for items that don't use isScrolling param.\n                this.preset.getItemStyleCache(-1, null);\n            });\n        };\n        this.preset = new Preset(props, this.refresh);\n        this.itemList = this.preset.itemList;\n        this.state = {\n            id: this.props.id || this.preset.id,\n            instance: this,\n            isScrolling: false,\n            scrollDirection: 'forward',\n            scrollOffset: typeof this.props.initialScrollOffset === 'number'\n                ? this.props.initialScrollOffset\n                : 0,\n            scrollUpdateWasRequested: false,\n            refreshCount: 0\n        };\n    }\n    static getDerivedStateFromProps(nextProps, prevState) {\n        return validateListProps(nextProps, prevState);\n    }\n    _callPropsCallbacks(prevProps = {}, prevState = {}) {\n        if (typeof this.props.onItemsRendered === 'function') {\n            if (this.props.itemCount > 0) {\n                if (prevProps && prevProps.itemCount !== this.props.itemCount) {\n                    const [overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex] = this._getRangeToRender();\n                    this._callOnItemsRendered(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex);\n                }\n            }\n        }\n        if (typeof this.props.onScroll === 'function') {\n            if (!prevState ||\n                prevState.scrollDirection !== this.state.scrollDirection ||\n                prevState.scrollOffset !== this.state.scrollOffset ||\n                prevState.scrollUpdateWasRequested !== this.state.scrollUpdateWasRequested) {\n                this._callOnScroll(this.state.scrollDirection, this.state.scrollOffset, this.state.scrollUpdateWasRequested, this.preset.field);\n            }\n        }\n        setTimeout(() => {\n            const [startIndex, stopIndex] = this._getRangeToRender();\n            const isHorizontal = this.preset.isHorizontal;\n            for (let index = startIndex; index <= stopIndex; index++) {\n                this._getSizeUploadSync(index, isHorizontal);\n            }\n        }, 0);\n    }\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getRangeToRender() {\n        return this.itemList.getRangeToRender(this.state.scrollDirection, this.state.scrollOffset, this.state.isScrolling);\n    }\n    scrollTo(scrollOffset = 0) {\n        const { enhanced } = this.props;\n        scrollOffset = Math.max(0, scrollOffset);\n        if (this.state.scrollOffset === scrollOffset)\n            return;\n        if (enhanced) {\n            const isHorizontal = this.preset.isHorizontal;\n            const option = {\n                animated: true,\n                duration: 500\n            };\n            if (isHorizontal) {\n                option.left = scrollOffset;\n            }\n            else {\n                option.top = scrollOffset;\n            }\n            return getScrollViewContextNode(`#${this.state.id}`).then((node) => node.scrollTo(option));\n        }\n        this.setState((prevState) => {\n            if (prevState.scrollOffset === scrollOffset) {\n                return null;\n            }\n            return {\n                scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n                scrollOffset: scrollOffset,\n                scrollUpdateWasRequested: true\n            };\n        }, this._resetIsScrollingDebounced);\n    }\n    scrollToItem(index, align = 'auto') {\n        const { itemCount } = this.props;\n        const { scrollOffset } = this.state;\n        index = Math.max(0, Math.min(index, itemCount - 1));\n        this.scrollTo(this.itemList.getOffsetForIndexAndAlignment(index, align, scrollOffset));\n    }\n    componentDidMount() {\n        const { initialScrollOffset } = this.props;\n        if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                outerRef.scrollLeft = initialScrollOffset;\n            }\n            else {\n                outerRef.scrollTop = initialScrollOffset;\n            }\n        }\n        this._callPropsCallbacks();\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { scrollOffset, scrollUpdateWasRequested } = this.state;\n        this.preset.update(this.props);\n        if (scrollUpdateWasRequested && this._outerRef != null) {\n            const outerRef = this._outerRef;\n            if (this.preset.isHorizontal) {\n                if (this.preset.isRtl) {\n                    // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // So we need to determine which browser behavior we're dealing with, and mimic it.\n                    switch (getRTLOffsetType()) {\n                        case 'negative':\n                            outerRef.scrollLeft = -scrollOffset;\n                            break;\n                        case 'positive-ascending':\n                            outerRef.scrollLeft = scrollOffset;\n                            break;\n                        default:\n                            outerRef.scrollLeft = outerRef.scrollWidth - outerRef.clientWidth - scrollOffset;\n                            break;\n                    }\n                }\n                else {\n                    outerRef.scrollLeft = scrollOffset;\n                }\n            }\n            else {\n                outerRef.scrollTop = scrollOffset;\n            }\n        }\n        this._callPropsCallbacks(prevProps, prevState);\n    }\n    componentWillUnmount() {\n        if (this._resetIsScrollingTimeoutId !== null) {\n            cancelTimeout(this._resetIsScrollingTimeoutId);\n        }\n    }\n    render() {\n        const _a = omit(this.props, ['innerElementType', 'innerTagName', 'itemElementType', 'itemTagName', 'outerElementType', 'outerTagName', 'position']), { className, direction, height, innerRef, item, itemCount, itemData, itemKey = defaultItemKey, layout, style, useIsScrolling, width, enhanced = false, renderTop, renderBottom } = _a, rest = __rest(_a, [\"className\", \"direction\", \"height\", \"innerRef\", \"item\", \"itemCount\", \"itemData\", \"itemKey\", \"layout\", \"style\", \"useIsScrolling\", \"width\", \"enhanced\", \"renderTop\", \"renderBottom\"]);\n        const { id, isScrolling, scrollOffset, scrollUpdateWasRequested } = this.state;\n        const isHorizontal = this.preset.isHorizontal;\n        const placeholderCount = this.preset.placeholderCount;\n        const onScroll = isHorizontal\n            ? this._onScrollHorizontal\n            : this._onScrollVertical;\n        const [startIndex, stopIndex] = this._getRangeToRender();\n        const items = [];\n        if (itemCount > 0) {\n            const prevPlaceholder = startIndex < placeholderCount ? startIndex : placeholderCount;\n            items.push(new Array(prevPlaceholder).fill(-1).map((_, index) => React.createElement(this.preset.itemTagName, {\n                key: itemKey(index + startIndex - prevPlaceholder, itemData),\n                style: { display: 'none' }\n            })));\n            for (let index = startIndex; index <= stopIndex; index++) {\n                const style = this.preset.getItemStyle(index);\n                items.push(React.createElement(this.preset.itemTagName, {\n                    key: itemKey(index, itemData),\n                    style\n                }, React.createElement(item, {\n                    id: `${id}-${index}`,\n                    data: itemData,\n                    index,\n                    isScrolling: useIsScrolling ? isScrolling : undefined\n                })));\n            }\n            let restCount = itemCount - stopIndex;\n            restCount = restCount > 0 ? restCount : 0;\n            const postPlaceholder = restCount < placeholderCount ? restCount : placeholderCount;\n            items.push(new Array(postPlaceholder).fill(-1).map((_, index) => React.createElement(this.preset.itemTagName, {\n                key: itemKey(1 + index + stopIndex, itemData),\n                style: { display: 'none' }\n            })));\n        }\n        // Read this value AFTER items have been created,\n        // So their actual sizes (if variable) are taken into consideration.\n        const estimatedTotalSize = convertNumber2PX(this.itemList.getOffsetSize());\n        const outerElementProps = Object.assign(Object.assign({}, rest), { id,\n            className,\n            onScroll, ref: this._outerRefSetter, layout,\n            enhanced, style: Object.assign({ position: 'relative', height: convertNumber2PX(height), width: convertNumber2PX(width), overflow: 'auto', WebkitOverflowScrolling: 'touch', willChange: 'transform', direction }, style) });\n        if (!enhanced) {\n            if (isHorizontal) {\n                outerElementProps.scrollLeft = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollLeft;\n            }\n            else {\n                outerElementProps.scrollTop = scrollUpdateWasRequested ? scrollOffset : this.preset.field.scrollTop;\n            }\n        }\n        if (this.preset.isRelative) {\n            const pre = convertNumber2PX(this.itemList.getOffsetSize(startIndex));\n            return React.createElement(this.preset.outerTagName, outerElementProps, renderTop, React.createElement(this.preset.itemTagName, {\n                key: `${id}-pre`,\n                id: `${id}-pre`,\n                style: {\n                    height: isHorizontal ? '100%' : pre,\n                    width: !isHorizontal ? '100%' : pre\n                }\n            }), React.createElement(this.preset.innerTagName, {\n                ref: innerRef,\n                key: `${id}-inner`,\n                id: `${id}-inner`,\n                style: {\n                    pointerEvents: isScrolling ? 'none' : 'auto',\n                    position: 'relative',\n                }\n            }, items), renderBottom);\n        }\n        else {\n            return React.createElement(this.preset.outerTagName, outerElementProps, renderTop, React.createElement(this.preset.innerTagName, {\n                ref: innerRef,\n                key: `${id}-inner`,\n                id: `${id}-inner`,\n                style: {\n                    height: isHorizontal ? '100%' : estimatedTotalSize,\n                    pointerEvents: isScrolling ? 'none' : 'auto',\n                    position: 'relative',\n                    width: !isHorizontal ? '100%' : estimatedTotalSize\n                }\n            }, items), renderBottom);\n        }\n    }\n}\nList.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false,\n    shouldResetStyleCacheOnItemSizeChange: true\n};\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'default', { enumerable: true, configurable: true, get: function() { return List; } });\n//# sourceMappingURL=list.js.map\n","let devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n    if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n        devWarningsDirection =\n            /* #__PURE__ */\n            new WeakSet();\n        devWarningsTagName =\n            /* #__PURE__ */\n            new WeakSet();\n    }\n}\nconst validateListProps = ({ item, direction, height, layout, itemTagName, innerTagName, outerTagName, width, itemSize }, { instance, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!['number', 'function'].includes(typeof itemSize)) {\n            throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number or function. ' + `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`);\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (innerTagName != null || outerTagName != null || itemTagName != null) {\n            if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n                devWarningsTagName.add(instance);\n                console.warn('The itemTagName、innerTagName and outerTagName props have been deprecated. ' + 'Please use the itemElementType、innerElementType and outerElementType props instead.');\n            }\n        }\n        const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n        switch (direction) {\n            case 'horizontal':\n            case 'vertical':\n                if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n                    devWarningsDirection.add(instance);\n                    console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n                }\n                break;\n            case 'ltr':\n            case 'rtl':\n                // Valid values\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + `\"${direction}\" was specified.`);\n        }\n        switch (layout) {\n            case 'horizontal':\n            case 'vertical':\n                // Valid values\n                break;\n            default:\n                throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + `\"${layout}\" was specified.`);\n        }\n        if (item == null) {\n            throw Error('An invalid \"item\" prop has been specified. ' + 'Value should be a React component. ' + `\"${item === null ? 'null' : typeof item}\" was specified.`);\n        }\n        if (isHorizontal && typeof width !== 'number') {\n            throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + `\"${width === null ? 'null' : typeof width}\" was specified.`);\n        }\n        else if (!isHorizontal && typeof height !== 'number') {\n            throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + `\"${height === null ? 'null' : typeof height}\" was specified.`);\n        }\n    }\n    return null;\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'validateListProps', { enumerable: true, configurable: true, get: function() { return validateListProps; } });\n//# sourceMappingURL=validate.js.map\n"]}