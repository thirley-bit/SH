{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxClassStaticBlock = require(\"@babel/plugin-syntax-class-static-block\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nfunction generateUid(scope, denyList) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n  do {\n    uid = scope._generateUid(name, i);\n    i++;\n  } while (denyList.has(uid));\n  return uid;\n}\nvar _default = (0, _helperPluginUtils.declare)(({\n  types: t,\n  template,\n  assertVersion\n}) => {\n  assertVersion(\"^7.12.0\");\n  return {\n    name: \"proposal-class-static-block\",\n    inherits: _pluginSyntaxClassStaticBlock.default,\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);\n    },\n    visitor: {\n      ClassBody(classBody) {\n        const {\n          scope\n        } = classBody;\n        const privateNames = new Set();\n        const body = classBody.get(\"body\");\n        for (const path of body) {\n          if (path.isPrivate()) {\n            privateNames.add(path.get(\"key.id\").node.name);\n          }\n        }\n        for (const path of body) {\n          if (!path.isStaticBlock()) continue;\n          const staticBlockPrivateId = generateUid(scope, privateNames);\n          privateNames.add(staticBlockPrivateId);\n          const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));\n          let replacement;\n          const blockBody = path.node.body;\n          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n            replacement = t.inheritsComments(blockBody[0].expression, blockBody[0]);\n          } else {\n            replacement = template.expression.ast`(() => { ${blockBody} })()`;\n          }\n          path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));\n        }\n      }\n    }\n  };\n});\nexports.default = _default;\n\n//# sourceMappingURL=index.js.map\n"]}