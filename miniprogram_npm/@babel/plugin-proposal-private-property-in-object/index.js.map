{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxPrivatePropertyInObject = require(\"@babel/plugin-syntax-private-property-in-object\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _default = (0, _helperPluginUtils.declare)((api, opt) => {\n  api.assertVersion(7);\n  const {\n    types: t,\n    template\n  } = api;\n  const {\n    loose\n  } = opt;\n  const classWeakSets = new WeakMap();\n  const fieldsWeakSets = new WeakMap();\n  function unshadow(name, targetScope, scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n  function injectToFieldInit(fieldPath, expr, before = false) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n  function injectInitialization(classPath, init) {\n    let firstFieldPath;\n    let constructorPath;\n    for (const el of classPath.get(\"body.body\")) {\n      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = el;\n      }\n    }\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);\n    }\n  }\n  function getWeakSetId(weakSets, outerClass, reference, name = \"\", inject) {\n    let id = weakSets.get(reference.node);\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      (0, _helperAnnotateAsPure.default)(newExpr);\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n    return t.cloneNode(id);\n  }\n  return {\n    name: \"proposal-private-property-in-object\",\n    inherits: _pluginSyntaxPrivatePropertyInObject.default,\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n        const {\n          name\n        } = node.left.id;\n        let privateElement;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n          privateElement = path.get(\"body.body\").find(({\n            node\n          }) => t.isPrivate(node) && node.key.id.name === name);\n          return !!privateElement;\n        });\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);\n          return;\n        }\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}\n              `);\n          } else {\n            var _outerClass$node$id;\n            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);\n            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n          }\n        } else {\n          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);\n          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n        }\n      }\n    }\n  };\n});\nexports.default = _default;\n\n//# sourceMappingURL=index.js.map\n"]}