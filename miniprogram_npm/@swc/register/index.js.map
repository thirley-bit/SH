{"version":3,"sources":["index.js","nodeWrapper.js","node.js","util.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This file wraps the compiled ES6 module implementation of register so\n * that it can be used both from a standard CommonJS environment, and also\n * from a compiled swc import.\n */\nexports = module.exports = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return register.apply(void 0, args);\n};\nexports.__esModule = true;\nvar node = require(\"./nodeWrapper\");\nvar register = node.default;\nObject.assign(exports, node);\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar node_1 = __importDefault(require(\"./node\"));\nnode_1.default();\nexports.default = node_1.default;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.revert = void 0;\nvar swc = __importStar(require(\"@swc/core\"));\nvar fs_1 = __importDefault(require(\"fs\"));\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar util_1 = require(\"./util\");\nvar path_1 = __importDefault(require(\"path\"));\nvar pirates_1 = require(\"pirates\");\nvar source_map_support_1 = __importDefault(require(\"source-map-support\"));\nvar maps = {};\nvar transformOpts = {};\nvar piratesRevert = null;\nfunction installSourceMapSupport() {\n    source_map_support_1.default.install({\n        handleUncaughtExceptions: false,\n        environment: \"node\",\n        retrieveSourceMap: function (source) {\n            var map = maps && maps[source];\n            if (map) {\n                return {\n                    url: null,\n                    map: map\n                };\n            }\n            else {\n                return null;\n            }\n        }\n    });\n}\nfunction mtime(filename) {\n    return +fs_1.default.statSync(filename).mtime;\n}\nfunction compile(code, filename) {\n    // merge in base options and resolve all the plugins and presets relative to this file\n    var opts = __assign(__assign({ sourceRoot: path_1.default.dirname(filename) + path_1.default.sep }, lodash_clonedeep_1.default(transformOpts)), { filename: filename });\n    if (typeof code !== \"string\") {\n        code = code.toString();\n    }\n    delete opts.only;\n    delete opts.ignore;\n    var output = swc.transformSync(code, __assign(__assign({}, opts), { sourceMaps: opts.sourceMaps === undefined ? true : opts.sourceMaps }));\n    if (output.map) {\n        if (Object.keys(maps).length === 0) {\n            installSourceMapSupport();\n        }\n        maps[filename] = output.map;\n    }\n    return output.code;\n}\nvar compiling = false;\nfunction compileHook(code, filename) {\n    if (compiling)\n        return code;\n    try {\n        compiling = true;\n        return compile(code, filename);\n    }\n    finally {\n        compiling = false;\n    }\n}\nfunction hookExtensions(exts) {\n    if (piratesRevert)\n        piratesRevert();\n    piratesRevert = pirates_1.addHook(compileHook, { exts: exts, ignoreNodeModules: false, matcher: matcher });\n}\nfunction revert() {\n    if (piratesRevert)\n        piratesRevert();\n}\nexports.revert = revert;\nfunction register(opts) {\n    if (opts === void 0) { opts = {}; }\n    // Clone to avoid mutating the arguments object with the 'delete's below.\n    opts = __assign({}, opts);\n    hookExtensions(opts.extensions || swc.DEFAULT_EXTENSIONS);\n    delete opts.extensions;\n    transformOpts = __assign(__assign({}, opts), { caller: __assign({ name: \"@swc/register\" }, (opts.caller || {})) });\n    var _a = transformOpts.cwd, cwd = _a === void 0 ? \".\" : _a;\n    // Ensure that the working directory is resolved up front so that\n    // things don't break if it changes later.\n    cwd = transformOpts.cwd = path_1.default.resolve(cwd);\n    if (transformOpts.ignore === undefined && transformOpts.only === undefined) {\n        transformOpts.only = [\n            // Only compile things inside the current working directory.\n            new RegExp(\"^\" + util_1.escapeRegExp(cwd), \"i\")\n        ];\n        transformOpts.ignore = [\n            // Ignore any node_modules inside the current working directory.\n            new RegExp(\"^\" +\n                util_1.escapeRegExp(cwd) +\n                \"(?:\" +\n                path_1.default.sep +\n                \".*)?\" +\n                util_1.escapeRegExp(path_1.default.sep + \"node_modules\" + path_1.default.sep), \"i\")\n        ];\n    }\n}\nexports.default = register;\n/**\n * https://github.com/babel/babel/blob/7acc68a86b70c6aadfef28e10e83d0adb2523807/packages/babel-core/src/config/config-chain.ts\n *\n * Tests if a filename should be ignored based on \"ignore\" and \"only\" options.\n */\nfunction matcher(filename, dirname) {\n    if (!dirname) {\n        dirname = transformOpts.cwd || path_1.default.dirname(filename);\n    }\n    return shouldCompile(transformOpts.ignore, transformOpts.only, filename, dirname);\n}\nfunction shouldCompile(ignore, only, filename, dirname) {\n    if (ignore && matchPattern(ignore, dirname, filename)) {\n        return false;\n    }\n    if (only && !matchPattern(only, dirname, filename)) {\n        return false;\n    }\n    return true;\n}\n/**\n * https://github.com/babel/babel/blob/7acc68a86b70c6aadfef28e10e83d0adb2523807/packages/babel-core/src/config/config-chain.ts\n *\n * Returns result of calling function with filename if pattern is a function.\n * Otherwise returns result of matching pattern Regex with filename.\n */\nfunction matchPattern(patterns, dirname, pathToTest) {\n    return patterns.some(function (pattern) {\n        if (typeof pattern === \"function\") {\n            return Boolean(pattern(pathToTest, { dirname: dirname }));\n        }\n        if (typeof pathToTest !== \"string\") {\n            throw new Error(\"Configuration contains string/RegExp file pattern, but no filename was provided.\");\n        }\n        if (typeof pattern === \"string\") {\n            pattern = util_1.pathPatternToRegex(pattern, dirname);\n        }\n        return pattern.test(path_1.default.resolve(dirname, pathToTest));\n    });\n}\n","\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pathPatternToRegex = exports.escapeRegExp = void 0;\nvar path_1 = __importDefault(require(\"path\"));\nfunction escapeRegExp(string) {\n    return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\nexports.escapeRegExp = escapeRegExp;\n/**\n * Babel <https://babeljs.io/>\n * Released under MIT license <https://github.com/babel/babel/blob/main/LICENSE>\n */\nvar sep = \"\\\\\" + path_1.default.sep;\nvar endSep = \"(?:\" + sep + \"|$)\";\nvar substitution = \"[^\" + sep + \"]+\";\nvar starPat = \"(?:\" + substitution + sep + \")\";\nvar starPatLast = \"(?:\" + substitution + endSep + \")\";\nvar starStarPat = starPat + \"*?\";\nvar starStarPatLast = starPat + \"*?\" + starPatLast + \"?\";\n/**\n * https://github.com/babel/babel/blob/7acc68a86b70c6aadfef28e10e83d0adb2523807/packages/babel-core/src/config/pattern-to-regex.ts\n *\n * Implement basic pattern matching that will allow users to do the simple\n * tests with * and **. If users want full complex pattern matching, then can\n * always use regex matching, or function validation.\n */\nfunction pathPatternToRegex(pattern, dirname) {\n    var parts = path_1.default.resolve(dirname, pattern).split(path_1.default.sep);\n    return new RegExp(__spreadArrays([\n        \"^\"\n    ], parts.map(function (part, i) {\n        var last = i === parts.length - 1;\n        // ** matches 0 or more path parts.\n        if (part === \"**\")\n            return last ? starStarPatLast : starStarPat;\n        // * matches 1 path part.\n        if (part === \"*\")\n            return last ? starPatLast : starPat;\n        // *.ext matches a wildcard with an extension.\n        if (part.indexOf(\"*.\") === 0) {\n            return (substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep));\n        }\n        // Otherwise match the pattern text.\n        return escapeRegExp(part) + (last ? endSep : sep);\n    })).join(\"\"));\n}\nexports.pathPatternToRegex = pathPatternToRegex;\n"]}