{"version":3,"sources":["index.js","fields.js","typescript.js","decorators.js","misc.js","features.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AENA,AJYA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\nObject.defineProperty(exports, \"buildCheckInRHS\", {\n  enumerable: true,\n  get: function () {\n    return _fields.buildCheckInRHS;\n  }\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"enableFeature\", {\n  enumerable: true,\n  get: function () {\n    return _features.enableFeature;\n  }\n});\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nvar _core = require(\"@babel/core\");\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\nvar _fields = require(\"./fields\");\nvar _decorators = require(\"./decorators\");\nvar _misc = require(\"./misc\");\nvar _features = require(\"./features\");\nvar _typescript = require(\"./typescript\");\nconst version = \"7.21.0\".split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-class-features/version\";\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api = {\n    assumption: () => void 0\n  },\n  inherits\n}) {\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(`Cannot enable both the \"privateFieldsAsProperties\" and ` + `\"privateFieldsAsSymbols\" assumptions as the same time.`);\n  }\n  const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;\n  if (loose === true) {\n    const explicit = [];\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(`[${name}]: You are using the \"loose: true\" option and you are` + ` explicitly setting a value for the ${explicit.join(\" and \")}` + ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\\n` + `\\t\"assumptions\": {\\n` + `\\t\\t\"setPublicClassFields\": true,\\n` + `\\t\\t\"privateFieldsAsSymbols\": true\\n` + `\\t}`);\n    }\n  }\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n    pre(file) {\n      (0, _features.enableFeature)(file, feature, loose);\n      if (!file.get(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n    visitor: {\n      Class(path, {\n        file\n      }) {\n        if (file.get(versionKey) !== version) return;\n        if (!(0, _features.shouldTransform)(path, file)) return;\n        if (path.isClassDeclaration()) (0, _typescript.assertFieldTransformed)(path);\n        const loose = (0, _features.isLoose)(file, feature);\n        let constructor;\n        const isDecorated = (0, _decorators.hasDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n        for (const path of body.get(\"body\")) {\n          if ((path.isClassProperty() || path.isClassMethod()) && path.node.computed) {\n            computedPaths.push(path);\n          }\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n              privateNames.add(name);\n            }\n          }\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (path.isProperty() || path.isPrivate() || path.isStaticBlock != null && path.isStaticBlock()) {\n              props.push(path);\n            }\n          }\n        }\n        {\n          if (!props.length && !isDecorated) return;\n        }\n        const innerBinding = path.node.id;\n        let ref;\n        if (!innerBinding || path.isClassExpression()) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = _core.types.cloneNode(path.node.id);\n        }\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, privateFieldsAsSymbols != null ? privateFieldsAsSymbols : false, file);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, {\n          privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,\n          noDocumentAll,\n          innerBinding\n        }, file);\n        let keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;\n        {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({\n              instanceNodes,\n              wrapClass\n            } = (0, _decorators.buildDecoratedClass)(ref, path, elements, file));\n          } else {\n            keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);\n            ({\n              staticNodes,\n              pureStaticNodes,\n              instanceNodes,\n              wrapClass\n            } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding));\n          }\n        }\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            {\n              if (isDecorated) return;\n            }\n            for (const prop of props) {\n              if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);\n        }\n      },\n      ExportDefaultDeclaration(path, {\n        file\n      }) {\n        {\n          if (file.get(versionKey) !== version) return;\n          const decl = path.get(\"declaration\");\n          if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n            if (decl.node.id) {\n              (0, _helperSplitExportDeclaration.default)(path);\n            } else {\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildCheckInRHS = buildCheckInRHS;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nvar _core = require(\"@babel/core\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\nvar ts = require(\"./typescript\");\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: prop.node.static,\n        method: !prop.isProperty()\n      };\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n        } else if (prop.node.kind === \"set\") {\n          update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\nfunction buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {\n  const initNodes = [];\n  for (const [name, value] of privateNamesMap) {\n    const {\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n    const id = _core.types.cloneNode(value.id);\n    let init;\n    if (privateFieldsAsProperties) {\n      init = _core.types.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [_core.types.stringLiteral(name)]);\n    } else if (privateFieldsAsSymbols) {\n      init = _core.types.callExpression(_core.types.identifier(\"Symbol\"), [_core.types.stringLiteral(name)]);\n    } else if (!isStatic) {\n      init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"), []);\n    }\n    if (init) {\n      (0, _helperAnnotateAsPure.default)(init);\n      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n  return initNodes;\n}\nfunction privateNameVisitorFactory(visitor) {\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]);\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n      if (!redeclared.length) {\n        return;\n      }\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n  });\n  return privateNameVisitor;\n}\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path, {\n    noDocumentAll\n  }) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath, noDocumentAll);\n  }\n});\nfunction unshadow(name, scope, innerBinding) {\n  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {\n    var _scope;\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\nfunction buildCheckInRHS(rhs, file, inRHSIsObject) {\n  if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper(\"checkInRHS\"))) return rhs;\n  return _core.types.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path, {\n    file\n  }) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!_core.types.isPrivateName(left)) return;\n    const {\n      privateFieldsAsProperties,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n    if (privateFieldsAsProperties) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id)})\n      `);\n      return;\n    }\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`);\n      return;\n    }\n    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);\n  }\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n    if (!memo) {\n      return;\n    }\n    this.memoiser.set(object, memo, count);\n  },\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n    return _core.types.cloneNode(object);\n  },\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      innerBinding\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      unshadow(classRef.name, member.scope, innerBinding);\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n    if (isMethod) {\n      if (isAccessor) {\n        if (!getId && setId) {\n          if (file.availableHelper(\"writeOnlyError\")) {\n            return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper(\"writeOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n          }\n          console.warn(`@babel/helpers is outdated, update it to silence this warning.`);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n      return _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper(\"readOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n  destructureSet(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n    if (isStatic) {\n      try {\n        var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n      } catch (_unused) {\n        throw new Error(\"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" + \"please update @babel/helpers to the latest version.\");\n      }\n      return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n    }\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: _core.types.cloneNode(object),\n      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)\n    });\n  },\n  set() {\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n  simpleSet(member) {\n    return this.get(member);\n  },\n  destructureSet(member) {\n    return this.get(member);\n  },\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n};\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, {\n  privateFieldsAsProperties,\n  noDocumentAll,\n  innerBinding\n}, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler, {\n    noDocumentAll,\n    innerBinding\n  }));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding\n  });\n}\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    `, prop);\n}\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })`, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)},\n      {\n        writable: true,\n        value: ${value}\n      },\n    )`, prop);\n}\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        var ${_core.types.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        }\n      `, prop);\n  }\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n      var ${_core.types.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      };\n    `, prop);\n}\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  if (methodId) {\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `, prop);\n  }\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      `, prop);\n  }\n}\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);\n  }\n  return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);\n}\nfunction buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId\n  } = privateName;\n  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n    initAdded: true\n  }));\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        `, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )`, prop);\n}\nfunction buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id\n  } = privateName;\n  {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)}\n    )`, prop);\n}\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);\n}\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);\n}\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `, prop);\n  }\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `, prop);\n}\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n  let declId = methodId;\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n  return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);\n}\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    const parent = path.findParent(path => !(0, _helperSkipTransparentExpressionWrappers.isTransparentExprWrapper)(path.node));\n    if (_core.types.isUnaryExpression(parent.node, {\n      operator: \"delete\"\n    })) {\n      path.parentPath.replaceWith(_core.types.booleanLiteral(true));\n      return;\n    }\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  },\n  MetaProperty(path) {\n    const meta = path.get(\"meta\");\n    const property = path.get(\"property\");\n    const {\n      scope\n    } = path;\n    if (meta.isIdentifier({\n      name: \"new\"\n    }) && property.isIdentifier({\n      name: \"target\"\n    })) {\n      path.replaceWith(scope.buildUndefinedNode());\n    }\n  }\n}, _helperEnvironmentVisitor.default]);\nconst innerReferencesVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  }\n};\nfunction replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {\n  var _state$classRef;\n  const state = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n    getObjectRef() {\n      state.needsClassRef = true;\n      return _core.types.isStaticBlock != null && _core.types.isStaticBlock(path.node) || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n  });\n  replacer.replace();\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n  if (innerBindingRef != null && (_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n  return state.needsClassRef;\n}\nfunction isNameOrLength({\n  key,\n  computed\n}) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\nfunction inheritPropComments(node, prop) {\n  _core.types.inheritLeadingComments(node, prop.node);\n  _core.types.inheritInnerComments(node, prop.node);\n  return node;\n}\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {\n  let needsClassRef = false;\n  let injectSuperRef;\n  const staticNodes = [];\n  const instanceNodes = [];\n  const pureStaticNodes = [];\n  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {\n    var _injectSuperRef;\n    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n    return injectSuperRef;\n  };\n  for (const prop of props) {\n    prop.isClassProperty() && ts.assertFieldTransformed(prop);\n    const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();\n    if (isStatic || isMethod && isPrivate || isStaticBlock) {\n      const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);\n      needsClassRef = needsClassRef || replaced;\n    }\n    switch (true) {\n      case isStaticBlock:\n        {\n          const blockBody = prop.node.body;\n          if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {\n            staticNodes.push(inheritPropComments(blockBody[0], prop));\n          } else {\n            staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));\n          }\n          break;\n        }\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n          break;\n        }\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        break;\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n      if (injectSuperRef) {\n        path.scope.push({\n          id: _core.types.cloneNode(injectSuperRef)\n        });\n        path.set(\"superClass\", _core.types.assignmentExpression(\"=\", injectSuperRef, path.node.superClass));\n      }\n      if (!needsClassRef) return path;\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n      return path;\n    }\n  };\n}\n\n//# sourceMappingURL=fields.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertFieldTransformed = assertFieldTransformed;\nfunction assertFieldTransformed(path) {\n  if (path.node.declare) {\n    throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by ` + `@babel/plugin-transform-typescript.\\n` + `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` + `that it runs before any plugin related to additional class features:\\n` + ` - @babel/plugin-proposal-class-properties\\n` + ` - @babel/plugin-proposal-private-methods\\n` + ` - @babel/plugin-proposal-decorators`);\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildDecoratedClass = buildDecoratedClass;\nexports.hasDecorators = hasDecorators;\nexports.hasOwnDecorators = hasOwnDecorators;\nvar _core = require(\"@babel/core\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\nfunction takeDecorators(node) {\n  let result;\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n  node.decorators = undefined;\n  return result;\n}\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\nfunction extractElementDescriptor(file, classRef, superRef, path) {\n  const isMethod = path.isClassMethod();\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n  if (path.node.type === \"ClassAccessorProperty\") {\n    throw path.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n  if (path.node.type === \"StaticBlock\") {\n    throw path.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`);\n  }\n  const {\n    node,\n    scope\n  } = path;\n  if (!path.isTSDeclareMethod()) {\n    new _helperReplaceSupers.default({\n      methodPath: path,\n      objectRef: classRef,\n      superRef,\n      file,\n      refToPreserve: classRef\n    }).replace();\n  }\n  const properties = [prop(\"kind\", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n  if (_core.types.isClassMethod(node)) {\n    const id = node.computed ? null : node.key;\n    const transformed = _core.types.toExpression(node);\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node: transformed,\n      id,\n      scope\n    }) || transformed));\n  } else if (_core.types.isClassProperty(node) && node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\nfunction addDecorateHelper(file) {\n  return file.addHelper(\"decorate\");\n}\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n  const classDecorators = takeDecorators(node);\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract && element.node.type !== \"TSIndexSignature\").map(path => extractElementDescriptor(file, node.id, superId, path)));\n  const wrapperCall = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n  let replacement = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n  if (isDeclaration) {\n    replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n  return {\n    instanceNodes: [_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`],\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n  };\n}\n\n//# sourceMappingURL=decorators.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComputedKeys = extractComputedKeys;\nexports.injectInitialization = injectInitialization;\nvar _core = require(\"@babel/core\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n}, _helperEnvironmentVisitor.default]);\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n  ReferencedIdentifier(path, {\n    scope\n  }) {\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n};\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        bareSuper.insertAfter(nodes);\n        isFirst = false;\n      } else {\n        bareSuper.insertAfter(nodes.map(n => _core.types.cloneNode(n)));\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\nfunction extractComputedKeys(path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n    const computedNode = computedPath.node;\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n  return declarations;\n}\n\n//# sourceMappingURL=misc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FEATURES = void 0;\nexports.enableFeature = enableFeature;\nexports.isLoose = isLoose;\nexports.shouldTransform = shouldTransform;\nvar _decorators = require(\"./decorators\");\nconst FEATURES = Object.freeze({\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3,\n  privateIn: 1 << 4,\n  staticBlocks: 1 << 5\n});\nexports.FEATURES = FEATURES;\nconst featuresSameLoose = new Map([[FEATURES.fields, \"@babel/plugin-proposal-class-properties\"], [FEATURES.privateMethods, \"@babel/plugin-proposal-private-methods\"], [FEATURES.privateIn, \"@babel/plugin-proposal-private-property-in-object\"]]);\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\nconst looseLowPriorityKey = \"@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing\";\nfunction enableFeature(file, feature, loose) {\n  if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n    if (loose === \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, true);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else if (loose === \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\") {\n      setLoose(file, feature, false);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else {\n      setLoose(file, feature, loose);\n    }\n  }\n  let resolvedLoose;\n  let higherPriorityPluginName;\n  for (const [mask, name] of featuresSameLoose) {\n    if (!hasFeature(file, mask)) continue;\n    const loose = isLoose(file, mask);\n    if (canIgnoreLoose(file, mask)) {\n      continue;\n    } else if (resolvedLoose === !loose) {\n      throw new Error(\"'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, \" + \"@babel/plugin-proposal-private-methods and \" + \"@babel/plugin-proposal-private-property-in-object (when they are enabled).\");\n    } else {\n      resolvedLoose = loose;\n      higherPriorityPluginName = name;\n    }\n  }\n  if (resolvedLoose !== undefined) {\n    for (const [mask, name] of featuresSameLoose) {\n      if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {\n        setLoose(file, mask, resolvedLoose);\n        console.warn(`Though the \"loose\" option was set to \"${!resolvedLoose}\" in your @babel/preset-env ` + `config, it will not be used for ${name} since the \"loose\" mode option was set to ` + `\"${resolvedLoose}\" for ${higherPriorityPluginName}.\\nThe \"loose\" option must be the ` + `same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods ` + `and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can ` + `silence this warning by explicitly adding\\n` + `\\t[\"${name}\", { \"loose\": ${resolvedLoose} }]\\n` + `to the \"plugins\" section of your Babel config.`);\n      }\n    }\n  }\n}\nfunction hasFeature(file, feature) {\n  return !!(file.get(featuresKey) & feature);\n}\nfunction isLoose(file, feature) {\n  return !!(file.get(looseKey) & feature);\n}\nfunction setLoose(file, feature, loose) {\n  if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);\n  file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);\n}\nfunction canIgnoreLoose(file, feature) {\n  return !!(file.get(looseLowPriorityKey) & feature);\n}\nfunction shouldTransform(path, file) {\n  let decoratorPath = null;\n  let publicFieldPath = null;\n  let privateFieldPath = null;\n  let privateMethodPath = null;\n  let staticBlockPath = null;\n  if ((0, _decorators.hasOwnDecorators)(path.node)) {\n    decoratorPath = path.get(\"decorators.0\");\n  }\n  for (const el of path.get(\"body.body\")) {\n    if (!decoratorPath && (0, _decorators.hasOwnDecorators)(el.node)) {\n      decoratorPath = el.get(\"decorators.0\");\n    }\n    if (!publicFieldPath && el.isClassProperty()) {\n      publicFieldPath = el;\n    }\n    if (!privateFieldPath && el.isClassPrivateProperty()) {\n      privateFieldPath = el;\n    }\n    if (!privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod()) {\n      privateMethodPath = el;\n    }\n    if (!staticBlockPath && el.isStaticBlock != null && el.isStaticBlock()) {\n      staticBlockPath = el;\n    }\n  }\n  if (decoratorPath && privateFieldPath) {\n    throw privateFieldPath.buildCodeFrameError(\"Private fields in decorated classes are not supported yet.\");\n  }\n  if (decoratorPath && privateMethodPath) {\n    throw privateMethodPath.buildCodeFrameError(\"Private methods in decorated classes are not supported yet.\");\n  }\n  if (decoratorPath && !hasFeature(file, FEATURES.decorators)) {\n    throw path.buildCodeFrameError(\"Decorators are not enabled.\" + \"\\nIf you are using \" + '[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }], ' + 'make sure it comes *before* \"@babel/plugin-proposal-class-properties\" ' + \"and enable loose mode, like so:\\n\" + '\\t[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }]\\n' + '\\t[\"@babel/plugin-proposal-class-properties\", { \"loose\": true }]');\n  }\n  if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) {\n    throw privateMethodPath.buildCodeFrameError(\"Class private methods are not enabled. \" + \"Please add `@babel/plugin-proposal-private-methods` to your configuration.\");\n  }\n  if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods)) {\n    throw path.buildCodeFrameError(\"Class fields are not enabled. \" + \"Please add `@babel/plugin-proposal-class-properties` to your configuration.\");\n  }\n  if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) {\n    throw path.buildCodeFrameError(\"Static class blocks are not enabled. \" + \"Please add `@babel/plugin-proposal-class-static-block` to your configuration.\");\n  }\n  if (decoratorPath || privateMethodPath || staticBlockPath) {\n    return true;\n  }\n  if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields)) {\n    return true;\n  }\n  return false;\n}\n\n//# sourceMappingURL=features.js.map\n"]}