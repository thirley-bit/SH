{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar syntaxOptionalChaining = require('@babel/plugin-syntax-optional-chaining');\nvar core = require('@babel/core');\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\nfunction findOutermostTransparentParent(path) {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n\nconst {\n  ast\n} = core.template.expression;\nfunction isSimpleMemberExpression(expression) {\n  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);\n  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n}\nfunction needsMemoize(path) {\n  let optionalPath = path;\n  const {\n    scope\n  } = path;\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get(\"object\") : optionalPath.get(\"callee\"));\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n    optionalPath = childPath;\n  }\n}\nfunction transform(path, {\n  pureGetters,\n  noDocumentAll\n}) {\n  const {\n    scope\n  } = path;\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const {\n    parentPath\n  } = maybeWrapped;\n  const willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);\n  let isDeleteOperation = false;\n  const parentIsCall = parentPath.isCallExpression({\n    callee: maybeWrapped.node\n  }) && path.isOptionalMemberExpression();\n  const optionals = [];\n  let optionalPath = path;\n  if (scope.path.isPattern() && needsMemoize(optionalPath)) {\n    path.replaceWith(core.template.ast`(() => ${path.node})()`);\n    return;\n  }\n  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {\n    const {\n      node\n    } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath.node.type = \"MemberExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath.node.type = \"CallExpression\";\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n  let replacementPath = path;\n  if (parentPath.isUnaryExpression({\n    operator: \"delete\"\n  })) {\n    replacementPath = parentPath;\n    isDeleteOperation = true;\n  }\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i];\n    const isCall = core.types.isCallExpression(node);\n    const chainWithTypes = isCall ? node.callee : node.object;\n    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);\n    let ref;\n    let check;\n    if (isCall && core.types.isIdentifier(chain, {\n      name: \"eval\"\n    })) {\n      check = ref = chain;\n      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      check = ref = node.callee;\n    } else {\n      ref = scope.maybeGenerateMemoised(chain);\n      if (ref) {\n        check = core.types.assignmentExpression(\"=\", core.types.cloneNode(ref), chainWithTypes);\n        isCall ? node.callee = ref : node.object = ref;\n      } else {\n        check = ref = chainWithTypes;\n      }\n    }\n    if (isCall && core.types.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        node.callee = chainWithTypes;\n      } else {\n        const {\n          object\n        } = chain;\n        let context;\n        if (core.types.isSuper(object)) {\n          context = core.types.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = core.types.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n        node.arguments.unshift(core.types.cloneNode(context));\n        node.callee = core.types.memberExpression(node.callee, core.types.identifier(\"call\"));\n      }\n    }\n    let replacement = replacementPath.node;\n    if (i === 0 && parentIsCall) {\n      var _baseRef;\n      const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);\n      let baseRef;\n      if (!pureGetters || !isSimpleMemberExpression(object)) {\n        baseRef = scope.maybeGenerateMemoised(object);\n        if (baseRef) {\n          replacement.object = core.types.assignmentExpression(\"=\", baseRef, object);\n        }\n      }\n      replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier(\"bind\")), [core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n    }\n    if (willReplacementCastToBoolean) {\n      const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`\n            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;\n      replacementPath.replaceWith(core.types.logicalExpression(\"&&\", nonNullishCheck, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"right\"));\n    } else {\n      const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`\n            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`;\n      const returnValue = isDeleteOperation ? ast`true` : ast`void 0`;\n      replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement));\n      replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get(\"alternate\"));\n    }\n  }\n}\n\nvar index = helperPluginUtils.declare((api, options) => {\n  var _api$assumption, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : loose;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : loose;\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: syntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        transform(path, {\n          noDocumentAll,\n          pureGetters\n        });\n      }\n    }\n  };\n});\n\nexports[\"default\"] = index;\nexports.transform = transform;\n//# sourceMappingURL=index.js.map\n"]}