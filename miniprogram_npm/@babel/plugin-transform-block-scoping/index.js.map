{"version":3,"sources":["index.js","loop.js","validation.js","annex-B_3_3.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _core = require(\"@babel/core\");\nvar _loop = require(\"./loop\");\nvar _validation = require(\"./validation\");\nvar _annexB_3_ = require(\"./annex-B_3_3\");\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n  return {\n    name: \"transform-block-scoping\",\n    visitor: _core.traverse.visitors.merge([_annexB_3_.annexB33FunctionsVisitor, {\n      Loop(path, state) {\n        const isForStatement = path.isForStatement();\n        const headPath = isForStatement ? path.get(\"init\") : path.isForXStatement() ? path.get(\"left\") : null;\n        let needsBodyWrap = false;\n        const markNeedsBodyWrap = () => {\n          if (throwIfClosureRequired) {\n            throw path.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n          }\n          needsBodyWrap = true;\n        };\n        const body = path.get(\"body\");\n        let bodyScope;\n        if (body.isBlockStatement()) {\n          bodyScope = body.scope;\n          const bindings = (0, _loop.getLoopBodyBindings)(path);\n          for (const binding of bindings) {\n            const {\n              capturedInClosure\n            } = (0, _loop.getUsageInBody)(binding, path);\n            if (capturedInClosure) markNeedsBodyWrap();\n          }\n        }\n        const captured = [];\n        const updatedBindingsUsages = new Map();\n        if (headPath && isBlockScoped(headPath.node)) {\n          const names = Object.keys(headPath.getBindingIdentifiers());\n          const headScope = headPath.scope;\n          for (let name of names) {\n            var _bodyScope;\n            if ((_bodyScope = bodyScope) != null && _bodyScope.hasOwnBinding(name)) continue;\n            let binding = headScope.getOwnBinding(name);\n            if (!binding) {\n              headScope.crawl();\n              binding = headScope.getOwnBinding(name);\n            }\n            const {\n              usages,\n              capturedInClosure,\n              hasConstantViolations\n            } = (0, _loop.getUsageInBody)(binding, path);\n            if (headScope.parent.hasBinding(name) || headScope.parent.hasGlobal(name)) {\n              const newName = headScope.generateUid(name);\n              headScope.rename(name, newName);\n              name = newName;\n            }\n            if (capturedInClosure) {\n              markNeedsBodyWrap();\n              captured.push(name);\n            }\n            if (isForStatement && hasConstantViolations) {\n              updatedBindingsUsages.set(name, usages);\n            }\n          }\n        }\n        if (needsBodyWrap) {\n          const varPath = (0, _loop.wrapLoopBody)(path, captured, updatedBindingsUsages);\n          if (headPath != null && headPath.isVariableDeclaration()) {\n            transformBlockScopedVariable(headPath, state, tdzEnabled);\n          }\n          varPath.get(\"declarations.0.init\").unwrapFunctionEnvironment();\n        }\n      },\n      VariableDeclaration(path, state) {\n        transformBlockScopedVariable(path, state, tdzEnabled);\n      },\n      ClassDeclaration(path) {\n        const {\n          id\n        } = path.node;\n        if (!id) return;\n        const {\n          scope\n        } = path.parentPath;\n        if (!(0, _annexB_3_.isVarScope)(scope) && scope.parent.hasBinding(id.name, {\n          noUids: true\n        })) {\n          path.scope.rename(id.name);\n        }\n      }\n    }])\n  };\n});\nexports.default = _default;\nconst conflictingFunctionsVisitor = {\n  Scope(path, {\n    names\n  }) {\n    for (const name of names) {\n      const binding = path.scope.getOwnBinding(name);\n      if (binding && binding.kind === \"hoisted\") {\n        path.scope.rename(name);\n      }\n    }\n  },\n  \"Expression|Declaration\"(path) {\n    path.skip();\n  }\n};\nfunction transformBlockScopedVariable(path, state, tdzEnabled) {\n  if (!isBlockScoped(path.node)) return;\n  const dynamicTDZNames = (0, _validation.validateUsage)(path, state, tdzEnabled);\n  path.node.kind = \"var\";\n  const bindingNames = Object.keys(path.getBindingIdentifiers());\n  for (const name of bindingNames) {\n    const binding = path.scope.getOwnBinding(name);\n    if (!binding) continue;\n    binding.kind = \"var\";\n  }\n  if (isInLoop(path) && !(0, _loop.isVarInLoopHead)(path) || dynamicTDZNames.length > 0) {\n    for (const decl of path.node.declarations) {\n      var _decl$init;\n      (_decl$init = decl.init) != null ? _decl$init : decl.init = path.scope.buildUndefinedNode();\n    }\n  }\n  const blockScope = path.scope;\n  const varScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n  if (varScope !== blockScope) {\n    for (const name of bindingNames) {\n      let newName = name;\n      if (blockScope.parent.hasBinding(name, {\n        noUids: true\n      }) || blockScope.parent.hasGlobal(name)) {\n        newName = blockScope.generateUid(name);\n        blockScope.rename(name, newName);\n      }\n      blockScope.moveBindingTo(newName, varScope);\n    }\n  }\n  blockScope.path.traverse(conflictingFunctionsVisitor, {\n    names: bindingNames\n  });\n  for (const name of dynamicTDZNames) {\n    path.scope.push({\n      id: _core.types.identifier(name),\n      init: state.addHelper(\"temporalUndefined\")\n    });\n  }\n}\nfunction isLetOrConst(kind) {\n  return kind === \"let\" || kind === \"const\";\n}\nfunction isInLoop(path) {\n  if (!path.parentPath) return false;\n  if (path.parentPath.isLoop()) return true;\n  if (path.parentPath.isFunctionParent()) return false;\n  return isInLoop(path.parentPath);\n}\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) {\n    return true;\n  }\n  if (!isLetOrConst(node.kind) && node.kind !== \"using\") {\n    return false;\n  }\n  return true;\n}\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLoopBodyBindings = getLoopBodyBindings;\nexports.getUsageInBody = getUsageInBody;\nexports.isVarInLoopHead = isVarInLoopHead;\nexports.wrapLoopBody = wrapLoopBody;\nvar _core = require(\"@babel/core\");\nconst collectLoopBodyBindingsVisitor = {\n  \"Expression|Declaration|Loop\"(path) {\n    path.skip();\n  },\n  Scope(path, state) {\n    if (path.isFunctionParent()) path.skip();\n    const {\n      bindings\n    } = path.scope;\n    for (const name of Object.keys(bindings)) {\n      const binding = bindings[name];\n      if (binding.kind === \"let\" || binding.kind === \"const\" || binding.kind === \"hoisted\") {\n        state.blockScoped.push(binding);\n      }\n    }\n  }\n};\nfunction getLoopBodyBindings(loopPath) {\n  const state = {\n    blockScoped: []\n  };\n  loopPath.traverse(collectLoopBodyBindingsVisitor, state);\n  return state.blockScoped;\n}\nfunction getUsageInBody(binding, loopPath) {\n  const seen = new WeakSet();\n  let capturedInClosure = false;\n  const constantViolations = filterMap(binding.constantViolations, path => {\n    const {\n      inBody,\n      inClosure\n    } = relativeLoopLocation(path, loopPath);\n    if (!inBody) return null;\n    capturedInClosure || (capturedInClosure = inClosure);\n    const id = path.isUpdateExpression() ? path.get(\"argument\") : path.isAssignmentExpression() ? path.get(\"left\") : null;\n    if (id) seen.add(id.node);\n    return id;\n  });\n  const references = filterMap(binding.referencePaths, path => {\n    if (seen.has(path.node)) return null;\n    const {\n      inBody,\n      inClosure\n    } = relativeLoopLocation(path, loopPath);\n    if (!inBody) return null;\n    capturedInClosure || (capturedInClosure = inClosure);\n    return path;\n  });\n  return {\n    capturedInClosure,\n    hasConstantViolations: constantViolations.length > 0,\n    usages: references.concat(constantViolations)\n  };\n}\nfunction relativeLoopLocation(path, loopPath) {\n  const bodyPath = loopPath.get(\"body\");\n  let inClosure = false;\n  for (let currPath = path; currPath; currPath = currPath.parentPath) {\n    if (currPath.isFunction() || currPath.isClass()) inClosure = true;\n    if (currPath === bodyPath) {\n      return {\n        inBody: true,\n        inClosure\n      };\n    } else if (currPath === loopPath) {\n      return {\n        inBody: false,\n        inClosure\n      };\n    }\n  }\n  throw new Error(\"Internal Babel error: path is not in loop. Please report this as a bug.\");\n}\nconst collectCompletionsAndVarsVisitor = {\n  Function(path) {\n    path.skip();\n  },\n  LabeledStatement: {\n    enter({\n      node\n    }, state) {\n      state.labelsStack.push(node.label.name);\n    },\n    exit({\n      node\n    }, state) {\n      const popped = state.labelsStack.pop();\n      if (popped !== node.label.name) {\n        throw new Error(\"Assertion failure. Please report this bug to Babel.\");\n      }\n    }\n  },\n  Loop: {\n    enter(_, state) {\n      state.labellessContinueTargets++;\n      state.labellessBreakTargets++;\n    },\n    exit(_, state) {\n      state.labellessContinueTargets--;\n      state.labellessBreakTargets--;\n    }\n  },\n  SwitchStatement: {\n    enter(_, state) {\n      state.labellessBreakTargets++;\n    },\n    exit(_, state) {\n      state.labellessBreakTargets--;\n    }\n  },\n  \"BreakStatement|ContinueStatement\"(path, state) {\n    const {\n      label\n    } = path.node;\n    if (label) {\n      if (state.labelsStack.includes(label.name)) return;\n    } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0) {\n      return;\n    }\n    state.breaksContinues.push(path);\n  },\n  ReturnStatement(path, state) {\n    state.returns.push(path);\n  },\n  VariableDeclaration(path, state) {\n    if (path.parent === state.loopNode && isVarInLoopHead(path)) return;\n    if (path.node.kind === \"var\") state.vars.push(path);\n  }\n};\nfunction wrapLoopBody(loopPath, captured, updatedBindingsUsages) {\n  const loopNode = loopPath.node;\n  const state = {\n    breaksContinues: [],\n    returns: [],\n    labelsStack: [],\n    labellessBreakTargets: 0,\n    labellessContinueTargets: 0,\n    vars: [],\n    loopNode\n  };\n  loopPath.traverse(collectCompletionsAndVarsVisitor, state);\n  const callArgs = [];\n  const closureParams = [];\n  const updater = [];\n  for (const [name, updatedUsage] of updatedBindingsUsages) {\n    callArgs.push(_core.types.identifier(name));\n    const innerName = loopPath.scope.generateUid(name);\n    closureParams.push(_core.types.identifier(innerName));\n    updater.push(_core.types.assignmentExpression(\"=\", _core.types.identifier(name), _core.types.identifier(innerName)));\n    for (const path of updatedUsage) path.replaceWith(_core.types.identifier(innerName));\n  }\n  for (const name of captured) {\n    if (updatedBindingsUsages.has(name)) continue;\n    callArgs.push(_core.types.identifier(name));\n    closureParams.push(_core.types.identifier(name));\n  }\n  const id = loopPath.scope.generateUid(\"loop\");\n  const fn = _core.types.functionExpression(null, closureParams, _core.types.toBlock(loopNode.body));\n  let call = _core.types.callExpression(_core.types.identifier(id), callArgs);\n  const fnParent = loopPath.findParent(p => p.isFunction());\n  if (fnParent) {\n    const {\n      async,\n      generator\n    } = fnParent.node;\n    fn.async = async;\n    fn.generator = generator;\n    if (generator) call = _core.types.yieldExpression(call, true);else if (async) call = _core.types.awaitExpression(call);\n  }\n  const updaterNode = updater.length > 0 ? _core.types.expressionStatement(_core.types.sequenceExpression(updater)) : null;\n  if (updaterNode) fn.body.body.push(updaterNode);\n  const [varPath] = loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(id), fn)]));\n  const bodyStmts = [];\n  const varNames = [];\n  for (const varPath of state.vars) {\n    const assign = [];\n    for (const decl of varPath.node.declarations) {\n      varNames.push(...Object.keys(_core.types.getBindingIdentifiers(decl.id)));\n      if (decl.init) {\n        assign.push(_core.types.assignmentExpression(\"=\", decl.id, decl.init));\n      }\n    }\n    if (assign.length > 0) {\n      let replacement = assign.length === 1 ? assign[0] : _core.types.sequenceExpression(assign);\n      if (!_core.types.isForStatement(varPath.parent, {\n        init: varPath.node\n      }) && !_core.types.isForXStatement(varPath.parent, {\n        left: varPath.node\n      })) {\n        replacement = _core.types.expressionStatement(replacement);\n      }\n      varPath.replaceWith(replacement);\n    } else {\n      varPath.remove();\n    }\n  }\n  if (varNames.length) {\n    bodyStmts.push(_core.types.variableDeclaration(\"var\", varNames.map(name => _core.types.variableDeclarator(_core.types.identifier(name)))));\n  }\n  if (state.breaksContinues.length === 0 && state.returns.length === 0) {\n    bodyStmts.push(_core.types.expressionStatement(call));\n  } else {\n    const completionId = loopPath.scope.generateUid(\"ret\");\n    bodyStmts.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(completionId), call)]));\n    const injected = new Set();\n    for (const path of state.breaksContinues) {\n      const {\n        node\n      } = path;\n      const {\n        type,\n        label\n      } = node;\n      let name = type === \"BreakStatement\" ? \"break\" : \"continue\";\n      if (label) name += \"|\" + label.name;\n      path.replaceWith(_core.types.returnStatement(_core.types.stringLiteral(name)));\n      if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));\n      if (injected.has(name)) continue;\n      injected.add(name);\n      bodyStmts.push(_core.template.statement.ast`\n        if (\n          ${_core.types.identifier(completionId)} === ${_core.types.stringLiteral(name)}\n        ) ${node}\n      `);\n    }\n    if (state.returns.length) {\n      for (const path of state.returns) {\n        const arg = path.node.argument || path.scope.buildUndefinedNode();\n        path.replaceWith(_core.template.statement.ast`\n          return { v: ${arg} };\n        `);\n      }\n      bodyStmts.push(_core.template.statement.ast`\n        if (typeof ${_core.types.identifier(completionId)} === \"object\")\n          return ${_core.types.identifier(completionId)}.v;\n      `);\n    }\n  }\n  loopNode.body = _core.types.blockStatement(bodyStmts);\n  return varPath;\n}\nfunction isVarInLoopHead(path) {\n  if (_core.types.isForStatement(path.parent)) return path.key === \"init\";\n  if (_core.types.isForXStatement(path.parent)) return path.key === \"left\";\n  return false;\n}\nfunction filterMap(list, fn) {\n  const result = [];\n  for (const item of list) {\n    const mapped = fn(item);\n    if (mapped) result.push(mapped);\n  }\n  return result;\n}\n\n//# sourceMappingURL=loop.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUsage = validateUsage;\nvar _core = require(\"@babel/core\");\nfunction validateUsage(path, state, tdzEnabled) {\n  const dynamicTDZNames = [];\n  for (const name of Object.keys(path.getBindingIdentifiers())) {\n    const binding = path.scope.getBinding(name);\n    if (!binding) continue;\n    if (tdzEnabled) {\n      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);\n    }\n    if (path.node.kind === \"const\") {\n      disallowConstantViolations(name, binding, state);\n    }\n  }\n  return dynamicTDZNames;\n}\nfunction disallowConstantViolations(name, binding, state) {\n  for (const violation of binding.constantViolations) {\n    const readOnlyError = state.addHelper(\"readOnlyError\");\n    const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n    if (violation.isAssignmentExpression()) {\n      const {\n        operator,\n        left,\n        right\n      } = violation.node;\n      if (operator === \"=\") {\n        const exprs = [right];\n        exprs.push(throwNode);\n        violation.replaceWith(_core.types.sequenceExpression(exprs));\n      } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n        violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), left, _core.types.sequenceExpression([right, throwNode])));\n      } else {\n        violation.replaceWith(_core.types.sequenceExpression([_core.types.binaryExpression(operator.slice(0, -1), left, right), throwNode]));\n      }\n    } else if (violation.isUpdateExpression()) {\n      violation.replaceWith(_core.types.sequenceExpression([_core.types.unaryExpression(\"+\", violation.get(\"argument\").node), throwNode]));\n    } else if (violation.isForXStatement()) {\n      violation.ensureBlock();\n      violation.get(\"left\").replaceWith(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))]));\n      violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n    }\n  }\n}\nfunction getTDZStatus(refPath, bindingPath) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\nconst skipTDZChecks = new WeakSet();\nfunction buildTDZAssert(status, node, state) {\n  if (status === \"maybe\") {\n    const clone = _core.types.cloneNode(node);\n    skipTDZChecks.add(clone);\n    return _core.types.callExpression(state.addHelper(\"temporalRef\"), [clone, _core.types.stringLiteral(node.name)]);\n  } else {\n    return _core.types.callExpression(state.addHelper(\"tdz\"), [_core.types.stringLiteral(node.name)]);\n  }\n}\nfunction getTDZReplacement(path, state, id = path.node) {\n  var _path$scope$getBindin;\n  if (skipTDZChecks.has(id)) return;\n  skipTDZChecks.add(id);\n  const bindingPath = (_path$scope$getBindin = path.scope.getBinding(id.name)) == null ? void 0 : _path$scope$getBindin.path;\n  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;\n  const status = getTDZStatus(path, bindingPath);\n  if (status === \"outside\") return;\n  if (status === \"maybe\") {\n    bindingPath.parent._tdzThis = true;\n  }\n  return {\n    status,\n    node: buildTDZAssert(status, id, state)\n  };\n}\nfunction injectTDZChecks(binding, state) {\n  const allUsages = new Set(binding.referencePaths);\n  binding.constantViolations.forEach(allUsages.add, allUsages);\n  let dynamicTdz = false;\n  for (const path of binding.constantViolations) {\n    const {\n      node\n    } = path;\n    if (skipTDZChecks.has(node)) continue;\n    skipTDZChecks.add(node);\n    if (path.isUpdateExpression()) {\n      const arg = path.get(\"argument\");\n      const replacement = getTDZReplacement(path, state, arg.node);\n      if (!replacement) continue;\n      if (replacement.status === \"maybe\") {\n        dynamicTdz = true;\n        path.insertBefore(replacement.node);\n      } else {\n        path.replaceWith(replacement.node);\n      }\n    } else if (path.isAssignmentExpression()) {\n      const nodes = [];\n      const ids = path.getBindingIdentifiers();\n      for (const name of Object.keys(ids)) {\n        const replacement = getTDZReplacement(path, state, ids[name]);\n        if (replacement) {\n          nodes.push(_core.types.expressionStatement(replacement.node));\n          if (replacement.status === \"inside\") break;\n          if (replacement.status === \"maybe\") dynamicTdz = true;\n        }\n      }\n      if (nodes.length > 0) path.insertBefore(nodes);\n    }\n  }\n  for (const path of binding.referencePaths) {\n    if (path.parentPath.isUpdateExpression()) continue;\n    if (path.parentPath.isFor({\n      left: path.node\n    })) continue;\n    const replacement = getTDZReplacement(path, state);\n    if (!replacement) continue;\n    if (replacement.status === \"maybe\") dynamicTdz = true;\n    path.replaceWith(replacement.node);\n  }\n  return dynamicTdz;\n}\n\n//# sourceMappingURL=validation.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.annexB33FunctionsVisitor = void 0;\nexports.isVarScope = isVarScope;\nvar _core = require(\"@babel/core\");\nconst annexB33FunctionsVisitor = {\n  VariableDeclaration(path) {\n    if (isStrict(path)) return;\n    if (path.node.kind !== \"var\") return;\n    const varScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    varScope.path.traverse(functionsToVarVisitor, {\n      names: Object.keys(path.getBindingIdentifiers())\n    });\n  },\n  BlockStatement(path) {\n    if (isStrict(path)) return;\n    if (_core.types.isFunction(path.parent, {\n      body: path.node\n    })) return;\n    transformStatementList(path.get(\"body\"));\n  },\n  SwitchCase(path) {\n    if (isStrict(path)) return;\n    transformStatementList(path.get(\"consequent\"));\n  }\n};\nexports.annexB33FunctionsVisitor = annexB33FunctionsVisitor;\nfunction transformStatementList(paths) {\n  outer: for (const path of paths) {\n    if (!path.isFunctionDeclaration()) continue;\n    if (path.node.async || path.node.generator) return;\n    const {\n      scope\n    } = path.parentPath;\n    if (isVarScope(scope)) return;\n    const {\n      name\n    } = path.node.id;\n    let currScope = scope;\n    do {\n      if (currScope.parent.hasOwnBinding(name)) continue outer;\n      currScope = currScope.parent;\n    } while (!isVarScope(currScope));\n    maybeTransformBlockScopedFunction(path);\n  }\n}\nfunction maybeTransformBlockScopedFunction(path) {\n  const {\n    node,\n    parentPath: {\n      scope\n    }\n  } = path;\n  const {\n    id\n  } = node;\n  scope.removeOwnBinding(id.name);\n  node.id = null;\n  const varNode = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.toExpression(node))]);\n  varNode._blockHoist = 2;\n  const [varPath] = path.replaceWith(varNode);\n  scope.registerDeclaration(varPath);\n}\nconst functionsToVarVisitor = {\n  Scope(path, {\n    names\n  }) {\n    for (const name of names) {\n      const binding = path.scope.getOwnBinding(name);\n      if (binding && binding.kind === \"hoisted\") {\n        maybeTransformBlockScopedFunction(binding.path);\n      }\n    }\n  },\n  \"Expression|Declaration\"(path) {\n    path.skip();\n  }\n};\nfunction isVarScope(scope) {\n  return scope.path.isFunctionParent() || scope.path.isProgram();\n}\nfunction isStrict(path) {\n  return !!path.find(({\n    node\n  }) => {\n    var _node$directives;\n    if (_core.types.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (_core.types.isClass(node)) {\n      return true;\n    } else if (!_core.types.isBlockStatement(node)) {\n      return false;\n    }\n    return (_node$directives = node.directives) == null ? void 0 : _node$directives.some(directive => directive.value.value === \"use strict\");\n  });\n}\n\n//# sourceMappingURL=annex-B_3_3.js.map\n"]}