{"version":3,"sources":["index.js","utils.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["let childProcess = require('child_process')\nlet escalade = require('escalade/sync')\nlet pico = require('picocolors')\nlet path = require('path')\nlet fs = require('fs')\n\nconst { detectIndent, detectEOL } = require('./utils')\n\nfunction BrowserslistUpdateError(message) {\n  this.name = 'BrowserslistUpdateError'\n  this.message = message\n  this.browserslist = true\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, BrowserslistUpdateError)\n  }\n}\n\nBrowserslistUpdateError.prototype = Error.prototype\n\n/* c8 ignore next 3 */\nfunction defaultPrint(str) {\n  process.stdout.write(str)\n}\n\nfunction detectLockfile() {\n  let packageDir = escalade('.', (dir, names) => {\n    return names.indexOf('package.json') !== -1 ? dir : ''\n  })\n\n  if (!packageDir) {\n    throw new BrowserslistUpdateError(\n      'Cannot find package.json. ' +\n        'Is this the right directory to run `npx update-browserslist-db` in?'\n    )\n  }\n\n  let lockfileNpm = path.join(packageDir, 'package-lock.json')\n  let lockfileShrinkwrap = path.join(packageDir, 'npm-shrinkwrap.json')\n  let lockfileYarn = path.join(packageDir, 'yarn.lock')\n  let lockfilePnpm = path.join(packageDir, 'pnpm-lock.yaml')\n\n  if (fs.existsSync(lockfilePnpm)) {\n    return { mode: 'pnpm', file: lockfilePnpm }\n  } else if (fs.existsSync(lockfileNpm)) {\n    return { mode: 'npm', file: lockfileNpm }\n  } else if (fs.existsSync(lockfileYarn)) {\n    let lock = { mode: 'yarn', file: lockfileYarn }\n    lock.content = fs.readFileSync(lock.file).toString()\n    lock.version = /# yarn lockfile v1/.test(lock.content) ? 1 : 2\n    return lock\n  } else if (fs.existsSync(lockfileShrinkwrap)) {\n    return { mode: 'npm', file: lockfileShrinkwrap }\n  }\n  throw new BrowserslistUpdateError(\n    'No lockfile found. Run \"npm install\", \"yarn install\" or \"pnpm install\"'\n  )\n}\n\nfunction getLatestInfo(lock) {\n  if (lock.mode === 'yarn') {\n    if (lock.version === 1) {\n      return JSON.parse(\n        childProcess.execSync('yarn info caniuse-lite --json').toString()\n      ).data\n    } else {\n      return JSON.parse(\n        childProcess.execSync('yarn npm info caniuse-lite --json').toString()\n      )\n    }\n  }\n  if (lock.mode === 'pnpm') {\n    return JSON.parse(\n      childProcess.execSync('pnpm info caniuse-lite --json').toString()\n    )\n  }\n  return JSON.parse(\n    childProcess.execSync('npm show caniuse-lite --json').toString()\n  )\n}\n\nfunction getBrowsers() {\n  let browserslist = require('browserslist')\n  return browserslist().reduce((result, entry) => {\n    if (!result[entry[0]]) {\n      result[entry[0]] = []\n    }\n    result[entry[0]].push(entry[1])\n    return result\n  }, {})\n}\n\nfunction diffBrowsers(old, current) {\n  let browsers = Object.keys(old).concat(\n    Object.keys(current).filter(browser => old[browser] === undefined)\n  )\n  return browsers\n    .map(browser => {\n      let oldVersions = old[browser] || []\n      let currentVersions = current[browser] || []\n      let common = oldVersions.filter(v => currentVersions.includes(v))\n      let added = currentVersions.filter(v => !common.includes(v))\n      let removed = oldVersions.filter(v => !common.includes(v))\n      return removed\n        .map(v => pico.red('- ' + browser + ' ' + v))\n        .concat(added.map(v => pico.green('+ ' + browser + ' ' + v)))\n    })\n    .reduce((result, array) => result.concat(array), [])\n    .join('\\n')\n}\n\nfunction updateNpmLockfile(lock, latest) {\n  let metadata = { latest, versions: [] }\n  let content = deletePackage(JSON.parse(lock.content), metadata)\n  metadata.content = JSON.stringify(content, null, detectIndent(lock.content))\n  return metadata\n}\n\nfunction deletePackage(node, metadata) {\n  if (node.dependencies) {\n    if (node.dependencies['caniuse-lite']) {\n      let version = node.dependencies['caniuse-lite'].version\n      metadata.versions[version] = true\n      delete node.dependencies['caniuse-lite']\n    }\n    for (let i in node.dependencies) {\n      node.dependencies[i] = deletePackage(node.dependencies[i], metadata)\n    }\n  }\n  return node\n}\n\nlet yarnVersionRe = /version \"(.*?)\"/\n\nfunction updateYarnLockfile(lock, latest) {\n  let blocks = lock.content.split(/(\\n{2,})/).map(block => {\n    return block.split('\\n')\n  })\n  let versions = {}\n  blocks.forEach(lines => {\n    if (lines[0].indexOf('caniuse-lite@') !== -1) {\n      let match = yarnVersionRe.exec(lines[1])\n      versions[match[1]] = true\n      if (match[1] !== latest.version) {\n        lines[1] = lines[1].replace(\n          /version \"[^\"]+\"/,\n          'version \"' + latest.version + '\"'\n        )\n        lines[2] = lines[2].replace(\n          /resolved \"[^\"]+\"/,\n          'resolved \"' + latest.dist.tarball + '\"'\n        )\n        if (lines.length === 4) {\n          lines[3] = latest.dist.integrity\n            ? lines[3].replace(\n                /integrity .+/,\n                'integrity ' + latest.dist.integrity\n              )\n            : ''\n        }\n      }\n    }\n  })\n  let content = blocks.map(lines => lines.join('\\n')).join('')\n  return { content, versions }\n}\n\nfunction updateLockfile(lock, latest) {\n  if (!lock.content) lock.content = fs.readFileSync(lock.file).toString()\n\n  let updatedLockFile\n  if (lock.mode === 'yarn') {\n    updatedLockFile = updateYarnLockfile(lock, latest)\n  } else {\n    updatedLockFile = updateNpmLockfile(lock, latest)\n  }\n  updatedLockFile.content = updatedLockFile.content.replace(\n    /\\n/g,\n    detectEOL(lock.content)\n  )\n  return updatedLockFile\n}\n\nfunction updatePackageManually(print, lock, latest) {\n  let lockfileData = updateLockfile(lock, latest)\n  let caniuseVersions = Object.keys(lockfileData.versions).sort()\n  if (caniuseVersions.length === 1 && caniuseVersions[0] === latest.version) {\n    print(\n      'Installed version:  ' +\n        pico.bold(pico.green(latest.version)) +\n        '\\n' +\n        pico.bold(pico.green('caniuse-lite is up to date')) +\n        '\\n'\n    )\n    return\n  }\n\n  if (caniuseVersions.length === 0) {\n    caniuseVersions[0] = 'none'\n  }\n  print(\n    'Installed version' +\n      (caniuseVersions.length === 1 ? ':  ' : 's: ') +\n      pico.bold(pico.red(caniuseVersions.join(', '))) +\n      '\\n' +\n      'Removing old caniuse-lite from lock file\\n'\n  )\n  fs.writeFileSync(lock.file, lockfileData.content)\n\n  let install = lock.mode === 'yarn' ? 'yarn add -W' : lock.mode + ' install'\n  print(\n    'Installing new caniuse-lite version\\n' +\n      pico.yellow('$ ' + install + ' caniuse-lite') +\n      '\\n'\n  )\n  try {\n    childProcess.execSync(install + ' caniuse-lite')\n  } catch (e) /* c8 ignore start */ {\n    print(\n      pico.red(\n        '\\n' +\n          e.stack +\n          '\\n\\n' +\n          'Problem with `' +\n          install +\n          ' caniuse-lite` call. ' +\n          'Run it manually.\\n'\n      )\n    )\n    process.exit(1)\n  } /* c8 ignore end */\n\n  let del = lock.mode === 'yarn' ? 'yarn remove -W' : lock.mode + ' uninstall'\n  print(\n    'Cleaning package.json dependencies from caniuse-lite\\n' +\n      pico.yellow('$ ' + del + ' caniuse-lite') +\n      '\\n'\n  )\n  childProcess.execSync(del + ' caniuse-lite')\n}\n\nfunction updateWith(print, cmd) {\n  print('Updating caniuse-lite version\\n' + pico.yellow('$ ' + cmd) + '\\n')\n  try {\n    childProcess.execSync(cmd)\n  } catch (e) /* c8 ignore start */ {\n    print(pico.red(e.stdout.toString()))\n    print(\n      pico.red(\n        '\\n' +\n          e.stack +\n          '\\n\\n' +\n          'Problem with `' +\n          cmd +\n          '` call. ' +\n          'Run it manually.\\n'\n      )\n    )\n    process.exit(1)\n  } /* c8 ignore end */\n}\n\nmodule.exports = function updateDB(print = defaultPrint) {\n  let lock = detectLockfile()\n  let latest = getLatestInfo(lock)\n\n  let listError\n  let oldList\n  try {\n    oldList = getBrowsers()\n  } catch (e) {\n    listError = e\n  }\n\n  print('Latest version:     ' + pico.bold(pico.green(latest.version)) + '\\n')\n\n  if (lock.mode === 'yarn' && lock.version !== 1) {\n    updateWith(print, 'yarn up -R caniuse-lite')\n  } else if (lock.mode === 'pnpm') {\n    updateWith(print, 'pnpm up caniuse-lite')\n  } else {\n    updatePackageManually(print, lock, latest)\n  }\n\n  print('caniuse-lite has been successfully updated\\n')\n\n  let newList\n  if (!listError) {\n    try {\n      newList = getBrowsers()\n    } catch (e) /* c8 ignore start */ {\n      listError = e\n    } /* c8 ignore end */\n  }\n\n  if (listError) {\n    print(\n      pico.red(\n        '\\n' +\n          listError.stack +\n          '\\n\\n' +\n          'Problem with browser list retrieval.\\n' +\n          'Target browser changes won’t be shown.\\n'\n      )\n    )\n  } else {\n    let changes = diffBrowsers(oldList, newList)\n    if (changes) {\n      print('\\nTarget browser changes:\\n')\n      print(changes + '\\n')\n    } else {\n      print('\\n' + pico.green('No target browser changes') + '\\n')\n    }\n  }\n}\n","const { EOL } = require('os')\n\nconst getFirstRegexpMatchOrDefault = (text, regexp, defaultValue) => {\n  regexp.lastIndex = 0 // https://stackoverflow.com/a/11477448/4536543\n  let match = regexp.exec(text)\n  if (match !== null) return match[1]\n  return defaultValue\n}\n\nconst DEFAULT_INDENT = '  '\nconst INDENT_REGEXP = /^([ \\t]+)[^\\s]/m\n\nmodule.exports.detectIndent = text =>\n  getFirstRegexpMatchOrDefault(text, INDENT_REGEXP, DEFAULT_INDENT)\nmodule.exports.DEFAULT_INDENT = DEFAULT_INDENT\n\nconst DEFAULT_EOL = EOL\nconst EOL_REGEXP = /(\\r\\n|\\n|\\r)/g\n\nmodule.exports.detectEOL = text =>\n  getFirstRegexpMatchOrDefault(text, EOL_REGEXP, DEFAULT_EOL)\nmodule.exports.DEFAULT_EOL = DEFAULT_EOL\n"]}