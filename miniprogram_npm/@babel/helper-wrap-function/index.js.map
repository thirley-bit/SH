{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\nvar _template = require(\"@babel/template\");\nvar _t = require(\"@babel/types\");\nconst {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression\n} = _t;\nconst buildAnonymousExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\nconst buildNamedExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\nconst buildDeclarationWrapper = _template.default.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\nfunction classOrObjectMethod(path, callId) {\n  const node = path.node;\n  const body = node.body;\n  const container = functionExpression(null, [], blockStatement(body.body), true);\n  body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];\n\n  node.async = false;\n  node.generator = false;\n\n  path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n}\nfunction plainFunction(inPath, callId, noNewArrows, ignoreFunctionLength) {\n  let path = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n  if (path.isArrowFunctionExpression()) {\n    {\n      var _path$arrowFunctionTo;\n      path = (_path$arrowFunctionTo = path.arrowFunctionToExpression({\n        noNewArrows\n      })) != null ? _path$arrowFunctionTo : path;\n    }\n    node = path.node;\n  } else {\n    node = path.node;\n  }\n  const isDeclaration = isFunctionDeclaration(node);\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [node]);\n  }\n  const params = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params\n  };\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n    if (functionId) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n      const returnFn = container.callee.body.body[1].argument;\n      (0, _helperFunctionName.default)({\n        node: returnFn,\n        parent: path.parent,\n        scope: path.scope\n      });\n      functionId = returnFn.id;\n    }\n    if (functionId || !ignoreFunctionLength && params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\nfunction wrapFunction(path, callId,\nnoNewArrows = true, ignoreFunctionLength = false) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(path, callId, noNewArrows, ignoreFunctionLength);\n  }\n}\n\n//# sourceMappingURL=index.js.map\n"]}