{"version":3,"sources":["index.js","dist/index.js","dist/Kernel.js","dist/Config.js","dist/utils/constants.js","dist/Plugin.js","dist/utils/index.js","dist/platform-plugin-base/index.js","dist/platform-plugin-base/mini.js","dist/platform-plugin-base/platform.js","dist/platform-plugin-base/web.js","dist/utils/package.js","dist/utils/types.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,ADGA,AGTA;ADIA,ADGA,AGTA,AJYA,AGTA;ADIA,ADGA,AGTA,AJYA,AGTA;ADIA,ADGA,AGTA,AJYA,AGTA;ADIA,ADGA,AGTA,AJYA,AGTA,AENA;AHUA,ADGA,AGTA,AJYA,AGTA,AENA;AHUA,ADGA,AGTA,AJYA,AGTA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,AHSA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,AHSA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,AHSA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,ACHA,AJYA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,ACHA,AJYA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,ACHA,AJYA,AENA;AHUA,ADGA,AGTA,AJYA,AMlBA,ACHA,ACHA,ALeA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ALeA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ALeA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,ANkBA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,ANkBA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,ANkBA,AENA;AHUA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;AT4BA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;AT4BA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA;AT4BA,ADGA,AGTA,AENA,ACHA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA,AKfA;ARyBA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AHUA,ADGA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AGTA,AGTA,ACHA,ACHA,AJYA;AJaA,AMlBA,ACHA,ACHA,AJYA;AJaA,AMlBA,ACHA,ACHA,AJYA;AJaA,AMlBA,ACHA,ACHA,AJYA;AJaA,AMlBA,ACHA,ACHA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA,AJYA;AJaA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./dist/index.js').default\n\nmodule.exports.default = module.exports\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TaroPlatformWeb = exports.TaroPlatformBase = exports.Kernel = void 0;\nconst Kernel_1 = require(\"./Kernel\");\nexports.Kernel = Kernel_1.default;\nconst platform_plugin_base_1 = require(\"./platform-plugin-base\");\nObject.defineProperty(exports, \"TaroPlatformBase\", { enumerable: true, get: function () { return platform_plugin_base_1.TaroPlatformBase; } });\nObject.defineProperty(exports, \"TaroPlatformWeb\", { enumerable: true, get: function () { return platform_plugin_base_1.TaroPlatformWeb; } });\n__exportStar(require(\"./utils/types\"), exports);\nexports.default = { Kernel: Kernel_1.default, TaroPlatformBase: platform_plugin_base_1.TaroPlatformBase, TaroPlatformWeb: platform_plugin_base_1.TaroPlatformWeb };\n//# sourceMappingURL=index.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst helper_1 = require(\"@tarojs/helper\");\nconst helper = require(\"@tarojs/helper\");\nconst events_1 = require(\"events\");\nconst lodash_1 = require(\"lodash\");\nconst path = require(\"path\");\nconst tapable_1 = require(\"tapable\");\nconst Config_1 = require(\"./Config\");\nconst Plugin_1 = require(\"./Plugin\");\nconst utils_1 = require(\"./utils\");\nconst constants_1 = require(\"./utils/constants\");\nclass Kernel extends events_1.EventEmitter {\n    constructor(options) {\n        super();\n        this.debugger = process.env.DEBUG === 'Taro:Kernel' ? (0, helper_1.createDebug)('Taro:Kernel') : function () { };\n        this.appPath = options.appPath || process.cwd();\n        this.optsPresets = options.presets;\n        this.optsPlugins = options.plugins;\n        this.hooks = new Map();\n        this.methods = new Map();\n        this.commands = new Map();\n        this.platforms = new Map();\n        this.initHelper();\n        this.initConfig();\n        this.initPaths();\n    }\n    initConfig() {\n        this.config = new Config_1.default({\n            appPath: this.appPath\n        });\n        this.initialConfig = this.config.initialConfig;\n        this.debugger('initConfig', this.initialConfig);\n    }\n    initPaths() {\n        this.paths = {\n            appPath: this.appPath,\n            nodeModulesPath: (0, helper_1.recursiveFindNodeModules)(path.join(this.appPath, helper_1.NODE_MODULES))\n        };\n        if (this.config.isInitSuccess) {\n            Object.assign(this.paths, {\n                configPath: this.config.configPath,\n                sourcePath: path.join(this.appPath, this.initialConfig.sourceRoot),\n                outputPath: path.resolve(this.appPath, this.initialConfig.outputRoot)\n            });\n        }\n        this.debugger(`initPaths:${JSON.stringify(this.paths, null, 2)}`);\n    }\n    initHelper() {\n        this.helper = helper;\n        this.debugger('initHelper');\n    }\n    initPresetsAndPlugins() {\n        const initialConfig = this.initialConfig;\n        const allConfigPresets = (0, utils_1.mergePlugins)(this.optsPresets || [], initialConfig.presets || [])();\n        const allConfigPlugins = (0, utils_1.mergePlugins)(this.optsPlugins || [], initialConfig.plugins || [])();\n        this.debugger('initPresetsAndPlugins', allConfigPresets, allConfigPlugins);\n        process.env.NODE_ENV !== 'test' &&\n            (0, helper_1.createSwcRegister)({\n                only: [...Object.keys(allConfigPresets), ...Object.keys(allConfigPlugins)]\n            });\n        this.plugins = new Map();\n        this.extraPlugins = {};\n        this.resolvePresets(allConfigPresets);\n        this.resolvePlugins(allConfigPlugins);\n    }\n    resolvePresets(presets) {\n        const allPresets = (0, utils_1.resolvePresetsOrPlugins)(this.appPath, presets, constants_1.PluginType.Preset);\n        while (allPresets.length) {\n            this.initPreset(allPresets.shift());\n        }\n    }\n    resolvePlugins(plugins) {\n        plugins = (0, lodash_1.merge)(this.extraPlugins, plugins);\n        const allPlugins = (0, utils_1.resolvePresetsOrPlugins)(this.appPath, plugins, constants_1.PluginType.Plugin);\n        while (allPlugins.length) {\n            this.initPlugin(allPlugins.shift());\n        }\n        this.extraPlugins = {};\n    }\n    initPreset(preset) {\n        this.debugger('initPreset', preset);\n        const { id, path, opts, apply } = preset;\n        const pluginCtx = this.initPluginCtx({ id, path, ctx: this });\n        const { presets, plugins } = apply()(pluginCtx, opts) || {};\n        this.registerPlugin(preset);\n        if (Array.isArray(presets)) {\n            const _presets = (0, utils_1.resolvePresetsOrPlugins)(this.appPath, (0, utils_1.convertPluginsToObject)(presets)(), constants_1.PluginType.Preset);\n            while (_presets.length) {\n                this.initPreset(_presets.shift());\n            }\n        }\n        if (Array.isArray(plugins)) {\n            this.extraPlugins = (0, lodash_1.merge)(this.extraPlugins, (0, utils_1.convertPluginsToObject)(plugins)());\n        }\n    }\n    initPlugin(plugin) {\n        const { id, path, opts, apply } = plugin;\n        const pluginCtx = this.initPluginCtx({ id, path, ctx: this });\n        this.debugger('initPlugin', plugin);\n        this.registerPlugin(plugin);\n        apply()(pluginCtx, opts);\n        this.checkPluginOpts(pluginCtx, opts);\n    }\n    checkPluginOpts(pluginCtx, opts) {\n        if (typeof pluginCtx.optsSchema !== 'function') {\n            return;\n        }\n        this.debugger('checkPluginOpts', pluginCtx);\n        const joi = require('joi');\n        const schema = pluginCtx.optsSchema(joi);\n        if (!joi.isSchema(schema)) {\n            throw new Error(`插件${pluginCtx.id}中设置参数检查 schema 有误，请检查！`);\n        }\n        const { error } = schema.validate(opts);\n        if (error) {\n            error.message = `插件${pluginCtx.id}获得的参数不符合要求，请检查！`;\n            throw error;\n        }\n    }\n    registerPlugin(plugin) {\n        this.debugger('registerPlugin', plugin);\n        if (this.plugins.has(plugin.id)) {\n            throw new Error(`插件 ${plugin.id} 已被注册`);\n        }\n        this.plugins.set(plugin.id, plugin);\n    }\n    initPluginCtx({ id, path, ctx }) {\n        const pluginCtx = new Plugin_1.default({ id, path, ctx });\n        const internalMethods = ['onReady', 'onStart'];\n        const kernelApis = [\n            'appPath',\n            'plugins',\n            'platforms',\n            'paths',\n            'helper',\n            'runOpts',\n            'initialConfig',\n            'applyPlugins'\n        ];\n        internalMethods.forEach(name => {\n            if (!this.methods.has(name)) {\n                pluginCtx.registerMethod(name);\n            }\n        });\n        return new Proxy(pluginCtx, {\n            get: (target, name) => {\n                if (this.methods.has(name)) {\n                    const method = this.methods.get(name);\n                    if (Array.isArray(method)) {\n                        return (...arg) => {\n                            method.forEach(item => {\n                                item.apply(this, arg);\n                            });\n                        };\n                    }\n                    return method;\n                }\n                if (kernelApis.includes(name)) {\n                    return typeof this[name] === 'function' ? this[name].bind(this) : this[name];\n                }\n                return target[name];\n            }\n        });\n    }\n    applyPlugins(args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let name;\n            let initialVal;\n            let opts;\n            if (typeof args === 'string') {\n                name = args;\n            }\n            else {\n                name = args.name;\n                initialVal = args.initialVal;\n                opts = args.opts;\n            }\n            this.debugger('applyPlugins');\n            this.debugger(`applyPlugins:name:${name}`);\n            this.debugger(`applyPlugins:initialVal:${initialVal}`);\n            this.debugger(`applyPlugins:opts:${opts}`);\n            if (typeof name !== 'string') {\n                throw new Error('调用失败，未传入正确的名称！');\n            }\n            const hooks = this.hooks.get(name) || [];\n            if (!hooks.length) {\n                return yield initialVal;\n            }\n            const waterfall = new tapable_1.AsyncSeriesWaterfallHook(['arg']);\n            if (hooks.length) {\n                const resArr = [];\n                for (const hook of hooks) {\n                    waterfall.tapPromise({\n                        name: hook.plugin,\n                        stage: hook.stage || 0,\n                        // @ts-ignore\n                        before: hook.before\n                    }, (arg) => __awaiter(this, void 0, void 0, function* () {\n                        const res = yield hook.fn(opts, arg);\n                        if (constants_1.IS_MODIFY_HOOK.test(name) && constants_1.IS_EVENT_HOOK.test(name)) {\n                            return res;\n                        }\n                        if (constants_1.IS_ADD_HOOK.test(name)) {\n                            resArr.push(res);\n                            return resArr;\n                        }\n                        return null;\n                    }));\n                }\n            }\n            return yield waterfall.promise(initialVal);\n        });\n    }\n    runWithPlatform(platform) {\n        if (!this.platforms.has(platform)) {\n            throw new Error(`不存在编译平台 ${platform}`);\n        }\n        const withNameConfig = this.config.getConfigWithNamed(platform, this.platforms.get(platform).useConfigName);\n        return withNameConfig;\n    }\n    setRunOpts(opts) {\n        this.runOpts = opts;\n    }\n    runHelp(name) {\n        const command = this.commands.get(name);\n        const defaultOptionsMap = new Map();\n        defaultOptionsMap.set('-h, --help', 'output usage information');\n        let customOptionsMap = new Map();\n        if (command === null || command === void 0 ? void 0 : command.optionsMap) {\n            customOptionsMap = new Map(Object.entries(command === null || command === void 0 ? void 0 : command.optionsMap));\n        }\n        const optionsMap = new Map([...customOptionsMap, ...defaultOptionsMap]);\n        (0, utils_1.printHelpLog)(name, optionsMap, (command === null || command === void 0 ? void 0 : command.synopsisList) ? new Set(command === null || command === void 0 ? void 0 : command.synopsisList) : new Set());\n    }\n    run(args) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            let name;\n            let opts;\n            if (typeof args === 'string') {\n                name = args;\n            }\n            else {\n                name = args.name;\n                opts = args.opts;\n            }\n            this.debugger('command:run');\n            this.debugger(`command:run:name:${name}`);\n            this.debugger('command:runOpts');\n            this.debugger(`command:runOpts:${JSON.stringify(opts, null, 2)}`);\n            this.setRunOpts(opts);\n            this.debugger('initPresetsAndPlugins');\n            this.initPresetsAndPlugins();\n            yield this.applyPlugins('onReady');\n            this.debugger('command:onStart');\n            yield this.applyPlugins('onStart');\n            if (!this.commands.has(name)) {\n                throw new Error(`${name} 命令不存在`);\n            }\n            if (opts === null || opts === void 0 ? void 0 : opts.isHelp) {\n                return this.runHelp(name);\n            }\n            if ((_a = opts === null || opts === void 0 ? void 0 : opts.options) === null || _a === void 0 ? void 0 : _a.platform) {\n                opts.config = this.runWithPlatform(opts.options.platform);\n                yield this.applyPlugins({\n                    name: 'modifyRunnerOpts',\n                    opts: {\n                        opts: opts === null || opts === void 0 ? void 0 : opts.config\n                    }\n                });\n            }\n            yield this.applyPlugins({\n                name,\n                opts\n            });\n        });\n    }\n}\nexports.default = Kernel;\n//# sourceMappingURL=Kernel.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst helper_1 = require(\"@tarojs/helper\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst merge = require(\"webpack-merge\");\nconst constants_1 = require(\"./utils/constants\");\nclass Config {\n    constructor(opts) {\n        this.appPath = opts.appPath;\n        this.init();\n    }\n    init() {\n        this.configPath = (0, helper_1.resolveScriptPath)(path.join(this.appPath, constants_1.CONFIG_DIR_NAME, constants_1.DEFAULT_CONFIG_FILE));\n        if (!fs.existsSync(this.configPath)) {\n            this.initialConfig = {};\n            this.isInitSuccess = false;\n        }\n        else {\n            (0, helper_1.createSwcRegister)({\n                only: [\n                    filePath => filePath.indexOf(path.join(this.appPath, constants_1.CONFIG_DIR_NAME)) >= 0\n                ]\n            });\n            try {\n                this.initialConfig = (0, helper_1.getModuleDefaultExport)(require(this.configPath))(merge);\n                this.isInitSuccess = true;\n            }\n            catch (err) {\n                this.initialConfig = {};\n                this.isInitSuccess = false;\n                console.log(err);\n            }\n        }\n    }\n    getConfigWithNamed(platform, useConfigName) {\n        const initialConfig = this.initialConfig;\n        const sourceDirName = initialConfig.sourceRoot || helper_1.SOURCE_DIR;\n        const outputDirName = initialConfig.outputRoot || helper_1.OUTPUT_DIR;\n        const sourceDir = path.join(this.appPath, sourceDirName);\n        const entryName = helper_1.ENTRY;\n        const entryFilePath = (0, helper_1.resolveScriptPath)(path.join(sourceDir, entryName));\n        const entry = {\n            [entryName]: [entryFilePath]\n        };\n        return Object.assign({ entry, alias: initialConfig.alias || {}, copy: initialConfig.copy, sourceRoot: sourceDirName, outputRoot: outputDirName, platform, framework: initialConfig.framework, compiler: initialConfig.compiler, cache: initialConfig.cache, logger: initialConfig.logger, baseLevel: initialConfig.baseLevel, csso: initialConfig.csso, sass: initialConfig.sass, uglify: initialConfig.uglify, plugins: initialConfig.plugins, projectName: initialConfig.projectName, env: initialConfig.env, defineConstants: initialConfig.defineConstants, designWidth: initialConfig.designWidth, deviceRatio: initialConfig.deviceRatio, projectConfigName: initialConfig.projectConfigName, jsMinimizer: initialConfig.jsMinimizer, cssMinimizer: initialConfig.cssMinimizer, terser: initialConfig.terser, esbuild: initialConfig.esbuild }, initialConfig[useConfigName]);\n    }\n}\nexports.default = Config;\n//# sourceMappingURL=Config.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PluginNamePrefix = exports.PluginType = exports.presetOrPluginPrefixReg = exports.IS_MODIFY_HOOK = exports.IS_ADD_HOOK = exports.IS_EVENT_HOOK = exports.PLUGIN_PREFIX = exports.PRESET_PREFIX = exports.DEFAULT_CONFIG_FILE = exports.CONFIG_DIR_NAME = void 0;\nexports.CONFIG_DIR_NAME = 'config';\nexports.DEFAULT_CONFIG_FILE = 'index';\nexports.PRESET_PREFIX = '@tarojs/preset-';\nexports.PLUGIN_PREFIX = '@tarojs/plugin-';\nexports.IS_EVENT_HOOK = /^on/;\nexports.IS_ADD_HOOK = /^add/;\nexports.IS_MODIFY_HOOK = /^modify/;\nexports.presetOrPluginPrefixReg = new RegExp(`^${exports.PRESET_PREFIX}|${exports.PLUGIN_PREFIX}`);\nvar PluginType;\n(function (PluginType) {\n    PluginType[\"Preset\"] = \"Preset\";\n    PluginType[\"Plugin\"] = \"Plugin\";\n})(PluginType = exports.PluginType || (exports.PluginType = {}));\nexports.PluginNamePrefix = {\n    [PluginType.Preset]: exports.PLUGIN_PREFIX,\n    [PluginType.Plugin]: exports.PLUGIN_PREFIX\n};\n//# sourceMappingURL=constants.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst helper_1 = require(\"@tarojs/helper\");\nclass Plugin {\n    constructor(opts) {\n        this.id = opts.id;\n        this.path = opts.path;\n        this.ctx = opts.ctx;\n    }\n    register(hook) {\n        if (typeof hook.name !== 'string') {\n            throw new Error(`插件 ${this.id} 中注册 hook 失败， hook.name 必须是 string 类型`);\n        }\n        if (typeof hook.fn !== 'function') {\n            throw new Error(`插件 ${this.id} 中注册 hook 失败， hook.fn 必须是 function 类型`);\n        }\n        const hooks = this.ctx.hooks.get(hook.name) || [];\n        hook.plugin = this.id;\n        this.ctx.hooks.set(hook.name, hooks.concat(hook));\n    }\n    registerCommand(command) {\n        if (this.ctx.commands.has(command.name)) {\n            throw new Error(`命令 ${command.name} 已存在`);\n        }\n        this.ctx.commands.set(command.name, command);\n        this.register(command);\n    }\n    registerPlatform(platform) {\n        if (this.ctx.platforms.has(platform.name)) {\n            throw new Error(`适配平台 ${platform.name} 已存在`);\n        }\n        (0, helper_1.addPlatforms)(platform.name);\n        this.ctx.platforms.set(platform.name, platform);\n        this.register(platform);\n    }\n    registerMethod(...args) {\n        const { name, fn } = processArgs(args);\n        const methods = this.ctx.methods.get(name) || [];\n        methods.push(fn || function (fn) {\n            this.register({\n                name,\n                fn\n            });\n        }.bind(this));\n        this.ctx.methods.set(name, methods);\n    }\n    addPluginOptsSchema(schema) {\n        this.optsSchema = schema;\n    }\n}\nexports.default = Plugin;\nfunction processArgs(args) {\n    let name, fn;\n    if (!args.length) {\n        throw new Error('参数为空');\n    }\n    else if (args.length === 1) {\n        if (typeof args[0] === 'string') {\n            name = args[0];\n        }\n        else {\n            name = args[0].name;\n            fn = args[0].fn;\n        }\n    }\n    else {\n        name = args[0];\n        fn = args[1];\n    }\n    return { name, fn };\n}\n//# sourceMappingURL=Plugin.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printHelpLog = exports.resolvePresetsOrPlugins = exports.mergePlugins = exports.convertPluginsToObject = exports.getPluginPath = exports.isNpmPkg = void 0;\nconst helper_1 = require(\"@tarojs/helper\");\nconst lodash_1 = require(\"lodash\");\nconst path = require(\"path\");\nconst resolve = require(\"resolve\");\nconst isNpmPkg = name => !(/^(\\.|\\/)/.test(name));\nexports.isNpmPkg = isNpmPkg;\nfunction getPluginPath(pluginPath) {\n    if ((0, exports.isNpmPkg)(pluginPath) || path.isAbsolute(pluginPath))\n        return pluginPath;\n    throw new Error('plugin 和 preset 配置必须为绝对路径或者包名');\n}\nexports.getPluginPath = getPluginPath;\nfunction convertPluginsToObject(items) {\n    return () => {\n        const obj = {};\n        if (Array.isArray(items)) {\n            items.forEach(item => {\n                if (typeof item === 'string') {\n                    const name = getPluginPath(item);\n                    obj[name] = null;\n                }\n                else if (Array.isArray(item)) {\n                    const name = getPluginPath(item[0]);\n                    obj[name] = item[1];\n                }\n            });\n        }\n        return obj;\n    };\n}\nexports.convertPluginsToObject = convertPluginsToObject;\nfunction mergePlugins(dist, src) {\n    return () => {\n        const srcObj = convertPluginsToObject(src)();\n        const distObj = convertPluginsToObject(dist)();\n        return (0, lodash_1.merge)(distObj, srcObj);\n    };\n}\nexports.mergePlugins = mergePlugins;\n// getModuleDefaultExport\nfunction resolvePresetsOrPlugins(root, args, type) {\n    return Object.keys(args).map(item => {\n        var _a;\n        let fPath;\n        try {\n            fPath = resolve.sync(item, {\n                basedir: root,\n                extensions: ['.js', '.ts']\n            });\n        }\n        catch (err) {\n            if ((_a = args[item]) === null || _a === void 0 ? void 0 : _a.backup) {\n                // 如果项目中没有，可以使用 CLI 中的插件\n                fPath = args[item].backup;\n            }\n            else {\n                console.log(helper_1.chalk.red(`找不到依赖 \"${item}\"，请先在项目中安装`));\n                process.exit(1);\n            }\n        }\n        return {\n            id: fPath,\n            path: fPath,\n            type,\n            opts: args[item] || {},\n            apply() {\n                try {\n                    return (0, helper_1.getModuleDefaultExport)(require(fPath));\n                }\n                catch (error) {\n                    console.error(error);\n                    throw new Error(`插件依赖 \"${item}\" 加载失败，请检查插件配置`);\n                }\n            }\n        };\n    });\n}\nexports.resolvePresetsOrPlugins = resolvePresetsOrPlugins;\nfunction supplementBlank(length) {\n    return Array(length).map(() => '').join(' ');\n}\nfunction printHelpLog(command, optionsList, synopsisList) {\n    console.log(`Usage: taro ${command} [options]`);\n    console.log();\n    console.log('Options:');\n    const keys = Array.from(optionsList.keys());\n    const maxLength = keys.reduce((v1, v2) => {\n        return v1.length > v2.length ? v1 : v2;\n    }).length + 3;\n    optionsList.forEach((v, k) => {\n        const supplementBlankLength = maxLength - k.length;\n        console.log(`  ${k}${supplementBlank(supplementBlankLength)}${v}`);\n    });\n    if (synopsisList && synopsisList.size) {\n        console.log();\n        console.log('Synopsis:');\n        synopsisList.forEach(item => {\n            console.log(`  $ ${item}`);\n        });\n    }\n}\nexports.printHelpLog = printHelpLog;\n//# sourceMappingURL=index.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./mini\"), exports);\n__exportStar(require(\"./web\"), exports);\n//# sourceMappingURL=index.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TaroPlatformBase = void 0;\nconst platform_1 = require(\"./platform\");\nclass TaroPlatformBase extends platform_1.default {\n    /**\n     * 1. 清空 dist 文件夹\n     * 2. 输出编译提示\n     * 3. 生成 project.config.json\n     */\n    setup() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setupTransaction.perform(this.setupImpl, this);\n            (_b = (_a = this.ctx).onSetupClose) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        });\n    }\n    setupImpl() {\n        var _a;\n        const { needClearOutput } = this.config;\n        if (typeof needClearOutput === 'undefined' || !!needClearOutput) {\n            this.emptyOutputDir();\n        }\n        this.printDevelopmentTip(this.platform);\n        if (this.projectConfigJson) {\n            this.generateProjectConfig(this.projectConfigJson);\n        }\n        if (((_a = this.ctx.initialConfig.logger) === null || _a === void 0 ? void 0 : _a.quiet) === false) {\n            const { printLog, processTypeEnum } = this.ctx.helper;\n            printLog(\"start\" /* processTypeEnum.START */, '开发者工具-项目目录', `${this.ctx.paths.outputPath}`);\n        }\n    }\n    printDevelopmentTip(platform) {\n        var _a;\n        const tips = [];\n        const config = this.config;\n        const { chalk } = this.helper;\n        if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n            const { isWindows } = this.helper;\n            const exampleCommand = isWindows\n                ? `$ set NODE_ENV=production && taro build --type ${platform} --watch`\n                : `$ NODE_ENV=production taro build --type ${platform} --watch`;\n            tips.push(chalk.yellowBright(`预览模式生成的文件较大，设置 NODE_ENV 为 production 可以开启压缩。\nExample:\n${exampleCommand}`));\n        }\n        if (this.compiler === 'webpack5' && !((_a = config.cache) === null || _a === void 0 ? void 0 : _a.enable)) {\n            tips.push(chalk.yellowBright('建议开启持久化缓存功能，能有效提升二次编译速度，详情请参考: https://docs.taro.zone/docs/config-detail#cache。'));\n        }\n        if (tips.length) {\n            console.log(chalk.yellowBright('Tips:'));\n            tips.forEach((item, index) => console.log(`${chalk.yellowBright(index + 1)}. ${item}`));\n            console.log('\\n');\n        }\n    }\n    /**\n     * 返回当前项目内的 @tarojs/mini-runner 包\n     */\n    getRunner() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { appPath } = this.ctx.paths;\n            const { npm } = this.helper;\n            let runnerPkg;\n            switch (this.compiler) {\n                case 'webpack5':\n                    runnerPkg = '@tarojs/webpack5-runner';\n                    break;\n                default:\n                    runnerPkg = '@tarojs/mini-runner';\n            }\n            const runner = yield npm.getNpmPkg(runnerPkg, appPath);\n            return runner.bind(null, appPath);\n        });\n    }\n    /**\n     * 准备 mini-runner 参数\n     * @param extraOptions 需要额外合入 Options 的配置项\n     */\n    getOptions(extraOptions = {}) {\n        const { ctx, config, globalObject, fileType, template } = this;\n        return Object.assign(Object.assign(Object.assign({}, config), { nodeModulesPath: ctx.paths.nodeModulesPath, buildAdapter: config.platform, globalObject,\n            fileType,\n            template }), extraOptions);\n    }\n    /**\n     * 调用 mini-runner 开始编译\n     * @param extraOptions 需要额外传入 @tarojs/mini-runner 的配置项\n     */\n    build(extraOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_b = (_a = this.ctx).onBuildInit) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n            yield this.buildTransaction.perform(this.buildImpl, this, extraOptions);\n        });\n    }\n    buildImpl(extraOptions = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runner = yield this.getRunner();\n            const options = this.getOptions(Object.assign({\n                runtimePath: this.runtimePath,\n                taroComponentsPath: this.taroComponentsPath\n            }, extraOptions));\n            yield runner(options);\n        });\n    }\n    /**\n     * 生成 project.config.json\n     * @param src 项目源码中配置文件的名称\n     * @param dist 编译后配置文件的名称，默认为 'project.config.json'\n     */\n    generateProjectConfig(src, dist = 'project.config.json') {\n        if (this.config.isBuildNativeComp)\n            return;\n        this.ctx.generateProjectConfig({\n            srcConfigName: src,\n            distConfigName: dist\n        });\n    }\n    /**\n     * 递归替换对象的 key 值\n     */\n    recursiveReplaceObjectKeys(obj, keyMap) {\n        Object.keys(obj).forEach(key => {\n            if (keyMap[key]) {\n                obj[keyMap[key]] = obj[key];\n                if (typeof obj[key] === 'object') {\n                    this.recursiveReplaceObjectKeys(obj[keyMap[key]], keyMap);\n                }\n                delete obj[key];\n            }\n            else if (keyMap[key] === false) {\n                delete obj[key];\n            }\n            else if (typeof obj[key] === 'object') {\n                this.recursiveReplaceObjectKeys(obj[key], keyMap);\n            }\n        });\n    }\n    /**\n     * 调用 mini-runner 开启编译\n     */\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setup();\n            yield this.build();\n        });\n    }\n}\nexports.TaroPlatformBase = TaroPlatformBase;\n//# sourceMappingURL=mini.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transaction = void 0;\nclass Transaction {\n    constructor() {\n        this.wrappers = [];\n    }\n    perform(fn, scope, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.initAll(scope);\n            yield fn.call(scope, ...args);\n            this.closeAll(scope);\n        });\n    }\n    initAll(scope) {\n        const wrappers = this.wrappers;\n        wrappers.forEach(wrapper => { var _a; return (_a = wrapper.init) === null || _a === void 0 ? void 0 : _a.call(scope); });\n    }\n    closeAll(scope) {\n        const wrappers = this.wrappers;\n        wrappers.forEach(wrapper => { var _a; return (_a = wrapper.close) === null || _a === void 0 ? void 0 : _a.call(scope); });\n    }\n    addWrapper(wrapper) {\n        this.wrappers.push(wrapper);\n    }\n}\nexports.Transaction = Transaction;\nclass TaroPlatform {\n    constructor(ctx, config) {\n        this.setupTransaction = new Transaction();\n        this.buildTransaction = new Transaction();\n        this.ctx = ctx;\n        this.helper = ctx.helper;\n        this.config = config;\n        this.updateOutputPath(config);\n        const _compiler = config.compiler;\n        this.compiler = typeof _compiler === 'object' ? _compiler.type : _compiler;\n    }\n    emptyOutputDir() {\n        const { outputPath } = this.ctx.paths;\n        this.helper.emptyDirectory(outputPath);\n    }\n    /**\n     * 如果分端编译详情 webpack 配置了 output 则需更新 outputPath 位置\n     */\n    updateOutputPath(config) {\n        var _a;\n        const platformPath = (_a = config.output) === null || _a === void 0 ? void 0 : _a.path;\n        if (platformPath) {\n            this.ctx.paths.outputPath = platformPath;\n        }\n    }\n}\nexports.default = TaroPlatform;\n//# sourceMappingURL=platform.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TaroPlatformWeb = void 0;\nconst lodash_1 = require(\"lodash\");\nconst path = require(\"path\");\nconst package_1 = require(\"../utils/package\");\nconst platform_1 = require(\"./platform\");\nclass TaroPlatformWeb extends platform_1.default {\n    /**\n     * 1. 清空 dist 文件夹\n     * 2. 输出编译提示\n     */\n    setup() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setupTransaction.perform(this.setupWebApp, this);\n            (_b = (_a = this.ctx).onSetupClose) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        });\n    }\n    setupWebApp() {\n        const { needClearOutput } = this.config;\n        if (typeof needClearOutput === 'undefined' || !!needClearOutput) {\n            this.emptyOutputDir();\n        }\n        this.printDevelopmentTip();\n    }\n    printDevelopmentTip() {\n        var _a;\n        const tips = [];\n        const config = this.config;\n        const { chalk } = this.helper;\n        if (this.compiler === 'webpack5' && !((_a = config.cache) === null || _a === void 0 ? void 0 : _a.enable)) {\n            tips.push(chalk.yellowBright('建议开启持久化缓存功能，能有效提升二次编译速度，详情请参考: https://docs.taro.zone/docs/config-detail#cache。'));\n        }\n        if (tips.length) {\n            console.log(chalk.yellowBright('Tips:'));\n            tips.forEach((item, index) => console.log(`${chalk.yellowBright(index + 1)}. ${item}`));\n            console.log('\\n');\n        }\n    }\n    /**\n     * 返回当前项目内的 runner 包\n     */\n    getRunner() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { appPath } = this.ctx.paths;\n            const { npm } = this.helper;\n            let runnerPkg;\n            switch (this.compiler) {\n                case 'webpack5':\n                    runnerPkg = '@tarojs/webpack5-runner';\n                    break;\n                default:\n                    runnerPkg = '@tarojs/webpack-runner';\n            }\n            const runner = yield npm.getNpmPkg(runnerPkg, appPath);\n            return runner.bind(null, appPath);\n        });\n    }\n    /**\n     * 准备 runner 参数\n     * @param extraOptions 需要额外合入 Options 的配置项\n     */\n    getOptions(extraOptions = {}) {\n        const { sourcePath } = this.ctx.paths;\n        const { initialConfig } = this.ctx;\n        const { port } = this.ctx.runOpts.options;\n        const { recursiveMerge, ENTRY, SOURCE_DIR, OUTPUT_DIR } = this.ctx.helper;\n        const entryFileName = `${ENTRY}.config`;\n        const entryFile = path.basename(entryFileName);\n        const defaultEntry = {\n            [ENTRY]: [path.join(sourcePath, entryFile)]\n        };\n        const customEntry = (0, lodash_1.get)(initialConfig, 'h5.entry');\n        const config = recursiveMerge(Object.assign({}, this.config), {\n            entryFileName: ENTRY,\n            env: {\n                TARO_ENV: JSON.stringify('h5'),\n                FRAMEWORK: JSON.stringify(this.config.framework),\n                TARO_VERSION: JSON.stringify((0, package_1.getPkgVersion)())\n            },\n            devServer: { port },\n            sourceRoot: this.config.sourceRoot || SOURCE_DIR,\n            outputRoot: this.config.outputRoot || OUTPUT_DIR\n        });\n        config.entry = (0, lodash_1.merge)(defaultEntry, customEntry);\n        return Object.assign(Object.assign({}, config), extraOptions);\n    }\n    /**\n     * 调用 runner 开始编译\n     * @param extraOptions 需要额外传入 runner 的配置项\n     */\n    build(extraOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_b = (_a = this.ctx).onBuildInit) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n            yield this.buildTransaction.perform(this.buildWebApp, this, extraOptions);\n        });\n    }\n    buildWebApp(extraOptions = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runner = yield this.getRunner();\n            const options = this.getOptions(Object.assign({\n                runtimePath: this.runtimePath,\n            }, extraOptions));\n            yield runner(options);\n        });\n    }\n    /**\n     * 调用 runner 开启编译\n     */\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.setup();\n            yield this.build();\n        });\n    }\n}\nexports.TaroPlatformWeb = TaroPlatformWeb;\n//# sourceMappingURL=web.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printPkgVersion = exports.getPkgVersion = exports.getRootPath = void 0;\n/* eslint-disable no-console */\nconst path = require(\"path\");\nfunction getRootPath() {\n    return path.resolve(__dirname, '../../');\n}\nexports.getRootPath = getRootPath;\nfunction getPkgVersion() {\n    return require(path.join(getRootPath(), 'package.json')).version;\n}\nexports.getPkgVersion = getPkgVersion;\nfunction printPkgVersion() {\n    console.log(`👽 Taro v${getPkgVersion()}`);\n    console.log();\n}\nexports.printPkgVersion = printPkgVersion;\n//# sourceMappingURL=package.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map"]}