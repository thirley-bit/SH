{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _core = require(\"@babel/core\");\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _template = require(\"@babel/template\");\nconst DefineAccessorHelper = _template.default.expression.ast`\nfunction (type, obj, key, fn) {\n  var desc = { configurable: true, enumerable: true };\n  desc[type] = fn;\n  return Object.defineProperty(obj, key, desc);\n}`;\nDefineAccessorHelper._compact = true;\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption;\n  api.assertVersion(7);\n  const setComputedProperties = (_api$assumption = api.assumption(\"setComputedProperties\")) != null ? _api$assumption : options.loose;\n  const pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;\n  function buildDefineAccessor(state, type, obj, key, fn) {\n    let helper;\n    if (state.availableHelper(\"defineAccessor\")) {\n      helper = state.addHelper(\"defineAccessor\");\n    } else {\n      const file = state.file;\n      helper = file.get(\"fallbackDefineAccessorHelper\");\n      if (!helper) {\n        const id = file.scope.generateUidIdentifier(\"defineAccessor\");\n        file.scope.push({\n          id,\n          init: DefineAccessorHelper\n        });\n        file.set(\"fallbackDefineAccessorHelper\", helper = id);\n      }\n      helper = _core.types.cloneNode(helper);\n    }\n    return _core.types.callExpression(helper, [_core.types.stringLiteral(type), obj, key, fn]);\n  }\n\n  function getValue(prop) {\n    if (_core.types.isObjectProperty(prop)) {\n      return prop.value;\n    } else if (_core.types.isObjectMethod(prop)) {\n      return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);\n    }\n  }\n  function pushAssign(objId, prop, body) {\n    body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));\n  }\n  function pushAccessorDefine({\n    body,\n    computedProps,\n    initPropExpression,\n    objId,\n    state\n  }, prop) {\n    const kind = prop.kind;\n    const key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;\n    const value = getValue(prop);\n    if (computedProps.length === 1) {\n      return buildDefineAccessor(state, kind, initPropExpression, key, value);\n    } else {\n      body.push(_core.types.expressionStatement(buildDefineAccessor(state, kind, _core.types.cloneNode(objId), key, value)));\n    }\n  }\n  function pushComputedPropsLoose(info) {\n    for (const prop of info.computedProps) {\n      if (_core.types.isObjectMethod(prop) && (prop.kind === \"get\" || prop.kind === \"set\")) {\n        const single = pushAccessorDefine(info, prop);\n        if (single) return single;\n      } else {\n        pushAssign(_core.types.cloneNode(info.objId), prop, info.body);\n      }\n    }\n  }\n  function pushComputedPropsSpec(info) {\n    const {\n      objId,\n      body,\n      computedProps,\n      state\n    } = info;\n    for (const prop of computedProps) {\n      const key = _core.types.toComputedKey(prop);\n      if (_core.types.isObjectMethod(prop) && (prop.kind === \"get\" || prop.kind === \"set\")) {\n        const single = pushAccessorDefine(info, prop);\n        if (single) return single;\n      } else {\n        const value = getValue(prop);\n        if (computedProps.length === 1) {\n          return _core.types.callExpression(state.addHelper(\"defineProperty\"), [info.initPropExpression, key, value]);\n        } else {\n          body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [_core.types.cloneNode(objId), key, value])));\n        }\n      }\n    }\n  }\n  return {\n    name: \"transform-computed-properties\",\n    visitor: {\n      ObjectExpression: {\n        exit(path, state) {\n          const {\n            node,\n            parent,\n            scope\n          } = path;\n          let hasComputed = false;\n          for (const prop of node.properties) {\n            hasComputed = prop.computed === true;\n            if (hasComputed) break;\n          }\n          if (!hasComputed) return;\n\n          const initProps = [];\n          const computedProps = [];\n          let foundComputed = false;\n          for (const prop of node.properties) {\n            if (_core.types.isSpreadElement(prop)) {\n              continue;\n            }\n            if (prop.computed) {\n              foundComputed = true;\n            }\n            if (foundComputed) {\n              computedProps.push(prop);\n            } else {\n              initProps.push(prop);\n            }\n          }\n          const objId = scope.generateUidIdentifierBasedOnNode(parent);\n          const initPropExpression = _core.types.objectExpression(initProps);\n          const body = [];\n          body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(objId, initPropExpression)]));\n          const single = pushComputedProps({\n            scope,\n            objId,\n            body,\n            computedProps,\n            initPropExpression,\n            state\n          });\n          if (single) {\n            path.replaceWith(single);\n          } else {\n            body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));\n            path.replaceWithMultiple(body);\n          }\n        }\n      }\n    }\n  };\n});\nexports.default = _default;\n\n//# sourceMappingURL=index.js.map\n"]}