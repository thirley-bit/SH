{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar core = require('@babel/core');\n\nfunction isPureVoid(node) {\n  return core.types.isUnaryExpression(node) && node.operator === \"void\" && core.types.isPureish(node.argument);\n}\nfunction unshiftForXStatementBody(statementPath, newStatements) {\n  statementPath.ensureBlock();\n  const {\n    scope,\n    node\n  } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(name => scope.hasBinding(name));\n  if (hasShadowedBlockScopedBindings) {\n    node.body = core.types.blockStatement([...newStatements, node.body]);\n  } else {\n    node.body.body.unshift(...newStatements);\n  }\n}\nfunction hasArrayRest(pattern) {\n  return pattern.elements.some(elem => core.types.isRestElement(elem));\n}\nfunction hasObjectRest(pattern) {\n  return pattern.properties.some(prop => core.types.isRestElement(prop));\n}\nconst STOP_TRAVERSAL = {};\nconst arrayUnpackVisitor = (node, ancestors, state) => {\n  if (!ancestors.length) {\n    return;\n  }\n  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\nclass DestructuringTransformer {\n  constructor(opts) {\n    this.blockHoist = void 0;\n    this.operator = void 0;\n    this.arrayRefSet = void 0;\n    this.nodes = void 0;\n    this.scope = void 0;\n    this.kind = void 0;\n    this.iterableIsArray = void 0;\n    this.arrayLikeIsIterable = void 0;\n    this.objectRestNoSymbols = void 0;\n    this.useBuiltIns = void 0;\n    this.addHelper = void 0;\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n  getExtendsHelper() {\n    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : this.addHelper(\"extends\");\n  }\n  buildVariableAssignment(id, init) {\n    let op = this.operator;\n    if (core.types.isMemberExpression(id)) op = \"=\";\n    let node;\n    if (op) {\n      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n    } else {\n      let nodeInit;\n      if ((this.kind === \"const\" || this.kind === \"using\") && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = core.types.cloneNode(init);\n      }\n      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);\n    }\n    node._blockHoist = this.blockHoist;\n    return node;\n  }\n  buildVariableDeclaration(id, init) {\n    const declar = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n  push(id, _init) {\n    const init = core.types.cloneNode(_init);\n    if (core.types.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (core.types.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (core.types.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n  toArray(node, count) {\n    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n  pushAssignmentPattern({\n    left,\n    right\n  }, valueRef) {\n    if (isPureVoid(valueRef)) {\n      this.push(left, right);\n      return;\n    }\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression(\"===\", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));\n    if (core.types.isPattern(left)) {\n      let patternId;\n      let node;\n      if (this.kind === \"const\" || this.kind === \"let\" || this.kind === \"using\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n        node = core.types.expressionStatement(core.types.assignmentExpression(\"=\", core.types.cloneNode(tempId), tempConditional));\n      }\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n  pushObjectProperty(prop, propRef) {\n    if (core.types.isLiteral(prop.key)) prop.computed = true;\n    const pattern = prop.value;\n    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);\n    if (core.types.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n  pushObjectPattern(pattern, objRef) {\n    if (!pattern.properties.length) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), isPureVoid(objRef) ? [] : [objRef])));\n      return;\n    }\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n    if (hasObjectRest(pattern)) {\n      let copiedPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (core.types.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(this.buildVariableDeclaration(name, key));\n          if (!copiedPattern) {\n            copiedPattern = pattern = Object.assign({}, pattern, {\n              properties: pattern.properties.slice()\n            });\n          }\n          copiedPattern.properties[i] = Object.assign({}, prop, {\n            key: name\n          });\n        }\n      }\n    }\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (core.types.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n  canUnpackArrayPattern(pattern, arr) {\n    if (!core.types.isArrayExpression(arr)) return false;\n    if (pattern.elements.length > arr.elements.length) return;\n    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {\n      return false;\n    }\n    for (const elem of pattern.elements) {\n      if (!elem) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n    for (const elem of arr.elements) {\n      if (core.types.isSpreadElement(elem)) return false;\n      if (core.types.isCallExpression(elem)) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n    const bindings = core.types.getBindingIdentifiers(pattern);\n    const state = {\n      deopt: false,\n      bindings\n    };\n    try {\n      core.types.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n    return !state.deopt;\n  }\n  pushUnpackedArrayPattern(pattern, arr) {\n    const holeToUndefined = el => el != null ? el : this.scope.buildUndefinedNode();\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (core.types.isRestElement(elem)) {\n        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));\n      } else {\n        this.push(elem, holeToUndefined(arr.elements[i]));\n      }\n    }\n  }\n  pushArrayPattern(pattern, arrayRef) {\n    if (arrayRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [])));\n      return;\n    }\n    if (!pattern.elements) return;\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      this.pushUnpackedArrayPattern(pattern, arrayRef);\n      return;\n    }\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n    const toArray = this.toArray(arrayRef, count);\n    if (core.types.isIdentifier(toArray)) {\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (!elem) continue;\n      let elemRef;\n      if (core.types.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier(\"slice\")), [core.types.numericLiteral(i)]);\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n  init(pattern, ref) {\n    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n    this.push(pattern, ref);\n    return this.nodes;\n  }\n}\nfunction buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (core.types.isIdentifier(key) && !prop.computed) {\n      keys.push(core.types.stringLiteral(key.name));\n    } else if (core.types.isTemplateLiteral(key)) {\n      keys.push(core.types.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (core.types.isLiteral(key)) {\n      keys.push(core.types.stringLiteral(String(key.value)));\n    } else if (core.types.isPrivateName(key)) ; else {\n      keys.push(core.types.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : addHelper(\"extends\");\n    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(addHelper(\"objectDestructuringEmpty\"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])]);\n  } else {\n    let keyExpression = core.types.arrayExpression(keys);\n    if (!allLiteral) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier(\"map\")), [addHelper(\"toPropertyKey\")]);\n    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\"\n      });\n      keyExpression = core.types.cloneNode(id);\n    }\n    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression]);\n  }\n  return value;\n}\nfunction convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope\n  } = path;\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n    const patternId = declar.init;\n    const pattern = declar.id;\n    const destructuring = new DestructuringTransformer({\n      blockHoist: node._blockHoist,\n      nodes: nodes,\n      scope: scope,\n      kind: node.kind,\n      iterableIsArray,\n      arrayLikeIsIterable,\n      useBuiltIns,\n      objectRestNoSymbols,\n      addHelper\n    });\n    if (core.types.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n      if (+i !== node.declarations.length - 1) {\n        core.types.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));\n    }\n  }\n  let tail = null;\n  let nodesOut = [];\n  for (const node of nodes) {\n    if (core.types.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(node);\n  }\n  if (nodesOut.length === 2 && core.types.isVariableDeclaration(nodesOut[0]) && core.types.isExpressionStatement(nodesOut[1]) && core.types.isCallExpression(nodesOut[1].expression) && nodesOut[0].declarations.length === 1) {\n    const expr = nodesOut[1].expression;\n    expr.arguments = [nodesOut[0].declarations[0].init];\n    nodesOut = [expr];\n  } else {\n    if (core.types.isForStatement(path.parent, {\n      init: node\n    }) && !nodesOut.some(v => core.types.isVariableDeclaration(v))) {\n      for (let i = 0; i < nodesOut.length; i++) {\n        const node = nodesOut[i];\n        if (core.types.isExpressionStatement(node)) {\n          nodesOut[i] = node.expression;\n        }\n      }\n    }\n  }\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\nfunction convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope,\n    parentPath\n  } = path;\n  const nodes = [];\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper\n  });\n  let ref;\n  if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n    nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(ref, node.right)]));\n    if (core.types.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n  destructuring.init(node.left, ref || node.right);\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(core.types.blockStatement([]));\n      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));\n    } else {\n      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));\n    }\n  }\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n\nfunction variableDeclarationHasPattern(node) {\n  for (const declar of node.declarations) {\n    if (core.types.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar index = helperPluginUtils.declare((api, options) => {\n  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false\n  } = options;\n  const iterableIsArray = (_ref = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose) != null ? _ref : false;\n  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\")) != null ? _ref2 : false;\n  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));\n        }\n        path.replaceWith(declaration.node);\n        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n        if (core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", left, core.types.cloneNode(temp))));\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n        if (!core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n      AssignmentExpression(path, state) {\n        if (!core.types.isPattern(path.node.left)) return;\n        convertAssignmentExpression(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      },\n      VariableDeclaration(path, state) {\n        const {\n          node,\n          parent\n        } = path;\n        if (core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      }\n    }\n  };\n});\n\nexports.buildObjectExcludingKeys = buildObjectExcludingKeys;\nexports[\"default\"] = index;\nexports.unshiftForXStatementBody = unshiftForXStatementBody;\n//# sourceMappingURL=index.js.map\n"]}