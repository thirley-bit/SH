{"version":3,"sources":["rewrite-pattern.js","data/iu-mappings.js","data/character-class-escape-sets.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst generate = require('@babel/regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction flatMap(array, callback) {\n\tconst result = [];\n\tarray.forEach(item => {\n\t\tconst res = callback(item);\n\t\tif (Array.isArray(res)) {\n\t\t\tresult.push.apply(result, res);\n\t\t} else {\n\t\t\tresult.push(res);\n\t\t}\n\t});\n\treturn result;\n}\n\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n\nconst ASTRAL_SET = regenerate().addRange(0x10000, 0x10FFFF);\n\nconst NEWLINE_SET = regenerate().add(\n\t// `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t0x000A, // Line Feed <LF>\n\t0x000D, // Carriage Return <CR>\n\t0x2028, // Line Separator <LS>\n\t0x2029  // Paragraph Separator <PS>\n);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(NEWLINE_SET);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a property\n\t// of strings.\n\ttry {\n\t\treturn getUnicodePropertyValueSet('Property_of_Strings', value);\n\t} catch (exception) {}\n\t// Lastly, check if it’s a binary property of single code points.\n\t// Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\tif (set.strings) {\n\t\t\tthrow new Error('Cannot negate Unicode property of strings');\n\t\t}\n\t\treturn {\n\t\t\tcharacters: UNICODE_SET.clone().remove(set.characters),\n\t\t\tstrings: new Set()\n\t\t};\n\t}\n\treturn {\n\t\tcharacters: set.characters.clone(),\n\t\tstrings: set.strings\n\t\t\t// We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n\t\t\t? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1')))\n\t\t\t: new Set()\n\t};\n};\n\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n\tconst set = getUnicodePropertyEscapeSet(property, isNegative);\n\tconst data = getCharacterClassEmptyData();\n\tdata.singleChars = set.characters;\n\tif (set.strings.size > 0) {\n\t\tdata.longStrings = set.strings;\n\t\tdata.maybeIncludesStrings = true;\n\t}\n\treturn data;\n};\n\nfunction configNeedCaseFoldAscii() {\n\treturn !!config.modifiersData.i;\n}\n\nfunction configNeedCaseFoldUnicode() {\n\t// config.modifiersData.i : undefined | false\n\tif (config.modifiersData.i === false) return false;\n\tif (!config.transform.unicodeFlag) return false;\n\treturn Boolean(config.modifiersData.i || config.flags.ignoreCase);\n}\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\nregenerate.prototype.iuRemoveRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n\t\tif (folded) {\n\t\t\t$this.remove(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '', {\n\t\tlookbehind: true,\n\t\tnamedGroups: true,\n\t\tunicodePropertyEscape: true,\n\t\tunicodeSet: true,\n\t\tmodifiers: true,\n\t});\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint, includeAscii, includeUnicode) => {\n\tlet folded = (includeUnicode ? iuMappings.get(codePoint) : undefined) || [];\n\tif (typeof folded === 'number') folded = [folded];\n\tif (includeAscii) {\n\t\tif (codePoint >= 0x41 && codePoint <= 0x5A) {\n\t\t\tfolded.push(codePoint + 0x20);\n\t\t} else if (codePoint >= 0x61 && codePoint <= 0x7A) {\n\t\t\tfolded.push(codePoint - 0x20);\n\t\t}\n\t}\n\treturn folded.length == 0 ? false : folded;\n};\n\nconst buildHandler = (action) => {\n\tswitch (action) {\n\t\tcase 'union':\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars.add(cp);\n\t\t\t\t},\n\t\t\t\tregSet: (data, set2) => {\n\t\t\t\t\tdata.singleChars.add(set2);\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.addRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.iuAddRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tdata.singleChars.add(nestedData.singleChars);\n\t\t\t\t\tfor (const str of nestedData.longStrings) data.longStrings.add(str);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n\t\t\t\t}\n\t\t\t};\n\t\tcase 'union-negative': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tdata.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tconst unicode = UNICODE_SET.clone();\n\t\t\t\t\tdata.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'intersection': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars = set2;\n\t\t\t\telse data.singleChars.intersection(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tregSet: (data, set) => {\n\t\t\t\t\tregSet(data, set);\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().addRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().iuAddRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'subtraction': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars.add(set2);\n\t\t\t\telse data.singleChars.remove(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tif (data.first) data.singleChars.add(cp);\n\t\t\t\t\telse data.singleChars.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.removeRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.iuRemoveRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown set action: ${ characterClassItem.kind }`);\n\t}\n};\n\nconst getCharacterClassEmptyData = () => ({\n\ttransformed: config.transform.unicodeFlag,\n\tsingleChars: regenerate(),\n\tlongStrings: new Set(),\n\thasEmptyString: false,\n\tfirst: true,\n\tmaybeIncludesStrings: false\n});\n\nconst maybeFold = (codePoint) => {\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tif (caseFoldAscii || caseFoldUnicode) {\n\t\tconst folded = caseFold(codePoint, caseFoldAscii, caseFoldUnicode);\n\t\tif (folded) {\n\t\t\treturn [codePoint, folded];\n\t\t}\n\t}\n\treturn [codePoint];\n};\n\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tfor (const string of classStrings.strings) {\n\t\tif (string.characters.length === 1) {\n\t\t\tmaybeFold(string.characters[0].codePoint).forEach((cp) => {\n\t\t\t\tdata.singleChars.add(cp);\n\t\t\t});\n\t\t} else {\n\t\t\tlet stringifiedString;\n\t\t\tif (caseFoldUnicode || caseFoldAscii) {\n\t\t\t\tstringifiedString = '';\n\t\t\t\tfor (const ch of string.characters) {\n\t\t\t\t\tlet set = regenerate(ch.codePoint);\n\t\t\t\t\tconst folded = maybeFold(ch.codePoint);\n\t\t\t\t\tif (folded) set.add(folded);\n\t\t\t\t\tstringifiedString += set.toString(regenerateOptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstringifiedString = string.characters.map(ch => generate(ch)).join('')\n\t\t\t}\n\n\t\t\tdata.longStrings.add(stringifiedString);\n\t\t\tdata.maybeIncludesStrings = true;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tlet handlePositive;\n\tlet handleNegative;\n\n\tswitch (characterClassItem.kind) {\n\t\tcase 'union':\n\t\t\thandlePositive = buildHandler('union');\n\t\t\thandleNegative = buildHandler('union-negative');\n\t\t\tbreak;\n\t\tcase 'intersection':\n\t\t\thandlePositive = buildHandler('intersection');\n\t\t\thandleNegative = buildHandler('subtraction');\n\t\t\tif (config.transform.unicodeSetsFlag) data.transformed = true;\n\t\t\tbreak;\n\t\tcase 'subtraction':\n\t\t\thandlePositive = buildHandler('subtraction');\n\t\t\thandleNegative = buildHandler('intersection');\n\t\t\tif (config.transform.unicodeSetsFlag) data.transformed = true;\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown character class kind: ${ characterClassItem.kind }`);\n\t}\n\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tmaybeFold(item.codePoint).forEach((cp) => {\n\t\t\t\t\thandlePositive.single(data, cp);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\thandlePositive.range(data, min, max);\n\t\t\t\tif (caseFoldAscii || caseFoldUnicode) {\n\t\t\t\t\thandlePositive.iuRange(data, min, max);\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\thandlePositive.regSet(data, getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.flags.unicode,\n\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tconst nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\t\thandlePositive.nested(data, nestedData);\n\t\t\t\tdata.transformed =\n\t\t\t\t\tdata.transformed ||\n\t\t\t\t\tconfig.transform.unicodePropertyEscapes ||\n\t\t\t\t\t(config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings);\n\t\t\t\tbreak;\n\t\t\tcase 'characterClass':\n\t\t\t\tconst handler = item.negative ? handleNegative : handlePositive;\n\t\t\t\tconst res = computeCharacterClass(item, regenerateOptions);\n\t\t\t\thandler.nested(data, res);\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\tcase 'classStrings':\n\t\t\t\thandlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\n\t\tdata.first = false;\n\t}\n\n\tif (characterClassItem.negative && data.maybeIncludesStrings) {\n\t\tthrow new SyntaxError('Cannot negate set containing strings');\n\t}\n\n\treturn data;\n}\n\nconst processCharacterClass = (\n\tcharacterClassItem,\n\tregenerateOptions,\n\tcomputed = computeCharacterClass(characterClassItem, regenerateOptions)\n) => {\n\tconst negative = characterClassItem.negative;\n\tconst { singleChars, transformed, longStrings } = computed;\n\tif (transformed) {\n\t\tconst setStr = singleChars.toString(regenerateOptions);\n\n\t\tif (negative) {\n\t\t\tif (config.useUnicodeFlag) {\n\t\t\t\tupdate(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`)\n\t\t\t} else {\n\t\t\t\tif (config.flags.unicode) {\n\t\t\t\t\tif (config.flags.ignoreCase) {\n\t\t\t\t\t\tconst astralCharsSet = singleChars.clone().intersection(ASTRAL_SET);\n\t\t\t\t\t\t// Assumption: singleChars do not contain lone surrogates.\n\t\t\t\t\t\t// Regex like /[^\\ud800]/u is not supported\n\t\t\t\t\t\tconst surrogateOrBMPSetStr = singleChars\n\t\t\t\t\t\t\t.clone()\n\t\t\t\t\t\t\t.remove(astralCharsSet)\n\t\t\t\t\t\t\t.addRange(0xd800, 0xdfff)\n\t\t\t\t\t\t\t.toString({ bmpOnly: true });\n\t\t\t\t\t\t// Don't generate negative lookahead for astral characters\n\t\t\t\t\t\t// because the case folding is not working anyway as we break\n\t\t\t\t\t\t// code points into surrogate pairs.\n\t\t\t\t\t\tconst astralNegativeSetStr = ASTRAL_SET\n\t\t\t\t\t\t\t.clone()\n\t\t\t\t\t\t\t.remove(astralCharsSet)\n\t\t\t\t\t\t\t.toString(regenerateOptions);\n\t\t\t\t\t\t// The transform here does not support lone surrogates.\n\t\t\t\t\t\tupdate(\n\t\t\t\t\t\t\tcharacterClassItem,\n\t\t\t\t\t\t\t`(?!${surrogateOrBMPSetStr})[\\\\s\\\\S]|${astralNegativeSetStr}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Generate negative set directly when case folding is not involved.\n\t\t\t\t\t\tupdate(\n\t\t\t\t\t\t\tcharacterClassItem,\n\t\t\t\t\t\t\tUNICODE_SET.clone().remove(singleChars).toString(regenerateOptions)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tupdate(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst hasEmptyString = longStrings.has('');\n\t\t\tconst pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n\n\t\t\tif (setStr !== '[]' || longStrings.size === 0) {\n\t\t\t\tpieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n\t\t\t}\n\n\t\t\tupdate(characterClassItem, pieces.join('|'));\n\t\t}\n\t}\n\treturn characterClassItem;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processModifiers = (item, regenerateOptions, groups) => {\n\tconst enabling = item.modifierFlags.enabling;\n\tconst disabling = item.modifierFlags.disabling;\n\n\tdelete item.modifierFlags;\n\titem.behavior = 'ignore';\n\n\tconst oldData = Object.assign({}, config.modifiersData);\n\n\tenabling.split('').forEach(flag => {\n\t\tconfig.modifiersData[flag] = true;\n\t});\n\tdisabling.split('').forEach(flag => {\n\t\tconfig.modifiersData[flag] = false;\n\t});\n\n\titem.body = item.body.map(term => {\n\t\treturn processTerm(term, regenerateOptions, groups);\n\t});\n\n\tconfig.modifiersData = oldData;\n\n\treturn item;\n}\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.flags.dotAll || config.modifiersData.s).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.transform.dotAllFlag || config.modifiersData.s) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tconst data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\tif (data.maybeIncludesStrings) {\n\t\t\t\tif (!config.flags.unicodeSets) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Properties of strings are only supported when using the unicodeSets (v) flag.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t\titem = processCharacterClass(item, regenerateOptions, data);\n\t\t\t\t}\n\t\t\t} else if (config.transform.unicodePropertyEscapes) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tdata.singleChars.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t/* config.transform.unicodeFlag implies config.flags.unicode */ true,\n\t\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t\t).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.namesConflicts[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Group '${ name }' has already been defined in this context.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tgroups.namesConflicts[name] = true;\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tdelete item.name;\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tif (!groups.names[name]) {\n\t\t\t\t\tgroups.names[name] = [];\n\t\t\t\t}\n\t\t\t\tgroups.names[name].push(index);\n\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.modifierFlags && config.transform.modifiers) {\n\t\t\t\treturn processModifiers(item, regenerateOptions, groups);\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'disjunction':\n\t\t\tconst outerNamesConflicts = groups.namesConflicts;\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\tgroups.namesConflicts = Object.create(outerNamesConflicts);\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'alternative':\n\t\t\titem.body = flatMap(item.body, term => {\n\t\t\t\tconst res = processTerm(term, regenerateOptions, groups);\n\t\t\t\t// Alternatives cannot contain alternatives; flatten them.\n\t\t\t\treturn res.type === 'alternative' ? res.body : res;\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tconst folded = maybeFold(codePoint);\n\t\t\tset.add(folded);\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst indexes = groups.names[name];\n\t\t\t\tif (!indexes) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = true;\n\t\t\t\t}\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tif (indexes) {\n\t\t\t\t\t\tconst body = indexes.map(index => ({\n\t\t\t\t\t\t\t'type': 'reference',\n\t\t\t\t\t\t\t'matchIndex': index,\n\t\t\t\t\t\t\t'raw': '\\\\' + index,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (body.length === 1) {\n\t\t\t\t\t\t\treturn body[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'alternative',\n\t\t\t\t\t\t\t'body': body,\n\t\t\t\t\t\t\t'raw': body.map(term => term.raw).join(''),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// This named reference comes before the group where it’s defined,\n\t\t\t\t\t// so it’s always an empty match.\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'group',\n\t\t\t\t\t\t'behavior': 'ignore',\n\t\t\t\t\t\t'body': [],\n\t\t\t\t\t\t'raw': '(?:)',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\t\tif (config.modifiersData.m) {\n\t\t\t\tif (item.kind == 'start') {\n\t\t\t\t\tupdate(item, `(?:^|(?<=${NEWLINE_SET.toString()}))`);\n\t\t\t\t} else if (item.kind == 'end') {\n\t\t\t\t\tupdate(item, `(?:$|(?=${NEWLINE_SET.toString()}))`);\n\t\t\t\t}\n\t\t\t}\n\t\tcase 'empty':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'flags': {\n\t\t'ignoreCase': false,\n\t\t'unicode': false,\n\t\t'unicodeSets': false,\n\t\t'dotAll': false,\n\t\t'multiline': false,\n\t},\n\t'transform': {\n\t\t'dotAllFlag': false,\n\t\t'unicodeFlag': false,\n\t\t'unicodeSetsFlag': false,\n\t\t'unicodePropertyEscapes': false,\n\t\t'namedGroups': false,\n\t\t'modifiers': false,\n\t},\n\t'modifiersData': {\n\t\t'i': undefined,\n\t\t's': undefined,\n\t\t'm': undefined,\n\t},\n\tget useUnicodeFlag() {\n\t\treturn (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n\t}\n};\n\nconst validateOptions = (options) => {\n\tif (!options) return;\n\n\tfor (const key of Object.keys(options)) {\n\t\tconst value = options[key];\n\t\tswitch (key) {\n\t\t\tcase 'dotAllFlag':\n\t\t\tcase 'unicodeFlag':\n\t\t\tcase 'unicodePropertyEscapes':\n\t\t\tcase 'namedGroups':\n\t\t\t\tif (value != null && value !== false && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default) or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'modifiers':\n\t\t\tcase 'unicodeSetsFlag':\n\t\t\t\tif (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'onNamedGroup':\n\t\t\tcase 'onNewFlags':\n\t\t\t\tif (value != null && typeof value !== 'function') {\n\t\t\t\t\tthrow new Error(`.${key} must be a function.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`.${key} is not a valid regexpu-core option.`);\n\t\t}\n\t}\n};\n\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\n\nconst rewritePattern = (pattern, flags, options) => {\n\tvalidateOptions(options);\n\n\tconfig.flags.unicode = hasFlag(flags, 'u');\n\tconfig.flags.unicodeSets = hasFlag(flags, 'v');\n\tconfig.flags.ignoreCase = hasFlag(flags, 'i');\n\tconfig.flags.dotAll = hasFlag(flags, 's');\n\tconfig.flags.multiline = hasFlag(flags, 'm');\n\n\tconfig.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n\tconfig.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n\tconfig.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n\t// unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n\tconfig.transform.unicodePropertyEscapes = config.flags.unicode && (\n\t\ttransform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes')\n\t);\n\tconfig.transform.namedGroups = transform(options, 'namedGroups');\n\tconfig.transform.modifiers = transform(options, 'modifiers');\n\n\tconfig.modifiersData.i = undefined;\n\tconfig.modifiersData.s = undefined;\n\tconfig.modifiersData.m = undefined;\n\n\tconst regjsparserFeatures = {\n\t\t'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n\t\t'modifiers': Boolean(options && options.modifiers),\n\n\t\t// Enable every stable RegExp feature by default\n\t\t'unicodePropertyEscape': true,\n\t\t'namedGroups': true,\n\t\t'lookbehind': true,\n\t};\n\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.flags.unicode\n\t};\n\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: Array<index> }\n\t\t'namesConflicts': Object.create(null), // { [name]: true }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: true }\n\t};\n\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\n\tif (config.transform.modifiers) {\n\t\tif (/\\(\\?[a-z]*-[a-z]+:/.test(pattern)) {\n\t\t\t// the pattern _likely_ contain inline disabled modifiers\n\t\t\t// we need to traverse to make sure that they are actually modifiers and to collect them\n\t\t\tconst allDisabledModifiers = Object.create(null)\n\t\t\tconst itemStack = [tree];\n\t\t\tlet node;\n\t\t\twhile (node = itemStack.pop(), node != undefined) {\n\t\t\t\tif (Array.isArray(node)) {\n\t\t\t\t\tArray.prototype.push.apply(itemStack, node);\n\t\t\t\t} else if (typeof node == 'object' && node != null) {\n\t\t\t\t\tfor (const key of Object.keys(node)) {\n\t\t\t\t\t\tconst value = node[key];\n\t\t\t\t\t\tif (key == 'modifierFlags') {\n\t\t\t\t\t\t\tif (value.disabling.length > 0){\n\t\t\t\t\t\t\t\tvalue.disabling.split('').forEach((flag)=>{\n\t\t\t\t\t\t\t\t\tallDisabledModifiers[flag] = true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof value == 'object' && value != null) {\n\t\t\t\t\t\t\titemStack.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const flag of Object.keys(allDisabledModifiers)) {\n\t\t\t\tconfig.modifiersData[flag] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\n\tconst onNewFlags = options && options.onNewFlags;\n\tif (onNewFlags) {\n\t\tlet newFlags = flags.split('').filter((flag) => !config.modifiersData[flag]).join('');\n\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\tnewFlags = newFlags.replace('v', 'u');\n\t\t}\n\t\tif (config.transform.unicodeFlag) {\n\t\t\tnewFlags = newFlags.replace('u', '');\n\t\t}\n\t\tif (config.transform.dotAllFlag === 'transform') {\n\t\t\tnewFlags = newFlags.replace('s', '');\n\t\t}\n\t\tonNewFlags(newFlags);\n\t}\n\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n","module.exports = new Map([\n\t[0x4B, 0x212A],\n\t[0x53, 0x17F],\n\t[0x6B, 0x212A],\n\t[0x73, 0x17F],\n\t[0xB5, 0x39C],\n\t[0xC5, 0x212B],\n\t[0xDF, 0x1E9E],\n\t[0xE5, 0x212B],\n\t[0x17F, 0x53],\n\t[0x1C4, 0x1C5],\n\t[0x1C5, 0x1C4],\n\t[0x1C7, 0x1C8],\n\t[0x1C8, 0x1C7],\n\t[0x1CA, 0x1CB],\n\t[0x1CB, 0x1CA],\n\t[0x1F1, 0x1F2],\n\t[0x1F2, 0x1F1],\n\t[0x345, 0x1FBE],\n\t[0x392, 0x3D0],\n\t[0x395, 0x3F5],\n\t[0x398, 0x3F4],\n\t[0x399, 0x1FBE],\n\t[0x39A, 0x3F0],\n\t[0x39C, 0xB5],\n\t[0x3A0, 0x3D6],\n\t[0x3A1, 0x3F1],\n\t[0x3A3, 0x3C2],\n\t[0x3A6, 0x3D5],\n\t[0x3A9, 0x2126],\n\t[0x3B8, 0x3F4],\n\t[0x3C2, 0x3A3],\n\t[0x3C9, 0x2126],\n\t[0x3D0, 0x392],\n\t[0x3D1, 0x3F4],\n\t[0x3D5, 0x3A6],\n\t[0x3D6, 0x3A0],\n\t[0x3F0, 0x39A],\n\t[0x3F1, 0x3A1],\n\t[0x3F4, [\n\t\t0x398,\n\t\t0x3D1,\n\t\t0x3B8\n\t]],\n\t[0x3F5, 0x395],\n\t[0x412, 0x1C80],\n\t[0x414, 0x1C81],\n\t[0x41E, 0x1C82],\n\t[0x421, 0x1C83],\n\t[0x422, 0x1C85],\n\t[0x42A, 0x1C86],\n\t[0x462, 0x1C87],\n\t[0x1C80, 0x412],\n\t[0x1C81, 0x414],\n\t[0x1C82, 0x41E],\n\t[0x1C83, 0x421],\n\t[0x1C84, 0x1C85],\n\t[0x1C85, [\n\t\t0x422,\n\t\t0x1C84\n\t]],\n\t[0x1C86, 0x42A],\n\t[0x1C87, 0x462],\n\t[0x1C88, 0xA64A],\n\t[0x1E60, 0x1E9B],\n\t[0x1E9B, 0x1E60],\n\t[0x1E9E, 0xDF],\n\t[0x1F80, 0x1F88],\n\t[0x1F81, 0x1F89],\n\t[0x1F82, 0x1F8A],\n\t[0x1F83, 0x1F8B],\n\t[0x1F84, 0x1F8C],\n\t[0x1F85, 0x1F8D],\n\t[0x1F86, 0x1F8E],\n\t[0x1F87, 0x1F8F],\n\t[0x1F88, 0x1F80],\n\t[0x1F89, 0x1F81],\n\t[0x1F8A, 0x1F82],\n\t[0x1F8B, 0x1F83],\n\t[0x1F8C, 0x1F84],\n\t[0x1F8D, 0x1F85],\n\t[0x1F8E, 0x1F86],\n\t[0x1F8F, 0x1F87],\n\t[0x1F90, 0x1F98],\n\t[0x1F91, 0x1F99],\n\t[0x1F92, 0x1F9A],\n\t[0x1F93, 0x1F9B],\n\t[0x1F94, 0x1F9C],\n\t[0x1F95, 0x1F9D],\n\t[0x1F96, 0x1F9E],\n\t[0x1F97, 0x1F9F],\n\t[0x1F98, 0x1F90],\n\t[0x1F99, 0x1F91],\n\t[0x1F9A, 0x1F92],\n\t[0x1F9B, 0x1F93],\n\t[0x1F9C, 0x1F94],\n\t[0x1F9D, 0x1F95],\n\t[0x1F9E, 0x1F96],\n\t[0x1F9F, 0x1F97],\n\t[0x1FA0, 0x1FA8],\n\t[0x1FA1, 0x1FA9],\n\t[0x1FA2, 0x1FAA],\n\t[0x1FA3, 0x1FAB],\n\t[0x1FA4, 0x1FAC],\n\t[0x1FA5, 0x1FAD],\n\t[0x1FA6, 0x1FAE],\n\t[0x1FA7, 0x1FAF],\n\t[0x1FA8, 0x1FA0],\n\t[0x1FA9, 0x1FA1],\n\t[0x1FAA, 0x1FA2],\n\t[0x1FAB, 0x1FA3],\n\t[0x1FAC, 0x1FA4],\n\t[0x1FAD, 0x1FA5],\n\t[0x1FAE, 0x1FA6],\n\t[0x1FAF, 0x1FA7],\n\t[0x1FB3, 0x1FBC],\n\t[0x1FBC, 0x1FB3],\n\t[0x1FBE, [\n\t\t0x345,\n\t\t0x399\n\t]],\n\t[0x1FC3, 0x1FCC],\n\t[0x1FCC, 0x1FC3],\n\t[0x1FF3, 0x1FFC],\n\t[0x1FFC, 0x1FF3],\n\t[0x2126, [\n\t\t0x3A9,\n\t\t0x3C9\n\t]],\n\t[0x212A, 0x4B],\n\t[0x212B, [\n\t\t0xC5,\n\t\t0xE5\n\t]],\n\t[0xA64A, 0x1C88],\n\t[0x10400, 0x10428],\n\t[0x10401, 0x10429],\n\t[0x10402, 0x1042A],\n\t[0x10403, 0x1042B],\n\t[0x10404, 0x1042C],\n\t[0x10405, 0x1042D],\n\t[0x10406, 0x1042E],\n\t[0x10407, 0x1042F],\n\t[0x10408, 0x10430],\n\t[0x10409, 0x10431],\n\t[0x1040A, 0x10432],\n\t[0x1040B, 0x10433],\n\t[0x1040C, 0x10434],\n\t[0x1040D, 0x10435],\n\t[0x1040E, 0x10436],\n\t[0x1040F, 0x10437],\n\t[0x10410, 0x10438],\n\t[0x10411, 0x10439],\n\t[0x10412, 0x1043A],\n\t[0x10413, 0x1043B],\n\t[0x10414, 0x1043C],\n\t[0x10415, 0x1043D],\n\t[0x10416, 0x1043E],\n\t[0x10417, 0x1043F],\n\t[0x10418, 0x10440],\n\t[0x10419, 0x10441],\n\t[0x1041A, 0x10442],\n\t[0x1041B, 0x10443],\n\t[0x1041C, 0x10444],\n\t[0x1041D, 0x10445],\n\t[0x1041E, 0x10446],\n\t[0x1041F, 0x10447],\n\t[0x10420, 0x10448],\n\t[0x10421, 0x10449],\n\t[0x10422, 0x1044A],\n\t[0x10423, 0x1044B],\n\t[0x10424, 0x1044C],\n\t[0x10425, 0x1044D],\n\t[0x10426, 0x1044E],\n\t[0x10427, 0x1044F],\n\t[0x10428, 0x10400],\n\t[0x10429, 0x10401],\n\t[0x1042A, 0x10402],\n\t[0x1042B, 0x10403],\n\t[0x1042C, 0x10404],\n\t[0x1042D, 0x10405],\n\t[0x1042E, 0x10406],\n\t[0x1042F, 0x10407],\n\t[0x10430, 0x10408],\n\t[0x10431, 0x10409],\n\t[0x10432, 0x1040A],\n\t[0x10433, 0x1040B],\n\t[0x10434, 0x1040C],\n\t[0x10435, 0x1040D],\n\t[0x10436, 0x1040E],\n\t[0x10437, 0x1040F],\n\t[0x10438, 0x10410],\n\t[0x10439, 0x10411],\n\t[0x1043A, 0x10412],\n\t[0x1043B, 0x10413],\n\t[0x1043C, 0x10414],\n\t[0x1043D, 0x10415],\n\t[0x1043E, 0x10416],\n\t[0x1043F, 0x10417],\n\t[0x10440, 0x10418],\n\t[0x10441, 0x10419],\n\t[0x10442, 0x1041A],\n\t[0x10443, 0x1041B],\n\t[0x10444, 0x1041C],\n\t[0x10445, 0x1041D],\n\t[0x10446, 0x1041E],\n\t[0x10447, 0x1041F],\n\t[0x10448, 0x10420],\n\t[0x10449, 0x10421],\n\t[0x1044A, 0x10422],\n\t[0x1044B, 0x10423],\n\t[0x1044C, 0x10424],\n\t[0x1044D, 0x10425],\n\t[0x1044E, 0x10426],\n\t[0x1044F, 0x10427],\n\t[0x104B0, 0x104D8],\n\t[0x104B1, 0x104D9],\n\t[0x104B2, 0x104DA],\n\t[0x104B3, 0x104DB],\n\t[0x104B4, 0x104DC],\n\t[0x104B5, 0x104DD],\n\t[0x104B6, 0x104DE],\n\t[0x104B7, 0x104DF],\n\t[0x104B8, 0x104E0],\n\t[0x104B9, 0x104E1],\n\t[0x104BA, 0x104E2],\n\t[0x104BB, 0x104E3],\n\t[0x104BC, 0x104E4],\n\t[0x104BD, 0x104E5],\n\t[0x104BE, 0x104E6],\n\t[0x104BF, 0x104E7],\n\t[0x104C0, 0x104E8],\n\t[0x104C1, 0x104E9],\n\t[0x104C2, 0x104EA],\n\t[0x104C3, 0x104EB],\n\t[0x104C4, 0x104EC],\n\t[0x104C5, 0x104ED],\n\t[0x104C6, 0x104EE],\n\t[0x104C7, 0x104EF],\n\t[0x104C8, 0x104F0],\n\t[0x104C9, 0x104F1],\n\t[0x104CA, 0x104F2],\n\t[0x104CB, 0x104F3],\n\t[0x104CC, 0x104F4],\n\t[0x104CD, 0x104F5],\n\t[0x104CE, 0x104F6],\n\t[0x104CF, 0x104F7],\n\t[0x104D0, 0x104F8],\n\t[0x104D1, 0x104F9],\n\t[0x104D2, 0x104FA],\n\t[0x104D3, 0x104FB],\n\t[0x104D8, 0x104B0],\n\t[0x104D9, 0x104B1],\n\t[0x104DA, 0x104B2],\n\t[0x104DB, 0x104B3],\n\t[0x104DC, 0x104B4],\n\t[0x104DD, 0x104B5],\n\t[0x104DE, 0x104B6],\n\t[0x104DF, 0x104B7],\n\t[0x104E0, 0x104B8],\n\t[0x104E1, 0x104B9],\n\t[0x104E2, 0x104BA],\n\t[0x104E3, 0x104BB],\n\t[0x104E4, 0x104BC],\n\t[0x104E5, 0x104BD],\n\t[0x104E6, 0x104BE],\n\t[0x104E7, 0x104BF],\n\t[0x104E8, 0x104C0],\n\t[0x104E9, 0x104C1],\n\t[0x104EA, 0x104C2],\n\t[0x104EB, 0x104C3],\n\t[0x104EC, 0x104C4],\n\t[0x104ED, 0x104C5],\n\t[0x104EE, 0x104C6],\n\t[0x104EF, 0x104C7],\n\t[0x104F0, 0x104C8],\n\t[0x104F1, 0x104C9],\n\t[0x104F2, 0x104CA],\n\t[0x104F3, 0x104CB],\n\t[0x104F4, 0x104CC],\n\t[0x104F5, 0x104CD],\n\t[0x104F6, 0x104CE],\n\t[0x104F7, 0x104CF],\n\t[0x104F8, 0x104D0],\n\t[0x104F9, 0x104D1],\n\t[0x104FA, 0x104D2],\n\t[0x104FB, 0x104D3],\n\t[0x10570, 0x10597],\n\t[0x10571, 0x10598],\n\t[0x10572, 0x10599],\n\t[0x10573, 0x1059A],\n\t[0x10574, 0x1059B],\n\t[0x10575, 0x1059C],\n\t[0x10576, 0x1059D],\n\t[0x10577, 0x1059E],\n\t[0x10578, 0x1059F],\n\t[0x10579, 0x105A0],\n\t[0x1057A, 0x105A1],\n\t[0x1057C, 0x105A3],\n\t[0x1057D, 0x105A4],\n\t[0x1057E, 0x105A5],\n\t[0x1057F, 0x105A6],\n\t[0x10580, 0x105A7],\n\t[0x10581, 0x105A8],\n\t[0x10582, 0x105A9],\n\t[0x10583, 0x105AA],\n\t[0x10584, 0x105AB],\n\t[0x10585, 0x105AC],\n\t[0x10586, 0x105AD],\n\t[0x10587, 0x105AE],\n\t[0x10588, 0x105AF],\n\t[0x10589, 0x105B0],\n\t[0x1058A, 0x105B1],\n\t[0x1058C, 0x105B3],\n\t[0x1058D, 0x105B4],\n\t[0x1058E, 0x105B5],\n\t[0x1058F, 0x105B6],\n\t[0x10590, 0x105B7],\n\t[0x10591, 0x105B8],\n\t[0x10592, 0x105B9],\n\t[0x10594, 0x105BB],\n\t[0x10595, 0x105BC],\n\t[0x10597, 0x10570],\n\t[0x10598, 0x10571],\n\t[0x10599, 0x10572],\n\t[0x1059A, 0x10573],\n\t[0x1059B, 0x10574],\n\t[0x1059C, 0x10575],\n\t[0x1059D, 0x10576],\n\t[0x1059E, 0x10577],\n\t[0x1059F, 0x10578],\n\t[0x105A0, 0x10579],\n\t[0x105A1, 0x1057A],\n\t[0x105A3, 0x1057C],\n\t[0x105A4, 0x1057D],\n\t[0x105A5, 0x1057E],\n\t[0x105A6, 0x1057F],\n\t[0x105A7, 0x10580],\n\t[0x105A8, 0x10581],\n\t[0x105A9, 0x10582],\n\t[0x105AA, 0x10583],\n\t[0x105AB, 0x10584],\n\t[0x105AC, 0x10585],\n\t[0x105AD, 0x10586],\n\t[0x105AE, 0x10587],\n\t[0x105AF, 0x10588],\n\t[0x105B0, 0x10589],\n\t[0x105B1, 0x1058A],\n\t[0x105B3, 0x1058C],\n\t[0x105B4, 0x1058D],\n\t[0x105B5, 0x1058E],\n\t[0x105B6, 0x1058F],\n\t[0x105B7, 0x10590],\n\t[0x105B8, 0x10591],\n\t[0x105B9, 0x10592],\n\t[0x105BB, 0x10594],\n\t[0x105BC, 0x10595],\n\t[0x10C80, 0x10CC0],\n\t[0x10C81, 0x10CC1],\n\t[0x10C82, 0x10CC2],\n\t[0x10C83, 0x10CC3],\n\t[0x10C84, 0x10CC4],\n\t[0x10C85, 0x10CC5],\n\t[0x10C86, 0x10CC6],\n\t[0x10C87, 0x10CC7],\n\t[0x10C88, 0x10CC8],\n\t[0x10C89, 0x10CC9],\n\t[0x10C8A, 0x10CCA],\n\t[0x10C8B, 0x10CCB],\n\t[0x10C8C, 0x10CCC],\n\t[0x10C8D, 0x10CCD],\n\t[0x10C8E, 0x10CCE],\n\t[0x10C8F, 0x10CCF],\n\t[0x10C90, 0x10CD0],\n\t[0x10C91, 0x10CD1],\n\t[0x10C92, 0x10CD2],\n\t[0x10C93, 0x10CD3],\n\t[0x10C94, 0x10CD4],\n\t[0x10C95, 0x10CD5],\n\t[0x10C96, 0x10CD6],\n\t[0x10C97, 0x10CD7],\n\t[0x10C98, 0x10CD8],\n\t[0x10C99, 0x10CD9],\n\t[0x10C9A, 0x10CDA],\n\t[0x10C9B, 0x10CDB],\n\t[0x10C9C, 0x10CDC],\n\t[0x10C9D, 0x10CDD],\n\t[0x10C9E, 0x10CDE],\n\t[0x10C9F, 0x10CDF],\n\t[0x10CA0, 0x10CE0],\n\t[0x10CA1, 0x10CE1],\n\t[0x10CA2, 0x10CE2],\n\t[0x10CA3, 0x10CE3],\n\t[0x10CA4, 0x10CE4],\n\t[0x10CA5, 0x10CE5],\n\t[0x10CA6, 0x10CE6],\n\t[0x10CA7, 0x10CE7],\n\t[0x10CA8, 0x10CE8],\n\t[0x10CA9, 0x10CE9],\n\t[0x10CAA, 0x10CEA],\n\t[0x10CAB, 0x10CEB],\n\t[0x10CAC, 0x10CEC],\n\t[0x10CAD, 0x10CED],\n\t[0x10CAE, 0x10CEE],\n\t[0x10CAF, 0x10CEF],\n\t[0x10CB0, 0x10CF0],\n\t[0x10CB1, 0x10CF1],\n\t[0x10CB2, 0x10CF2],\n\t[0x10CC0, 0x10C80],\n\t[0x10CC1, 0x10C81],\n\t[0x10CC2, 0x10C82],\n\t[0x10CC3, 0x10C83],\n\t[0x10CC4, 0x10C84],\n\t[0x10CC5, 0x10C85],\n\t[0x10CC6, 0x10C86],\n\t[0x10CC7, 0x10C87],\n\t[0x10CC8, 0x10C88],\n\t[0x10CC9, 0x10C89],\n\t[0x10CCA, 0x10C8A],\n\t[0x10CCB, 0x10C8B],\n\t[0x10CCC, 0x10C8C],\n\t[0x10CCD, 0x10C8D],\n\t[0x10CCE, 0x10C8E],\n\t[0x10CCF, 0x10C8F],\n\t[0x10CD0, 0x10C90],\n\t[0x10CD1, 0x10C91],\n\t[0x10CD2, 0x10C92],\n\t[0x10CD3, 0x10C93],\n\t[0x10CD4, 0x10C94],\n\t[0x10CD5, 0x10C95],\n\t[0x10CD6, 0x10C96],\n\t[0x10CD7, 0x10C97],\n\t[0x10CD8, 0x10C98],\n\t[0x10CD9, 0x10C99],\n\t[0x10CDA, 0x10C9A],\n\t[0x10CDB, 0x10C9B],\n\t[0x10CDC, 0x10C9C],\n\t[0x10CDD, 0x10C9D],\n\t[0x10CDE, 0x10C9E],\n\t[0x10CDF, 0x10C9F],\n\t[0x10CE0, 0x10CA0],\n\t[0x10CE1, 0x10CA1],\n\t[0x10CE2, 0x10CA2],\n\t[0x10CE3, 0x10CA3],\n\t[0x10CE4, 0x10CA4],\n\t[0x10CE5, 0x10CA5],\n\t[0x10CE6, 0x10CA6],\n\t[0x10CE7, 0x10CA7],\n\t[0x10CE8, 0x10CA8],\n\t[0x10CE9, 0x10CA9],\n\t[0x10CEA, 0x10CAA],\n\t[0x10CEB, 0x10CAB],\n\t[0x10CEC, 0x10CAC],\n\t[0x10CED, 0x10CAD],\n\t[0x10CEE, 0x10CAE],\n\t[0x10CEF, 0x10CAF],\n\t[0x10CF0, 0x10CB0],\n\t[0x10CF1, 0x10CB1],\n\t[0x10CF2, 0x10CB2],\n\t[0x118A0, 0x118C0],\n\t[0x118A1, 0x118C1],\n\t[0x118A2, 0x118C2],\n\t[0x118A3, 0x118C3],\n\t[0x118A4, 0x118C4],\n\t[0x118A5, 0x118C5],\n\t[0x118A6, 0x118C6],\n\t[0x118A7, 0x118C7],\n\t[0x118A8, 0x118C8],\n\t[0x118A9, 0x118C9],\n\t[0x118AA, 0x118CA],\n\t[0x118AB, 0x118CB],\n\t[0x118AC, 0x118CC],\n\t[0x118AD, 0x118CD],\n\t[0x118AE, 0x118CE],\n\t[0x118AF, 0x118CF],\n\t[0x118B0, 0x118D0],\n\t[0x118B1, 0x118D1],\n\t[0x118B2, 0x118D2],\n\t[0x118B3, 0x118D3],\n\t[0x118B4, 0x118D4],\n\t[0x118B5, 0x118D5],\n\t[0x118B6, 0x118D6],\n\t[0x118B7, 0x118D7],\n\t[0x118B8, 0x118D8],\n\t[0x118B9, 0x118D9],\n\t[0x118BA, 0x118DA],\n\t[0x118BB, 0x118DB],\n\t[0x118BC, 0x118DC],\n\t[0x118BD, 0x118DD],\n\t[0x118BE, 0x118DE],\n\t[0x118BF, 0x118DF],\n\t[0x118C0, 0x118A0],\n\t[0x118C1, 0x118A1],\n\t[0x118C2, 0x118A2],\n\t[0x118C3, 0x118A3],\n\t[0x118C4, 0x118A4],\n\t[0x118C5, 0x118A5],\n\t[0x118C6, 0x118A6],\n\t[0x118C7, 0x118A7],\n\t[0x118C8, 0x118A8],\n\t[0x118C9, 0x118A9],\n\t[0x118CA, 0x118AA],\n\t[0x118CB, 0x118AB],\n\t[0x118CC, 0x118AC],\n\t[0x118CD, 0x118AD],\n\t[0x118CE, 0x118AE],\n\t[0x118CF, 0x118AF],\n\t[0x118D0, 0x118B0],\n\t[0x118D1, 0x118B1],\n\t[0x118D2, 0x118B2],\n\t[0x118D3, 0x118B3],\n\t[0x118D4, 0x118B4],\n\t[0x118D5, 0x118B5],\n\t[0x118D6, 0x118B6],\n\t[0x118D7, 0x118B7],\n\t[0x118D8, 0x118B8],\n\t[0x118D9, 0x118B9],\n\t[0x118DA, 0x118BA],\n\t[0x118DB, 0x118BB],\n\t[0x118DC, 0x118BC],\n\t[0x118DD, 0x118BD],\n\t[0x118DE, 0x118BE],\n\t[0x118DF, 0x118BF],\n\t[0x16E40, 0x16E60],\n\t[0x16E41, 0x16E61],\n\t[0x16E42, 0x16E62],\n\t[0x16E43, 0x16E63],\n\t[0x16E44, 0x16E64],\n\t[0x16E45, 0x16E65],\n\t[0x16E46, 0x16E66],\n\t[0x16E47, 0x16E67],\n\t[0x16E48, 0x16E68],\n\t[0x16E49, 0x16E69],\n\t[0x16E4A, 0x16E6A],\n\t[0x16E4B, 0x16E6B],\n\t[0x16E4C, 0x16E6C],\n\t[0x16E4D, 0x16E6D],\n\t[0x16E4E, 0x16E6E],\n\t[0x16E4F, 0x16E6F],\n\t[0x16E50, 0x16E70],\n\t[0x16E51, 0x16E71],\n\t[0x16E52, 0x16E72],\n\t[0x16E53, 0x16E73],\n\t[0x16E54, 0x16E74],\n\t[0x16E55, 0x16E75],\n\t[0x16E56, 0x16E76],\n\t[0x16E57, 0x16E77],\n\t[0x16E58, 0x16E78],\n\t[0x16E59, 0x16E79],\n\t[0x16E5A, 0x16E7A],\n\t[0x16E5B, 0x16E7B],\n\t[0x16E5C, 0x16E7C],\n\t[0x16E5D, 0x16E7D],\n\t[0x16E5E, 0x16E7E],\n\t[0x16E5F, 0x16E7F],\n\t[0x16E60, 0x16E40],\n\t[0x16E61, 0x16E41],\n\t[0x16E62, 0x16E42],\n\t[0x16E63, 0x16E43],\n\t[0x16E64, 0x16E44],\n\t[0x16E65, 0x16E45],\n\t[0x16E66, 0x16E46],\n\t[0x16E67, 0x16E47],\n\t[0x16E68, 0x16E48],\n\t[0x16E69, 0x16E49],\n\t[0x16E6A, 0x16E4A],\n\t[0x16E6B, 0x16E4B],\n\t[0x16E6C, 0x16E4C],\n\t[0x16E6D, 0x16E4D],\n\t[0x16E6E, 0x16E4E],\n\t[0x16E6F, 0x16E4F],\n\t[0x16E70, 0x16E50],\n\t[0x16E71, 0x16E51],\n\t[0x16E72, 0x16E52],\n\t[0x16E73, 0x16E53],\n\t[0x16E74, 0x16E54],\n\t[0x16E75, 0x16E55],\n\t[0x16E76, 0x16E56],\n\t[0x16E77, 0x16E57],\n\t[0x16E78, 0x16E58],\n\t[0x16E79, 0x16E59],\n\t[0x16E7A, 0x16E5A],\n\t[0x16E7B, 0x16E5B],\n\t[0x16E7C, 0x16E5C],\n\t[0x16E7D, 0x16E5D],\n\t[0x16E7E, 0x16E5E],\n\t[0x16E7F, 0x16E5F],\n\t[0x1E900, 0x1E922],\n\t[0x1E901, 0x1E923],\n\t[0x1E902, 0x1E924],\n\t[0x1E903, 0x1E925],\n\t[0x1E904, 0x1E926],\n\t[0x1E905, 0x1E927],\n\t[0x1E906, 0x1E928],\n\t[0x1E907, 0x1E929],\n\t[0x1E908, 0x1E92A],\n\t[0x1E909, 0x1E92B],\n\t[0x1E90A, 0x1E92C],\n\t[0x1E90B, 0x1E92D],\n\t[0x1E90C, 0x1E92E],\n\t[0x1E90D, 0x1E92F],\n\t[0x1E90E, 0x1E930],\n\t[0x1E90F, 0x1E931],\n\t[0x1E910, 0x1E932],\n\t[0x1E911, 0x1E933],\n\t[0x1E912, 0x1E934],\n\t[0x1E913, 0x1E935],\n\t[0x1E914, 0x1E936],\n\t[0x1E915, 0x1E937],\n\t[0x1E916, 0x1E938],\n\t[0x1E917, 0x1E939],\n\t[0x1E918, 0x1E93A],\n\t[0x1E919, 0x1E93B],\n\t[0x1E91A, 0x1E93C],\n\t[0x1E91B, 0x1E93D],\n\t[0x1E91C, 0x1E93E],\n\t[0x1E91D, 0x1E93F],\n\t[0x1E91E, 0x1E940],\n\t[0x1E91F, 0x1E941],\n\t[0x1E920, 0x1E942],\n\t[0x1E921, 0x1E943],\n\t[0x1E922, 0x1E900],\n\t[0x1E923, 0x1E901],\n\t[0x1E924, 0x1E902],\n\t[0x1E925, 0x1E903],\n\t[0x1E926, 0x1E904],\n\t[0x1E927, 0x1E905],\n\t[0x1E928, 0x1E906],\n\t[0x1E929, 0x1E907],\n\t[0x1E92A, 0x1E908],\n\t[0x1E92B, 0x1E909],\n\t[0x1E92C, 0x1E90A],\n\t[0x1E92D, 0x1E90B],\n\t[0x1E92E, 0x1E90C],\n\t[0x1E92F, 0x1E90D],\n\t[0x1E930, 0x1E90E],\n\t[0x1E931, 0x1E90F],\n\t[0x1E932, 0x1E910],\n\t[0x1E933, 0x1E911],\n\t[0x1E934, 0x1E912],\n\t[0x1E935, 0x1E913],\n\t[0x1E936, 0x1E914],\n\t[0x1E937, 0x1E915],\n\t[0x1E938, 0x1E916],\n\t[0x1E939, 0x1E917],\n\t[0x1E93A, 0x1E918],\n\t[0x1E93B, 0x1E919],\n\t[0x1E93C, 0x1E91A],\n\t[0x1E93D, 0x1E91B],\n\t[0x1E93E, 0x1E91C],\n\t[0x1E93F, 0x1E91D],\n\t[0x1E940, 0x1E91E],\n\t[0x1E941, 0x1E91F],\n\t[0x1E942, 0x1E920],\n\t[0x1E943, 0x1E921]\n]);\n","// Generated using `npm run build`. Do not edit.\n\n\nconst regenerate = require('regenerate');\n\nexports.REGULAR = new Map([\n\t['d', regenerate()\n\t\t.addRange(0x30, 0x39)],\n\t['D', regenerate()\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0xFFFF)],\n\t['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)\n\t\t.addRange(0x9, 0xD)\n\t\t.addRange(0x2000, 0x200A)\n\t\t.addRange(0x2028, 0x2029)],\n\t['S', regenerate()\n\t\t.addRange(0x0, 0x8)\n\t\t.addRange(0xE, 0x1F)\n\t\t.addRange(0x21, 0x9F)\n\t\t.addRange(0xA1, 0x167F)\n\t\t.addRange(0x1681, 0x1FFF)\n\t\t.addRange(0x200B, 0x2027)\n\t\t.addRange(0x202A, 0x202E)\n\t\t.addRange(0x2030, 0x205E)\n\t\t.addRange(0x2060, 0x2FFF)\n\t\t.addRange(0x3001, 0xFEFE)\n\t\t.addRange(0xFF00, 0xFFFF)],\n\t['w', regenerate(0x5F)\n\t\t.addRange(0x30, 0x39)\n\t\t.addRange(0x41, 0x5A)\n\t\t.addRange(0x61, 0x7A)],\n\t['W', regenerate(0x60)\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0x40)\n\t\t.addRange(0x5B, 0x5E)\n\t\t.addRange(0x7B, 0xFFFF)]\n]);\n\nexports.UNICODE = new Map([\n\t['d', regenerate()\n\t\t.addRange(0x30, 0x39)],\n\t['D', regenerate()\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0x10FFFF)],\n\t['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)\n\t\t.addRange(0x9, 0xD)\n\t\t.addRange(0x2000, 0x200A)\n\t\t.addRange(0x2028, 0x2029)],\n\t['S', regenerate()\n\t\t.addRange(0x0, 0x8)\n\t\t.addRange(0xE, 0x1F)\n\t\t.addRange(0x21, 0x9F)\n\t\t.addRange(0xA1, 0x167F)\n\t\t.addRange(0x1681, 0x1FFF)\n\t\t.addRange(0x200B, 0x2027)\n\t\t.addRange(0x202A, 0x202E)\n\t\t.addRange(0x2030, 0x205E)\n\t\t.addRange(0x2060, 0x2FFF)\n\t\t.addRange(0x3001, 0xFEFE)\n\t\t.addRange(0xFF00, 0x10FFFF)],\n\t['w', regenerate(0x5F)\n\t\t.addRange(0x30, 0x39)\n\t\t.addRange(0x41, 0x5A)\n\t\t.addRange(0x61, 0x7A)],\n\t['W', regenerate(0x60)\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0x40)\n\t\t.addRange(0x5B, 0x5E)\n\t\t.addRange(0x7B, 0x10FFFF)]\n]);\n\nexports.UNICODE_IGNORE_CASE = new Map([\n\t['d', regenerate()\n\t\t.addRange(0x30, 0x39)],\n\t['D', regenerate()\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0x10FFFF)],\n\t['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF)\n\t\t.addRange(0x9, 0xD)\n\t\t.addRange(0x2000, 0x200A)\n\t\t.addRange(0x2028, 0x2029)],\n\t['S', regenerate()\n\t\t.addRange(0x0, 0x8)\n\t\t.addRange(0xE, 0x1F)\n\t\t.addRange(0x21, 0x9F)\n\t\t.addRange(0xA1, 0x167F)\n\t\t.addRange(0x1681, 0x1FFF)\n\t\t.addRange(0x200B, 0x2027)\n\t\t.addRange(0x202A, 0x202E)\n\t\t.addRange(0x2030, 0x205E)\n\t\t.addRange(0x2060, 0x2FFF)\n\t\t.addRange(0x3001, 0xFEFE)\n\t\t.addRange(0xFF00, 0x10FFFF)],\n\t['w', regenerate(0x5F, 0x17F, 0x212A)\n\t\t.addRange(0x30, 0x39)\n\t\t.addRange(0x41, 0x5A)\n\t\t.addRange(0x61, 0x7A)],\n\t['W', regenerate(0x60)\n\t\t.addRange(0x0, 0x2F)\n\t\t.addRange(0x3A, 0x40)\n\t\t.addRange(0x5B, 0x5E)\n\t\t.addRange(0x7B, 0x17E)\n\t\t.addRange(0x180, 0x2129)\n\t\t.addRange(0x212B, 0x10FFFF)]\n]);\n"]}