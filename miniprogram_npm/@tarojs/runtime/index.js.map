{"version":3,"sources":["runtime.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('@tarojs/shared');var noop = __TEMP__['noop'];var isFunction = __TEMP__['isFunction'];var getComponentsAlias$1 = __TEMP__['getComponentsAlias'];var internalComponents = __TEMP__['internalComponents'];var EMPTY_OBJ = __TEMP__['EMPTY_OBJ'];var hooks = __TEMP__['hooks'];var toCamelCase = __TEMP__['toCamelCase'];var isObject = __TEMP__['isObject'];var warn = __TEMP__['warn'];var isArray = __TEMP__['isArray'];var ensure = __TEMP__['ensure'];var isNull = __TEMP__['isNull'];var isUndefined = __TEMP__['isUndefined'];var toDashed = __TEMP__['toDashed'];var isString = __TEMP__['isString'];var controlledComponent = __TEMP__['controlledComponent'];var Events = __TEMP__['Events'];var isNumber = __TEMP__['isNumber'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('@tarojs/shared');Object.defineProperty(exports, 'Events', { enumerable: true, configurable: true, get: function() { return __TEMP__.Events; } });Object.defineProperty(exports, 'hooks', { enumerable: true, configurable: true, get: function() { return __TEMP__.hooks; } });\n\nconst PROPERTY_THRESHOLD = 2046;\nconst SET_DATA = '小程序 setData';\nconst PAGE_INIT = '页面初始化';\nconst ROOT_STR = 'root';\nconst HTML = 'html';\nconst HEAD = 'head';\nconst BODY = 'body';\nconst APP = 'app';\nconst CONTAINER = 'container';\nconst DOCUMENT_ELEMENT_NAME = '#document';\nconst DOCUMENT_FRAGMENT = 'document-fragment';\nconst ID = 'id';\nconst UID = 'uid';\nconst CLASS = 'class';\nconst STYLE = 'style';\nconst FOCUS = 'focus';\nconst VIEW = 'view';\nconst STATIC_VIEW = 'static-view';\nconst PURE_VIEW = 'pure-view';\nconst PROPS = 'props';\nconst DATASET = 'dataset';\nconst OBJECT = 'object';\nconst VALUE = 'value';\nconst INPUT = 'input';\nconst CHANGE = 'change';\nconst CUSTOM_WRAPPER = 'custom-wrapper';\nconst TARGET = 'target';\nconst CURRENT_TARGET = 'currentTarget';\nconst TYPE = 'type';\nconst CONFIRM = 'confirm';\nconst TIME_STAMP = 'timeStamp';\nconst KEY_CODE = 'keyCode';\nconst TOUCHMOVE = 'touchmove';\nconst CATCHMOVE = 'catchMove';\nconst CATCH_VIEW = 'catch-view';\nconst COMMENT = 'comment';\nconst ON_LOAD = 'onLoad';\nconst ON_READY = 'onReady';\nconst ON_SHOW = 'onShow';\nconst ON_HIDE = 'onHide';\nconst OPTIONS = 'options';\nconst EXTERNAL_CLASSES = 'externalClasses';\nconst EVENT_CALLBACK_RESULT = 'e_result';\nconst BEHAVIORS = 'behaviors';\nconst A = 'a';\n/**\n * 页面上下文切换时的行为\n */\nvar CONTEXT_ACTIONS;\n(function (CONTEXT_ACTIONS) {\n    CONTEXT_ACTIONS[\"INIT\"] = \"0\";\n    CONTEXT_ACTIONS[\"RESTORE\"] = \"1\";\n    CONTEXT_ACTIONS[\"RECOVER\"] = \"2\";\n    CONTEXT_ACTIONS[\"DESTORY\"] = \"3\";\n})(CONTEXT_ACTIONS || (CONTEXT_ACTIONS = {}));\n\nconst observers = [];\n/**\n * The MutationObserver provides the ability\n * to watch for changes being made to the DOM tree.\n * It will invoke a specified callback function\n * when DOM changes occur.\n * @see https://dom.spec.whatwg.org/#mutationobserver\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n */\nclass MutationObserverImpl {\n    constructor(callback) {\n        this.records = [];\n        this.callback = callback;\n    }\n    /**\n     * Configures the MutationObserver\n     * to begin receiving notifications\n     * through its callback function\n     * when DOM changes matching the given options occur.\n     *\n     * Options matching is to be implemented.\n     */\n    observe(target, options) {\n        this.disconnect();\n        this.target = target;\n        this.options = options || {};\n        observers.push(this);\n    }\n    /**\n     * Stop the MutationObserver instance\n     * from receiving further notifications\n     * until and unless observe() is called again.\n     */\n    disconnect() {\n        this.target = null;\n        const index = observers.indexOf(this);\n        if (index >= 0) {\n            observers.splice(index, 1);\n        }\n    }\n    /**\n     * Removes all pending notifications\n     * from the MutationObserver's notification queue\n     * and returns them in a new Array of MutationRecord objects.\n     */\n    takeRecords() {\n        return this.records.splice(0, this.records.length);\n    }\n}\n/** Match two TaroNodes by sid. */\nconst sidMatches = (observerTarget, target) => {\n    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);\n};\nconst isConcerned = (record, options) => {\n    const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options;\n    switch (record.type) {\n        case \"characterData\" /* MutationRecordType.CHARACTER_DATA */:\n            if (characterData) {\n                if (!characterDataOldValue)\n                    record.oldValue = null;\n                return true;\n            }\n            return false;\n        case \"attributes\" /* MutationRecordType.ATTRIBUTES */:\n            if (attributes) {\n                if (!attributeOldValue)\n                    record.oldValue = null;\n                return true;\n            }\n            return false;\n        case \"childList\" /* MutationRecordType.CHILD_LIST */:\n            if (childList) {\n                return true;\n            }\n            return false;\n    }\n};\nlet pendingMuatations = false;\nfunction logMutation(observer, record) {\n    observer.records.push(record);\n    if (!pendingMuatations) {\n        pendingMuatations = true;\n        Promise\n            .resolve()\n            .then(() => {\n            pendingMuatations = false;\n            observers.forEach(observer => {\n                return observer.callback(observer.takeRecords());\n            });\n        });\n    }\n}\nfunction recordMutation(record) {\n    observers.forEach(observer => {\n        const { options } = observer;\n        for (let t = record.target; t; t = t.parentNode) {\n            if (sidMatches(observer.target, t) && isConcerned(record, options)) {\n                logMutation(observer, record);\n                break;\n            }\n            if (!options.subtree)\n                break;\n        }\n    });\n}\n\nclass MutationObserver {\n    constructor(callback) {\n        if (ENABLE_MUTATION_OBSERVER) {\n            this.core = new MutationObserverImpl(callback);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                console.warn('[Taro Warning] 若要使用 MutationObserver，请在 Taro 编译配置中设置 \\'mini.enableMutationObserver: true\\'');\n            }\n            this.core = {\n                observe: noop,\n                disconnect: noop,\n                takeRecords: noop\n            };\n        }\n    }\n    observe(...args) {\n        this.core.observe(...args);\n    }\n    disconnect() {\n        this.core.disconnect();\n    }\n    takeRecords() {\n        return this.core.takeRecords();\n    }\n    static record(record) {\n        recordMutation(record);\n    }\n}\n\nconst incrementId = () => {\n    const chatCodes = [];\n    // A-Z\n    for (let i = 65; i <= 90; i++) {\n        chatCodes.push(i);\n    }\n    // a-z\n    for (let i = 97; i <= 122; i++) {\n        chatCodes.push(i);\n    }\n    const chatCodesLen = chatCodes.length - 1;\n    const list = [0, 0];\n    return () => {\n        const target = list.map(item => chatCodes[item]);\n        const res = String.fromCharCode(...target);\n        let tailIdx = list.length - 1;\n        list[tailIdx]++;\n        while (list[tailIdx] > chatCodesLen) {\n            list[tailIdx] = 0;\n            tailIdx = tailIdx - 1;\n            if (tailIdx < 0) {\n                list.push(0);\n                break;\n            }\n            list[tailIdx]++;\n        }\n        return res;\n    };\n};\nfunction isElement(node) {\n    return node.nodeType === 1 /* NodeType.ELEMENT_NODE */;\n}\nfunction isText(node) {\n    return node.nodeType === 3 /* NodeType.TEXT_NODE */;\n}\nfunction isComment(node) {\n    return node.nodeName === COMMENT;\n}\nfunction isHasExtractProp(el) {\n    const res = Object.keys(el.props).find(prop => {\n        return !(/^(class|style|id)$/.test(prop) || prop.startsWith('data-'));\n    });\n    return Boolean(res);\n}\n/**\n * 往上寻找组件树直到 root，寻找是否有祖先组件绑定了同类型的事件\n * @param node 当前组件\n * @param type 事件类型\n */\nfunction isParentBinded(node, type) {\n    var _a;\n    let res = false;\n    while ((node === null || node === void 0 ? void 0 : node.parentElement) && node.parentElement._path !== ROOT_STR) {\n        if ((_a = node.parentElement.__handlers[type]) === null || _a === void 0 ? void 0 : _a.length) {\n            res = true;\n            break;\n        }\n        node = node.parentElement;\n    }\n    return res;\n}\nfunction shortcutAttr(key) {\n    switch (key) {\n        case STYLE:\n            return \"st\" /* Shortcuts.Style */;\n        case ID:\n            return UID;\n        case CLASS:\n            return \"cl\" /* Shortcuts.Class */;\n        default:\n            return key;\n    }\n}\nconst customWrapperCache = new Map();\nfunction extend(ctor, methodName, options) {\n    if (isFunction(options)) {\n        options = {\n            value: options\n        };\n    }\n    Object.defineProperty(ctor.prototype, methodName, Object.assign({ configurable: true, enumerable: true }, options));\n}\nlet componentsAlias$1;\nfunction getComponentsAlias() {\n    if (!componentsAlias$1) {\n        componentsAlias$1 = getComponentsAlias$1(internalComponents);\n    }\n    return componentsAlias$1;\n}\n\nclass ClassList extends Set {\n    constructor(className, el) {\n        super();\n        className.trim().split(/\\s+/).forEach(super.add.bind(this));\n        this.el = el;\n    }\n    get value() {\n        return [...this].filter(v => v !== '').join(' ');\n    }\n    add(s) {\n        super.add(s);\n        this._update();\n        return this;\n    }\n    get length() {\n        return this.size;\n    }\n    remove(s) {\n        super.delete(s);\n        this._update();\n    }\n    toggle(s) {\n        if (super.has(s)) {\n            super.delete(s);\n        }\n        else {\n            super.add(s);\n        }\n        this._update();\n    }\n    replace(s1, s2) {\n        super.delete(s1);\n        super.add(s2);\n        this._update();\n    }\n    contains(s) {\n        return super.has(s);\n    }\n    toString() {\n        return this.value;\n    }\n    _update() {\n        this.el.className = this.value;\n    }\n}\n\nclass EventSource extends Map {\n    removeNode(child) {\n        const { sid, uid } = child;\n        this.delete(sid);\n        if (uid !== sid && uid)\n            this.delete(uid);\n    }\n    removeNodeTree(child) {\n        this.removeNode(child);\n        const { childNodes } = child;\n        childNodes.forEach(node => this.removeNodeTree(node));\n    }\n}\nconst eventSource = new EventSource();\n\nconst env = {\n    window: process.env.TARO_ENV === 'h5' ? window : EMPTY_OBJ,\n    document: process.env.TARO_ENV === 'h5' ? document : EMPTY_OBJ\n};\n\nlet SPECIAL_NODES;\nlet componentsAlias;\n/**\n * React also has a fancy function's name for this: `hydrate()`.\n * You may have been heard `hydrate` as a SSR-related function,\n * actually, `hydrate` basicly do the `render()` thing, but ignore some properties,\n * it's a vnode traverser and modifier: that's exactly what Taro's doing in here.\n */\nfunction hydrate(node) {\n    if (!componentsAlias) {\n        // 初始化 componentsAlias\n        componentsAlias = getComponentsAlias();\n    }\n    if (!SPECIAL_NODES) {\n        // 初始化 SPECIAL_NODES\n        SPECIAL_NODES = hooks.call('getSpecialNodes');\n    }\n    const nodeName = node.nodeName;\n    if (isText(node)) {\n        return {\n            [\"v\" /* Shortcuts.Text */]: node.nodeValue,\n            [\"nn\" /* Shortcuts.NodeName */]: componentsAlias[nodeName]._num\n        };\n    }\n    const data = {\n        [\"nn\" /* Shortcuts.NodeName */]: nodeName,\n        sid: node.sid\n    };\n    if (node.uid !== node.sid) {\n        data.uid = node.uid;\n    }\n    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {\n        data[\"nn\" /* Shortcuts.NodeName */] = `static-${nodeName}`;\n        if (nodeName === VIEW && !isHasExtractProp(node)) {\n            data[\"nn\" /* Shortcuts.NodeName */] = PURE_VIEW;\n        }\n    }\n    const { props } = node;\n    for (const prop in props) {\n        const propInCamelCase = toCamelCase(prop);\n        if (!prop.startsWith('data-') && // 在 node.dataset 的数据\n            prop !== CLASS &&\n            prop !== STYLE &&\n            prop !== ID &&\n            propInCamelCase !== CATCHMOVE) {\n            data[propInCamelCase] = props[prop];\n        }\n        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {\n            data[\"nn\" /* Shortcuts.NodeName */] = CATCH_VIEW;\n        }\n    }\n    let { childNodes } = node;\n    // 过滤 comment 节点\n    childNodes = childNodes.filter(node => !isComment(node));\n    if (childNodes.length > 0) {\n        data[\"cn\" /* Shortcuts.Childnodes */] = childNodes.map(hydrate);\n    }\n    else {\n        data[\"cn\" /* Shortcuts.Childnodes */] = [];\n    }\n    if (node.className !== '') {\n        data[\"cl\" /* Shortcuts.Class */] = node.className;\n    }\n    const cssText = node.cssText;\n    if (cssText !== '' && nodeName !== 'swiper-item') {\n        data[\"st\" /* Shortcuts.Style */] = cssText;\n    }\n    hooks.call('modifyHydrateData', data);\n    const nn = data[\"nn\" /* Shortcuts.NodeName */];\n    const componentAlias = componentsAlias[nn];\n    if (componentAlias) {\n        data[\"nn\" /* Shortcuts.NodeName */] = componentAlias._num;\n        for (const prop in data) {\n            if (prop in componentAlias) {\n                data[componentAlias[prop]] = data[prop];\n                delete data[prop];\n            }\n        }\n    }\n    return data;\n}\n\nclass TaroEventTarget {\n    constructor() {\n        this.__handlers = {};\n    }\n    addEventListener(type, handler, options) {\n        type = type.toLowerCase();\n        hooks.call('onAddEvent', type, handler, options, this);\n        if (type === 'regionchange') {\n            // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766\n            this.addEventListener('begin', handler, options);\n            this.addEventListener('end', handler, options);\n            return;\n        }\n        let isCapture = Boolean(options);\n        let isOnce = false;\n        if (isObject(options)) {\n            isCapture = Boolean(options.capture);\n            isOnce = Boolean(options.once);\n        }\n        if (isOnce) {\n            const wrapper = function () {\n                handler.apply(this, arguments); // this 指向 Element\n                this.removeEventListener(type, wrapper);\n            };\n            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options), { once: false }));\n            return;\n        }\n        process.env.NODE_ENV !== 'production' && warn(isCapture, 'Taro 暂未实现 event 的 capture 特性。');\n        // 某些框架，如 PReact 有委托的机制，handler 始终是同一个函数\n        // 这会导致多层停止冒泡失败：view -> view(handler.stop = false) -> view(handler.stop = true)\n        // 这样解决：view -> view(handlerA.stop = false) -> view(handlerB.stop = false)\n        // 因此每次绑定事件都新建一个函数，如果带来了性能问题，可以把这段逻辑抽取到 PReact 插件中。\n        const oldHandler = handler;\n        handler = function () {\n            return oldHandler.apply(this, arguments); // this 指向 Element\n        };\n        handler.oldHandler = oldHandler;\n        const handlers = this.__handlers[type];\n        if (isArray(handlers)) {\n            handlers.push(handler);\n        }\n        else {\n            this.__handlers[type] = [handler];\n        }\n    }\n    removeEventListener(type, handler) {\n        type = type.toLowerCase();\n        if (type === 'regionchange') {\n            // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766\n            this.removeEventListener('begin', handler);\n            this.removeEventListener('end', handler);\n            return;\n        }\n        if (!handler) {\n            return;\n        }\n        const handlers = this.__handlers[type];\n        if (!isArray(handlers)) {\n            return;\n        }\n        const index = handlers.findIndex(item => {\n            if (item === handler || item.oldHandler === handler)\n                return true;\n        });\n        process.env.NODE_ENV !== 'production' && warn(index === -1, `事件: '${type}' 没有注册在 DOM 中，因此不会被移除。`);\n        handlers.splice(index, 1);\n    }\n    isAnyEventBinded() {\n        const handlers = this.__handlers;\n        const isAnyEventBinded = Object.keys(handlers).find(key => handlers[key].length);\n        return Boolean(isAnyEventBinded);\n    }\n}\n\nconst CHILDNODES = \"cn\" /* Shortcuts.Childnodes */;\nconst nodeId = incrementId();\nclass TaroNode extends TaroEventTarget {\n    constructor() {\n        super();\n        this.parentNode = null;\n        this.childNodes = [];\n        this.hydrate = (node) => () => hydrate(node);\n        this.uid = '_' + nodeId(); // dom 节点 id，开发者可修改\n        this.sid = this.uid; // dom 节点全局唯一 id，不可被修改\n        eventSource.set(this.sid, this);\n    }\n    updateChildNodes(isClean) {\n        const cleanChildNodes = () => [];\n        const rerenderChildNodes = () => {\n            const childNodes = this.childNodes.filter(node => !isComment(node));\n            return childNodes.map(hydrate);\n        };\n        this.enqueueUpdate({\n            path: `${this._path}.${CHILDNODES}`,\n            value: isClean ? cleanChildNodes : rerenderChildNodes\n        });\n    }\n    get _root() {\n        var _a;\n        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a._root) || null;\n    }\n    findIndex(refChild) {\n        const index = this.childNodes.indexOf(refChild);\n        ensure(index !== -1, 'The node to be replaced is not a child of this node.');\n        return index;\n    }\n    get _path() {\n        const parentNode = this.parentNode;\n        if (parentNode) {\n            // 计算路径时，先过滤掉 comment 节点\n            const list = parentNode.childNodes.filter(node => !isComment(node));\n            const indexOfNode = list.indexOf(this);\n            const index = hooks.call('getPathIndex', indexOfNode);\n            return `${parentNode._path}.${CHILDNODES}.${index}`;\n        }\n        return '';\n    }\n    get nextSibling() {\n        const parentNode = this.parentNode;\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;\n    }\n    get previousSibling() {\n        const parentNode = this.parentNode;\n        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;\n    }\n    get parentElement() {\n        const parentNode = this.parentNode;\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1 /* NodeType.ELEMENT_NODE */) {\n            return parentNode;\n        }\n        return null;\n    }\n    get firstChild() {\n        return this.childNodes[0] || null;\n    }\n    get lastChild() {\n        const childNodes = this.childNodes;\n        return childNodes[childNodes.length - 1] || null;\n    }\n    /**\n     * @textContent 目前只能置空子元素\n     * @TODO 等待完整 innerHTML 实现\n     */\n    // eslint-disable-next-line accessor-pairs\n    set textContent(text) {\n        const removedNodes = this.childNodes.slice();\n        const addedNodes = [];\n        // Handle old children' data structure & ref\n        while (this.firstChild) {\n            this.removeChild(this.firstChild, { doUpdate: false });\n        }\n        if (text === '') {\n            this.updateChildNodes(true);\n        }\n        else {\n            const newText = env.document.createTextNode(text);\n            addedNodes.push(newText);\n            this.appendChild(newText);\n            this.updateChildNodes();\n        }\n        // @Todo: appendChild 会多触发一次\n        MutationObserver.record({\n            type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n            target: this,\n            removedNodes,\n            addedNodes\n        });\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore\n     * @scenario\n     * [A,B,C]\n     *   1. insert D before C, D has no parent\n     *   2. insert D before C, D has the same parent of C\n     *   3. insert D before C, D has the different parent of C\n     */\n    insertBefore(newChild, refChild, isReplace) {\n        if (newChild.nodeName === DOCUMENT_FRAGMENT) {\n            newChild.childNodes.reduceRight((previousValue, currentValue) => {\n                this.insertBefore(currentValue, previousValue);\n                return currentValue;\n            }, refChild);\n            return newChild;\n        }\n        // Parent release newChild\n        //   - cleanRef: false (No need to clean eventSource, because newChild is about to be inserted)\n        //   - update: true (Need to update parent.childNodes, because parent.childNodes is reordered)\n        newChild.remove({ cleanRef: false });\n        // Data structure\n        newChild.parentNode = this;\n        if (refChild) {\n            // insertBefore & replaceChild\n            const index = this.findIndex(refChild);\n            this.childNodes.splice(index, 0, newChild);\n        }\n        else {\n            // appendChild\n            this.childNodes.push(newChild);\n        }\n        // Serialization\n        if (this._root) {\n            if (!refChild) {\n                // appendChild\n                const isOnlyChild = this.childNodes.length === 1;\n                if (isOnlyChild) {\n                    this.updateChildNodes();\n                }\n                else {\n                    this.enqueueUpdate({\n                        path: newChild._path,\n                        value: this.hydrate(newChild)\n                    });\n                }\n            }\n            else if (isReplace) {\n                // replaceChild\n                this.enqueueUpdate({\n                    path: newChild._path,\n                    value: this.hydrate(newChild)\n                });\n            }\n            else {\n                // insertBefore\n                this.updateChildNodes();\n            }\n        }\n        MutationObserver.record({\n            type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n            target: this,\n            addedNodes: [newChild],\n            removedNodes: isReplace\n                ? [refChild] /** replaceChild */\n                : [],\n            nextSibling: isReplace\n                ? refChild.nextSibling /** replaceChild */\n                : (refChild || null),\n            previousSibling: newChild.previousSibling\n        });\n        return newChild;\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild\n     * @scenario\n     * [A,B,C]\n     *   1. append C, C has no parent\n     *   2. append C, C has the same parent of B\n     *   3. append C, C has the different parent of B\n     */\n    appendChild(newChild) {\n        return this.insertBefore(newChild);\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild\n     * @scenario\n     * [A,B,C]\n     *   1. replace B with C, C has no parent\n     *   2. replace B with C, C has no parent, C has the same parent of B\n     *   3. replace B with C, C has no parent, C has the different parent of B\n     */\n    replaceChild(newChild, oldChild) {\n        if (oldChild.parentNode !== this)\n            return;\n        // Insert the newChild\n        this.insertBefore(newChild, oldChild, true);\n        // Destroy the oldChild\n        //   - cleanRef: true (Need to clean eventSource, because the oldChild was detached from the DOM tree)\n        //   - update: false (No need to update parent.childNodes, because replace will not cause the parent.childNodes being reordered)\n        oldChild.remove({ doUpdate: false });\n        return oldChild;\n    }\n    /**\n     * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild\n     * @scenario\n     * [A,B,C]\n     *   1. remove A or B\n     *   2. remove C\n     */\n    removeChild(child, options = {}) {\n        const { cleanRef, doUpdate } = options;\n        if (cleanRef !== false && doUpdate !== false) {\n            // appendChild/replaceChild/insertBefore 不应该触发\n            // @Todo: 但其实如果 newChild 的父节点是另一颗子树的节点，应该是要触发的\n            MutationObserver.record({\n                type: \"childList\" /* MutationRecordType.CHILD_LIST */,\n                target: this,\n                removedNodes: [child],\n                nextSibling: child.nextSibling,\n                previousSibling: child.previousSibling\n            });\n        }\n        // Data Structure\n        const index = this.findIndex(child);\n        this.childNodes.splice(index, 1);\n        child.parentNode = null;\n        // Set eventSource\n        if (cleanRef !== false) {\n            eventSource.removeNodeTree(child);\n        }\n        // Serialization\n        if (this._root && doUpdate !== false) {\n            this.updateChildNodes();\n        }\n        return child;\n    }\n    remove(options) {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this, options);\n    }\n    hasChildNodes() {\n        return this.childNodes.length > 0;\n    }\n    enqueueUpdate(payload) {\n        var _a;\n        (_a = this._root) === null || _a === void 0 ? void 0 : _a.enqueueUpdate(payload);\n    }\n    get ownerDocument() {\n        return env.document;\n    }\n    static extend(methodName, options) {\n        extend(TaroNode, methodName, options);\n    }\n}\n\n/*\n *\n * https://www.w3.org/Style/CSS/all-properties.en.html\n */\nconst WEBKIT = 'webkit';\nconst styleProperties = [\n    'all',\n    'appearance',\n    'blockOverflow',\n    'blockSize',\n    'bottom',\n    'clear',\n    'contain',\n    'content',\n    'continue',\n    'cursor',\n    'direction',\n    'display',\n    'filter',\n    'float',\n    'gap',\n    'height',\n    'inset',\n    'isolation',\n    'left',\n    'letterSpacing',\n    'lightingColor',\n    'markerSide',\n    'mixBlendMode',\n    'opacity',\n    'order',\n    'position',\n    'quotes',\n    'resize',\n    'right',\n    'rowGap',\n    'tabSize',\n    'tableLayout',\n    'top',\n    'userSelect',\n    'verticalAlign',\n    'visibility',\n    'voiceFamily',\n    'volume',\n    'whiteSpace',\n    'widows',\n    'width',\n    'zIndex',\n    'pointerEvents'\n    /** 非常用 style */\n    // 'azimuth',\n    // 'backfaceVisibility',\n    // 'baselineShift',\n    // 'captionSide',\n    // 'chains',\n    // 'dominantBaseline',\n    // 'elevation',\n    // 'emptyCells',\n    // 'forcedColorAdjust',\n    // 'glyphOrientationVertical',\n    // 'hangingPunctuation',\n    // 'hyphenateCharacter',\n    // 'hyphens',\n    // 'imageOrientation',\n    // 'imageResolution',\n    // 'orphans',\n    // 'playDuring',\n    // 'pointerEvents',\n    // 'regionFragment',\n    // 'richness',\n    // 'running',\n    // 'scrollBehavior',\n    // 'speechRate',\n    // 'stress',\n    // 'stringSet',\n    // 'unicodeBidi',\n    // 'willChange',\n    // 'writingMode',\n];\n// 减少文件体积\nfunction combine(prefix, list, excludeSelf) {\n    !excludeSelf && styleProperties.push(prefix);\n    list.forEach(item => {\n        styleProperties.push(prefix + item);\n        if (prefix === WEBKIT) {\n            styleProperties.push('Webkit' + item);\n        }\n    });\n}\nconst color = 'Color';\nconst style = 'Style';\nconst width = 'Width';\nconst image = 'Image';\nconst size = 'Size';\nconst color_style_width = [color, style, width];\nconst fitlength_fitwidth_image = ['FitLength', 'FitWidth', image];\nconst fitlength_fitwidth_image_radius = [...fitlength_fitwidth_image, 'Radius'];\nconst color_style_width_fitlength_fitwidth_image = [...color_style_width, ...fitlength_fitwidth_image];\nconst endRadius_startRadius = ['EndRadius', 'StartRadius'];\nconst bottom_left_right_top = ['Bottom', 'Left', 'Right', 'Top'];\nconst end_start = ['End', 'Start'];\nconst content_items_self = ['Content', 'Items', 'Self'];\nconst blockSize_height_inlineSize_width = ['BlockSize', 'Height', 'InlineSize', width];\nconst after_before = ['After', 'Before'];\ncombine('borderBlock', color_style_width);\ncombine('borderBlockEnd', color_style_width);\ncombine('borderBlockStart', color_style_width);\ncombine('outline', [...color_style_width, 'Offset']);\ncombine('border', [...color_style_width, 'Boundary', 'Break', 'Collapse', 'Radius', 'Spacing']);\ncombine('borderFit', ['Length', width]);\ncombine('borderInline', color_style_width);\ncombine('borderInlineEnd', color_style_width);\ncombine('borderInlineStart', color_style_width);\ncombine('borderLeft', color_style_width_fitlength_fitwidth_image);\ncombine('borderRight', color_style_width_fitlength_fitwidth_image);\ncombine('borderTop', color_style_width_fitlength_fitwidth_image);\ncombine('borderBottom', color_style_width_fitlength_fitwidth_image);\ncombine('textDecoration', [color, style, 'Line']);\ncombine('textEmphasis', [color, style, 'Position']);\ncombine('scrollMargin', bottom_left_right_top);\ncombine('scrollPadding', bottom_left_right_top);\ncombine('padding', bottom_left_right_top);\ncombine('margin', [...bottom_left_right_top, 'Trim']);\ncombine('scrollMarginBlock', end_start);\ncombine('scrollMarginInline', end_start);\ncombine('scrollPaddingBlock', end_start);\ncombine('scrollPaddingInline', end_start);\ncombine('gridColumn', end_start);\ncombine('gridRow', end_start);\ncombine('insetBlock', end_start);\ncombine('insetInline', end_start);\ncombine('marginBlock', end_start);\ncombine('marginInline', end_start);\ncombine('paddingBlock', end_start);\ncombine('paddingInline', end_start);\ncombine('pause', after_before);\ncombine('cue', after_before);\ncombine('mask', ['Clip', 'Composite', image, 'Mode', 'Origin', 'Position', 'Repeat', size, 'Type']);\ncombine('borderImage', ['Outset', 'Repeat', 'Slice', 'Source', 'Transform', width]);\ncombine('maskBorder', ['Mode', 'Outset', 'Repeat', 'Slice', 'Source', width]);\ncombine('font', ['Family', 'FeatureSettings', 'Kerning', 'LanguageOverride', 'MaxSize', 'MinSize', 'OpticalSizing', 'Palette', size, 'SizeAdjust', 'Stretch', style, 'Weight', 'VariationSettings']);\ncombine('transform', ['Box', 'Origin', style]);\ncombine('background', [color, image, 'Attachment', 'BlendMode', 'Clip', 'Origin', 'Position', 'Repeat', size]);\ncombine('listStyle', [image, 'Position', 'Type']);\ncombine('scrollSnap', ['Align', 'Stop', 'Type']);\ncombine('grid', ['Area', 'AutoColumns', 'AutoFlow', 'AutoRows']);\ncombine('gridTemplate', ['Areas', 'Columns', 'Rows']);\ncombine('overflow', ['Block', 'Inline', 'Wrap', 'X', 'Y']);\ncombine('transition', ['Delay', 'Duration', 'Property', 'TimingFunction']);\ncombine('color', ['Adjust', 'InterpolationFilters', 'Scheme']);\ncombine('textAlign', ['All', 'Last']);\ncombine('page', ['BreakAfter', 'BreakBefore', 'BreakInside']);\ncombine('animation', ['Delay', 'Direction', 'Duration', 'FillMode', 'IterationCount', 'Name', 'PlayState', 'TimingFunction']);\ncombine('flex', ['Basis', 'Direction', 'Flow', 'Grow', 'Shrink', 'Wrap']);\ncombine('offset', [...after_before, ...end_start, 'Anchor', 'Distance', 'Path', 'Position', 'Rotate']);\ncombine('perspective', ['Origin']);\ncombine('clip', ['Path', 'Rule']);\ncombine('flow', ['From', 'Into']);\ncombine('align', ['Content', 'Items', 'Self'], true);\ncombine('alignment', ['Adjust', 'Baseline'], true);\ncombine('borderStart', endRadius_startRadius, true);\ncombine('borderEnd', endRadius_startRadius, true);\ncombine('borderCorner', ['Fit', image, 'ImageTransform'], true);\ncombine('borderTopLeft', fitlength_fitwidth_image_radius, true);\ncombine('borderTopRight', fitlength_fitwidth_image_radius, true);\ncombine('borderBottomLeft', fitlength_fitwidth_image_radius, true);\ncombine('borderBottomRight', fitlength_fitwidth_image_radius, true);\ncombine('column', ['s', 'Count', 'Fill', 'Gap', 'Rule', 'RuleColor', 'RuleStyle', 'RuleWidth', 'Span', width], true);\ncombine('break', [...after_before, 'Inside'], true);\ncombine('wrap', [...after_before, 'Flow', 'Inside', 'Through'], true);\ncombine('justify', content_items_self, true);\ncombine('place', content_items_self, true);\ncombine('max', [...blockSize_height_inlineSize_width, 'Lines'], true);\ncombine('min', blockSize_height_inlineSize_width, true);\ncombine('line', ['Break', 'Clamp', 'Grid', 'Height', 'Padding', 'Snap'], true);\ncombine('inline', ['BoxAlign', size, 'Sizing'], true);\ncombine('text', ['CombineUpright', 'GroupAlign', 'Height', 'Indent', 'Justify', 'Orientation', 'Overflow', 'Shadow', 'SpaceCollapse', 'SpaceTrim', 'Spacing', 'Transform', 'UnderlinePosition', 'Wrap'], true);\ncombine('shape', ['ImageThreshold', 'Inside', 'Margin', 'Outside'], true);\ncombine('word', ['Break', 'Spacing', 'Wrap'], true);\ncombine('object', ['Fit', 'Position'], true);\ncombine('box', ['DecorationBreak', 'Shadow', 'Sizing', 'Snap'], true);\ncombine(WEBKIT, ['LineClamp', 'BoxOrient', 'TextFillColor', 'TextStroke', 'TextStrokeColor', 'TextStrokeWidth'], true);\n\nfunction recordCss(obj) {\n    MutationObserver.record({\n        type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n        target: obj._element,\n        attributeName: 'style',\n        oldValue: obj.cssText\n    });\n}\nfunction enqueueUpdate(obj) {\n    const element = obj._element;\n    if (element._root) {\n        element.enqueueUpdate({\n            path: `${element._path}.${\"st\" /* Shortcuts.Style */}`,\n            value: obj.cssText\n        });\n    }\n}\nfunction setStyle(newVal, styleKey) {\n    process.env.NODE_ENV !== 'production' && warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style 属性 ${styleKey} 的值数据量过大，可能会影响渲染性能，考虑使用 CSS 类或其它方案替代。`);\n    const old = this[styleKey];\n    if (old === newVal)\n        return;\n    !this._pending && recordCss(this);\n    if (isNull(newVal) || isUndefined(newVal)) {\n        this._usedStyleProp.delete(styleKey);\n        delete this._value[styleKey];\n    }\n    else {\n        this._usedStyleProp.add(styleKey);\n        this._value[styleKey] = newVal;\n    }\n    !this._pending && enqueueUpdate(this);\n}\nfunction initStyle(ctor) {\n    const properties = {};\n    for (let i = 0; i < styleProperties.length; i++) {\n        const styleKey = styleProperties[i];\n        properties[styleKey] = {\n            get() {\n                const val = this._value[styleKey];\n                return isNull(val) || isUndefined(val) ? '' : val;\n            },\n            set(newVal) {\n                setStyle.call(this, newVal, styleKey);\n            }\n        };\n    }\n    Object.defineProperties(ctor.prototype, properties);\n}\nfunction isCssVariable(propertyName) {\n    return /^--/.test(propertyName);\n}\nclass Style {\n    constructor(element) {\n        this._element = element;\n        this._usedStyleProp = new Set();\n        this._value = {};\n    }\n    setCssVariables(styleKey) {\n        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {\n            enumerable: true,\n            configurable: true,\n            get: () => {\n                return this._value[styleKey] || '';\n            },\n            set: (newVal) => {\n                setStyle.call(this, newVal, styleKey);\n            }\n        });\n    }\n    get cssText() {\n        if (!this._usedStyleProp.size)\n            return '';\n        const texts = [];\n        this._usedStyleProp.forEach(key => {\n            const val = this[key];\n            if (isNull(val) || isUndefined(val))\n                return;\n            let styleName = isCssVariable(key) ? key : toDashed(key);\n            if (styleName.indexOf('webkit') === 0 || styleName.indexOf('Webkit') === 0) {\n                styleName = `-${styleName}`;\n            }\n            texts.push(`${styleName}: ${val};`);\n        });\n        return texts.join(' ');\n    }\n    set cssText(str) {\n        this._pending = true;\n        recordCss(this);\n        this._usedStyleProp.forEach(prop => {\n            this.removeProperty(prop);\n        });\n        if (str === '' || isUndefined(str) || isNull(str)) {\n            this._pending = false;\n            enqueueUpdate(this);\n            return;\n        }\n        const rules = str.split(';');\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i].trim();\n            if (rule === '') {\n                continue;\n            }\n            // 可能存在 'background: url(http:x/y/z)' 的情况\n            const [propName, ...valList] = rule.split(':');\n            const val = valList.join(':');\n            if (isUndefined(val)) {\n                continue;\n            }\n            this.setProperty(propName.trim(), val.trim());\n        }\n        this._pending = false;\n        enqueueUpdate(this);\n    }\n    setProperty(propertyName, value) {\n        if (propertyName[0] === '-') {\n            // 支持 webkit 属性或 css 变量\n            this.setCssVariables(propertyName);\n        }\n        else {\n            propertyName = toCamelCase(propertyName);\n        }\n        if (isNull(value) || isUndefined(value)) {\n            this.removeProperty(propertyName);\n        }\n        else {\n            this[propertyName] = value;\n        }\n    }\n    removeProperty(propertyName) {\n        propertyName = toCamelCase(propertyName);\n        if (!this._usedStyleProp.has(propertyName)) {\n            return '';\n        }\n        const value = this[propertyName];\n        this[propertyName] = undefined;\n        return value;\n    }\n    getPropertyValue(propertyName) {\n        propertyName = toCamelCase(propertyName);\n        const value = this[propertyName];\n        if (!value) {\n            return '';\n        }\n        return value;\n    }\n}\ninitStyle(Style);\n\nfunction returnTrue() {\n    return true;\n}\nfunction treeToArray(root, predict) {\n    const array = [];\n    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;\n    let object = root;\n    while (object) {\n        if (object.nodeType === 1 /* NodeType.ELEMENT_NODE */ && filter(object)) {\n            array.push(object);\n        }\n        object = following(object, root);\n    }\n    return array;\n}\nfunction following(el, root) {\n    const firstChild = el.firstChild;\n    if (firstChild) {\n        return firstChild;\n    }\n    let current = el;\n    do {\n        if (current === root) {\n            return null;\n        }\n        const nextSibling = current.nextSibling;\n        if (nextSibling) {\n            return nextSibling;\n        }\n        current = current.parentElement;\n    } while (current);\n    return null;\n}\n\nclass TaroElement extends TaroNode {\n    constructor() {\n        super();\n        this.props = {};\n        this.dataset = EMPTY_OBJ;\n        this.nodeType = 1 /* NodeType.ELEMENT_NODE */;\n        this.style = new Style(this);\n        hooks.call('patchElement', this);\n    }\n    _stopPropagation(event) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let target = this;\n        // eslint-disable-next-line no-cond-assign\n        while ((target = target.parentNode)) {\n            const listeners = target.__handlers[event.type];\n            if (!isArray(listeners)) {\n                continue;\n            }\n            for (let i = listeners.length; i--;) {\n                const l = listeners[i];\n                l._stop = true;\n            }\n        }\n    }\n    get id() {\n        return this.getAttribute(ID);\n    }\n    set id(val) {\n        this.setAttribute(ID, val);\n    }\n    get className() {\n        return this.getAttribute(CLASS) || '';\n    }\n    set className(val) {\n        this.setAttribute(CLASS, val);\n    }\n    get cssText() {\n        return this.getAttribute(STYLE) || '';\n    }\n    get classList() {\n        return new ClassList(this.className, this);\n    }\n    get children() {\n        return this.childNodes.filter(isElement);\n    }\n    get attributes() {\n        const props = this.props;\n        const propKeys = Object.keys(props);\n        const style = this.style.cssText;\n        const attrs = propKeys.map(key => ({ name: key, value: props[key] }));\n        return attrs.concat(style ? { name: STYLE, value: style } : []);\n    }\n    get textContent() {\n        let text = '';\n        const childNodes = this.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            text += childNodes[i].textContent;\n        }\n        return text;\n    }\n    set textContent(text) {\n        super.textContent = text;\n    }\n    hasAttribute(qualifiedName) {\n        return !isUndefined(this.props[qualifiedName]);\n    }\n    hasAttributes() {\n        return this.attributes.length > 0;\n    }\n    get focus() {\n        return function () {\n            this.setAttribute(FOCUS, true);\n        };\n    }\n    // 兼容 Vue3，详情请见：https://github.com/NervJS/taro/issues/10579\n    set focus(value) {\n        this.setAttribute(FOCUS, value);\n    }\n    blur() {\n        this.setAttribute(FOCUS, false);\n    }\n    setAttribute(qualifiedName, value) {\n        process.env.NODE_ENV !== 'production' && warn(isString(value) && value.length > PROPERTY_THRESHOLD, `元素 ${this.nodeName} 的 ${qualifiedName} 属性值数据量过大，可能会影响渲染性能。考虑降低图片转为 base64 的阈值或在 CSS 中使用 base64。`);\n        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();\n        if (qualifiedName !== STYLE) {\n            MutationObserver.record({\n                target: this,\n                type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n                attributeName: qualifiedName,\n                oldValue: this.getAttribute(qualifiedName)\n            });\n        }\n        switch (qualifiedName) {\n            case STYLE:\n                this.style.cssText = value;\n                break;\n            case ID:\n                if (this.uid !== this.sid) {\n                    // eventSource[sid] 永远保留，直到组件卸载\n                    // eventSource[uid] 可变\n                    eventSource.delete(this.uid);\n                }\n                value = String(value);\n                this.props[qualifiedName] = this.uid = value;\n                eventSource.set(value, this);\n                break;\n            default:\n                this.props[qualifiedName] = value;\n                if (qualifiedName.startsWith('data-')) {\n                    if (this.dataset === EMPTY_OBJ) {\n                        this.dataset = Object.create(null);\n                    }\n                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ''))] = value;\n                }\n                break;\n        }\n        // Serialization\n        if (!this._root)\n            return;\n        const componentsAlias = getComponentsAlias();\n        const _alias = componentsAlias[this.nodeName];\n        const viewAlias = componentsAlias[VIEW]._num;\n        const staticViewAlias = componentsAlias[STATIC_VIEW]._num;\n        const catchViewAlias = componentsAlias[CATCH_VIEW]._num;\n        const _path = this._path;\n        qualifiedName = shortcutAttr(qualifiedName);\n        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);\n        const payload = {\n            path: `${_path}.${qualifiedNameInCamelCase}`,\n            value: isFunction(value) ? () => value : value\n        };\n        hooks.call('modifySetAttrPayload', this, qualifiedName, payload, componentsAlias);\n        if (_alias) {\n            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;\n            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;\n        }\n        this.enqueueUpdate(payload);\n        if (this.nodeName === VIEW) {\n            if (qualifiedNameInCamelCase === CATCHMOVE) {\n                // catchMove = true: catch-view\n                // catchMove = false: view or static-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: value ? catchViewAlias : (this.isAnyEventBinded() ? viewAlias : staticViewAlias)\n                });\n            }\n            else if (isPureView && isHasExtractProp(this)) {\n                // pure-view => static-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: staticViewAlias\n                });\n            }\n        }\n    }\n    removeAttribute(qualifiedName) {\n        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();\n        MutationObserver.record({\n            target: this,\n            type: \"attributes\" /* MutationRecordType.ATTRIBUTES */,\n            attributeName: qualifiedName,\n            oldValue: this.getAttribute(qualifiedName)\n        });\n        if (qualifiedName === STYLE) {\n            this.style.cssText = '';\n        }\n        else {\n            const isInterrupt = hooks.call('onRemoveAttribute', this, qualifiedName);\n            if (isInterrupt) {\n                return;\n            }\n            if (!this.props.hasOwnProperty(qualifiedName)) {\n                return;\n            }\n            delete this.props[qualifiedName];\n        }\n        // Serialization\n        if (!this._root)\n            return;\n        const componentsAlias = getComponentsAlias();\n        const _alias = componentsAlias[this.nodeName];\n        const viewAlias = componentsAlias[VIEW]._num;\n        const staticViewAlias = componentsAlias[STATIC_VIEW]._num;\n        const pureViewAlias = componentsAlias[PURE_VIEW]._num;\n        const _path = this._path;\n        qualifiedName = shortcutAttr(qualifiedName);\n        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);\n        const payload = {\n            path: `${_path}.${qualifiedNameInCamelCase}`,\n            value: ''\n        };\n        hooks.call('modifyRmAttrPayload', this, qualifiedName, payload, componentsAlias);\n        if (_alias) {\n            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;\n            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;\n        }\n        this.enqueueUpdate(payload);\n        if (this.nodeName === VIEW) {\n            if (qualifiedNameInCamelCase === CATCHMOVE) {\n                // catch-view => view or static-view or pure-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: this.isAnyEventBinded() ? viewAlias : (isHasExtractProp(this) ? staticViewAlias : pureViewAlias)\n                });\n            }\n            else if (isStaticView && !isHasExtractProp(this)) {\n                // static-view => pure-view\n                this.enqueueUpdate({\n                    path: `${_path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                    value: pureViewAlias\n                });\n            }\n        }\n    }\n    getAttribute(qualifiedName) {\n        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];\n        return attr !== null && attr !== void 0 ? attr : '';\n    }\n    getElementsByTagName(tagName) {\n        return treeToArray(this, (el) => {\n            return el.nodeName === tagName || (tagName === '*' && this !== el);\n        });\n    }\n    getElementsByClassName(className) {\n        return treeToArray(this, (el) => {\n            const classList = el.classList;\n            const classNames = className.trim().split(/\\s+/);\n            return classNames.every(c => classList.has(c));\n        });\n    }\n    dispatchEvent(event) {\n        const cancelable = event.cancelable;\n        const listeners = this.__handlers[event.type];\n        if (!isArray(listeners)) {\n            return false;\n        }\n        for (let i = listeners.length; i--;) {\n            const listener = listeners[i];\n            let result;\n            if (listener._stop) {\n                listener._stop = false;\n            }\n            else {\n                hooks.call('modifyDispatchEvent', event, this);\n                result = listener.call(this, event);\n            }\n            if ((result === false || event._end) && cancelable) {\n                event.defaultPrevented = true;\n            }\n            if (!isUndefined(result) && event.mpEvent) {\n                event.mpEvent[EVENT_CALLBACK_RESULT] = result;\n            }\n            if (event._end && event._stop) {\n                break;\n            }\n        }\n        if (event._stop) {\n            this._stopPropagation(event);\n        }\n        else {\n            event._stop = true;\n        }\n        return listeners != null;\n    }\n    addEventListener(type, handler, options) {\n        const name = this.nodeName;\n        const SPECIAL_NODES = hooks.call('getSpecialNodes');\n        let sideEffect = true;\n        if (isObject(options) && options.sideEffect === false) {\n            sideEffect = false;\n            delete options.sideEffect;\n        }\n        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\n            const componentsAlias = getComponentsAlias();\n            const alias = componentsAlias[name]._num;\n            this.enqueueUpdate({\n                path: `${this._path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                value: alias\n            });\n        }\n        super.addEventListener(type, handler, options);\n    }\n    removeEventListener(type, handler, sideEffect = true) {\n        super.removeEventListener(type, handler);\n        const name = this.nodeName;\n        const SPECIAL_NODES = hooks.call('getSpecialNodes');\n        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES.indexOf(name) > -1) {\n            const componentsAlias = getComponentsAlias();\n            const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;\n            const valueAlias = componentsAlias[value]._num;\n            this.enqueueUpdate({\n                path: `${this._path}.${\"nn\" /* Shortcuts.NodeName */}`,\n                value: valueAlias\n            });\n        }\n    }\n    static extend(methodName, options) {\n        extend(TaroElement, methodName, options);\n    }\n}\n\nconst options = {\n    prerender: true,\n    debug: false\n};\n\nfunction initPosition() {\n    return {\n        index: 0,\n        column: 0,\n        line: 0\n    };\n}\nfunction feedPosition(position, str, len) {\n    const start = position.index;\n    const end = position.index = start + len;\n    for (let i = start; i < end; i++) {\n        const char = str.charAt(i);\n        if (char === '\\n') {\n            position.line++;\n            position.column = 0;\n        }\n        else {\n            position.column++;\n        }\n    }\n}\nfunction jumpPosition(position, str, end) {\n    const len = end - position.index;\n    return feedPosition(position, str, len);\n}\nfunction copyPosition(position) {\n    return {\n        index: position.index,\n        line: position.line,\n        column: position.column\n    };\n}\nconst whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n    return whitespace.test(char);\n}\nconst equalSign = /=/;\nfunction isEqualSignChar(char) {\n    return equalSign.test(char);\n}\nfunction shouldBeIgnore(tagName) {\n    const name = tagName.toLowerCase();\n    if (options.html.skipElements.has(name)) {\n        return true;\n    }\n    return false;\n}\nconst alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n    while (true) {\n        const textEnd = str.indexOf('<', index);\n        if (textEnd === -1) {\n            return textEnd;\n        }\n        const char = str.charAt(textEnd + 1);\n        if (char === '/' || char === '!' || alphanumeric.test(char)) {\n            return textEnd;\n        }\n        index = textEnd + 1;\n    }\n}\nfunction isWordEnd(cursor, wordBegin, html) {\n    if (!isWhitespaceChar(html.charAt(cursor)))\n        return false;\n    const len = html.length;\n    // backwrad\n    for (let i = cursor - 1; i > wordBegin; i--) {\n        const char = html.charAt(i);\n        if (!isWhitespaceChar(char)) {\n            if (isEqualSignChar(char))\n                return false;\n            break;\n        }\n    }\n    // forward\n    for (let i = cursor + 1; i < len; i++) {\n        const char = html.charAt(i);\n        if (!isWhitespaceChar(char)) {\n            if (isEqualSignChar(char))\n                return false;\n            return true;\n        }\n    }\n}\nclass Scaner {\n    constructor(html) {\n        this.tokens = [];\n        this.position = initPosition();\n        this.html = html;\n    }\n    scan() {\n        const { html, position } = this;\n        const len = html.length;\n        while (position.index < len) {\n            const start = position.index;\n            this.scanText();\n            if (position.index === start) {\n                const isComment = html.startsWith('!--', start + 1);\n                if (isComment) {\n                    this.scanComment();\n                }\n                else {\n                    const tagName = this.scanTag();\n                    if (shouldBeIgnore(tagName)) {\n                        this.scanSkipTag(tagName);\n                    }\n                }\n            }\n        }\n        return this.tokens;\n    }\n    scanText() {\n        const type = 'text';\n        const { html, position } = this;\n        let textEnd = findTextEnd(html, position.index);\n        if (textEnd === position.index) {\n            return;\n        }\n        if (textEnd === -1) {\n            textEnd = html.length;\n        }\n        const start = copyPosition(position);\n        const content = html.slice(position.index, textEnd);\n        jumpPosition(position, html, textEnd);\n        const end = copyPosition(position);\n        this.tokens.push({ type, content, position: { start, end } });\n    }\n    scanComment() {\n        const type = 'comment';\n        const { html, position } = this;\n        const start = copyPosition(position);\n        feedPosition(position, html, 4); // \"<!--\".length\n        let contentEnd = html.indexOf('-->', position.index);\n        let commentEnd = contentEnd + 3; // \"-->\".length\n        if (contentEnd === -1) {\n            contentEnd = commentEnd = html.length;\n        }\n        const content = html.slice(position.index, contentEnd);\n        jumpPosition(position, html, commentEnd);\n        this.tokens.push({\n            type,\n            content,\n            position: {\n                start,\n                end: copyPosition(position)\n            }\n        });\n    }\n    scanTag() {\n        this.scanTagStart();\n        const tagName = this.scanTagName();\n        this.scanAttrs();\n        this.scanTagEnd();\n        return tagName;\n    }\n    scanTagStart() {\n        const type = 'tag-start';\n        const { html, position } = this;\n        const secondChar = html.charAt(position.index + 1);\n        const close = secondChar === '/';\n        const start = copyPosition(position);\n        feedPosition(position, html, close ? 2 : 1);\n        this.tokens.push({ type, close, position: { start } });\n    }\n    scanTagEnd() {\n        const type = 'tag-end';\n        const { html, position } = this;\n        const firstChar = html.charAt(position.index);\n        const close = firstChar === '/';\n        feedPosition(position, html, close ? 2 : 1);\n        const end = copyPosition(position);\n        this.tokens.push({ type, close, position: { end } });\n    }\n    scanTagName() {\n        const type = 'tag';\n        const { html, position } = this;\n        const len = html.length;\n        let start = position.index;\n        while (start < len) {\n            const char = html.charAt(start);\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n            if (isTagChar)\n                break;\n            start++;\n        }\n        let end = start + 1;\n        while (end < len) {\n            const char = html.charAt(end);\n            const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n            if (!isTagChar)\n                break;\n            end++;\n        }\n        jumpPosition(position, html, end);\n        const tagName = html.slice(start, end);\n        this.tokens.push({\n            type,\n            content: tagName\n        });\n        return tagName;\n    }\n    scanAttrs() {\n        const { html, position, tokens } = this;\n        let cursor = position.index;\n        let quote = null; // null, single-, or double-quote\n        let wordBegin = cursor; // index of word start\n        const words = []; // \"key\", \"key=value\", \"key='value'\", etc\n        const len = html.length;\n        while (cursor < len) {\n            const char = html.charAt(cursor);\n            if (quote) {\n                const isQuoteEnd = char === quote;\n                if (isQuoteEnd) {\n                    quote = null;\n                }\n                cursor++;\n                continue;\n            }\n            const isTagEnd = char === '/' || char === '>';\n            if (isTagEnd) {\n                if (cursor !== wordBegin) {\n                    words.push(html.slice(wordBegin, cursor));\n                }\n                break;\n            }\n            if (isWordEnd(cursor, wordBegin, html)) {\n                if (cursor !== wordBegin) {\n                    words.push(html.slice(wordBegin, cursor));\n                }\n                wordBegin = cursor + 1;\n                cursor++;\n                continue;\n            }\n            const isQuoteStart = char === '\\'' || char === '\"';\n            if (isQuoteStart) {\n                quote = char;\n                cursor++;\n                continue;\n            }\n            cursor++;\n        }\n        jumpPosition(position, html, cursor);\n        const wLen = words.length;\n        const type = 'attribute';\n        for (let i = 0; i < wLen; i++) {\n            const word = words[i];\n            const isNotPair = word.includes('=');\n            if (isNotPair) {\n                const secondWord = words[i + 1];\n                if (secondWord && secondWord.startsWith('=')) {\n                    if (secondWord.length > 1) {\n                        const newWord = word + secondWord;\n                        tokens.push({ type, content: newWord });\n                        i += 1;\n                        continue;\n                    }\n                    const thirdWord = words[i + 2];\n                    i += 1;\n                    if (thirdWord) {\n                        const newWord = word + '=' + thirdWord;\n                        tokens.push({ type, content: newWord });\n                        i += 1;\n                        continue;\n                    }\n                }\n            }\n            if (word.endsWith('=')) {\n                const secondWord = words[i + 1];\n                if (secondWord && !secondWord.includes('=')) {\n                    const newWord = word + secondWord;\n                    tokens.push({ type, content: newWord });\n                    i += 1;\n                    continue;\n                }\n                const newWord = word.slice(0, -1);\n                tokens.push({ type, content: newWord });\n                continue;\n            }\n            tokens.push({ type, content: word });\n        }\n    }\n    scanSkipTag(tagName) {\n        const { html, position } = this;\n        const safeTagName = tagName.toLowerCase();\n        const len = html.length;\n        while (position.index < len) {\n            const nextTag = html.indexOf('</', position.index);\n            if (nextTag === -1) {\n                this.scanText();\n                break;\n            }\n            jumpPosition(position, html, nextTag);\n            const name = this.scanTag();\n            if (safeTagName === name.toLowerCase()) {\n                break;\n            }\n        }\n    }\n}\n\nfunction unquote(str) {\n    const car = str.charAt(0);\n    const end = str.length - 1;\n    const isQuoteStart = car === '\"' || car === \"'\";\n    if (isQuoteStart && car === str.charAt(end)) {\n        return str.slice(1, end);\n    }\n    return str;\n}\n\nconst LEFT_BRACKET = '{';\nconst RIGHT_BRACKET = '}';\nconst CLASS_SELECTOR = '.';\nconst ID_SELECTOR = '#';\nconst CHILD_COMBINATOR = '>';\nconst GENERAL_SIBLING_COMBINATOR = '~';\nconst ADJACENT_SIBLING_COMBINATOR = '+';\nclass StyleTagParser {\n    constructor() {\n        this.styles = [];\n    }\n    extractStyle(src) {\n        const REG_STYLE = /<style\\s?[^>]*>((.|\\n|\\s)+?)<\\/style>/g;\n        let html = src;\n        // let html = src.replace(/\\n/g, '')\n        html = html.replace(REG_STYLE, (_, $1) => {\n            const style = $1.trim();\n            this.stringToSelector(style);\n            return '';\n        });\n        return html.trim();\n    }\n    stringToSelector(style) {\n        let lb = style.indexOf(LEFT_BRACKET);\n        while (lb > -1) {\n            const rb = style.indexOf(RIGHT_BRACKET);\n            const selectors = style.slice(0, lb).trim();\n            let content = style.slice(lb + 1, rb);\n            content = content.replace(/:(.*);/g, function (_, $1) {\n                const t = $1.trim().replace(/ +/g, '+++');\n                return `:${t};`;\n            });\n            content = content.replace(/ /g, '');\n            content = content.replace(/\\+\\+\\+/g, ' ');\n            if (!(/;$/.test(content))) {\n                content += ';';\n            }\n            selectors.split(',').forEach(src => {\n                const selectorList = this.parseSelector(src);\n                this.styles.push({\n                    content,\n                    selectorList\n                });\n            });\n            style = style.slice(rb + 1);\n            lb = style.indexOf(LEFT_BRACKET);\n        }\n        // console.log('res this.styles: ', this.styles)\n    }\n    parseSelector(src) {\n        const list = src\n            .trim()\n            .replace(/ *([>~+]) */g, ' $1')\n            .replace(/ +/g, ' ')\n            .replace(/\\[\\s*([^[\\]=\\s]+)\\s*=\\s*([^[\\]=\\s]+)\\s*\\]/g, '[$1=$2]')\n            .split(' ');\n        const selectors = list.map(item => {\n            const firstChar = item.charAt(0);\n            const selector = {\n                isChild: firstChar === CHILD_COMBINATOR,\n                isGeneralSibling: firstChar === GENERAL_SIBLING_COMBINATOR,\n                isAdjacentSibling: firstChar === ADJACENT_SIBLING_COMBINATOR,\n                tag: null,\n                id: null,\n                class: [],\n                attrs: []\n            };\n            item = item.replace(/^[>~+]/, '');\n            // 属性选择器\n            item = item.replace(/\\[(.+?)\\]/g, function (_, $1) {\n                const [key, value] = $1.split('=');\n                const all = $1.indexOf('=') === -1;\n                const attr = {\n                    all,\n                    key,\n                    value: all ? null : value\n                };\n                selector.attrs.push(attr);\n                return '';\n            });\n            item = item.replace(/([.#][A-Za-z0-9-_]+)/g, function (_, $1) {\n                if ($1[0] === ID_SELECTOR) {\n                    // id 选择器\n                    selector.id = $1.substr(1);\n                }\n                else if ($1[0] === CLASS_SELECTOR) {\n                    // class 选择器\n                    selector.class.push($1.substr(1));\n                }\n                return '';\n            });\n            // 标签选择器\n            if (item !== '') {\n                selector.tag = item;\n            }\n            return selector;\n        });\n        return selectors;\n    }\n    matchStyle(tagName, el, list) {\n        const res = sortStyles(this.styles).reduce((str, { content, selectorList }, i) => {\n            let idx = list[i];\n            let selector = selectorList[idx];\n            const nextSelector = selectorList[idx + 1];\n            if ((nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isGeneralSibling) || (nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isAdjacentSibling)) {\n                selector = nextSelector;\n                idx += 1;\n                list[i] += 1;\n            }\n            let isMatch = this.matchCurrent(tagName, el, selector);\n            if (isMatch && selector.isGeneralSibling) {\n                let prev = getPreviousElement(el);\n                while (prev) {\n                    if (prev.h5tagName && this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1])) {\n                        isMatch = true;\n                        break;\n                    }\n                    prev = getPreviousElement(prev);\n                    isMatch = false;\n                }\n            }\n            if (isMatch && selector.isAdjacentSibling) {\n                const prev = getPreviousElement(el);\n                if (!prev || !prev.h5tagName) {\n                    isMatch = false;\n                }\n                else {\n                    const isSiblingMatch = this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1]);\n                    if (!isSiblingMatch) {\n                        isMatch = false;\n                    }\n                }\n            }\n            if (isMatch) {\n                if (idx === selectorList.length - 1) {\n                    return str + content;\n                }\n                else if (idx < selectorList.length - 1) {\n                    list[i] += 1;\n                }\n            }\n            else {\n                // 直接子代组合器: >\n                if (selector.isChild && idx > 0) {\n                    list[i] -= 1;\n                    if (this.matchCurrent(tagName, el, selectorList[list[i]])) {\n                        list[i] += 1;\n                    }\n                }\n            }\n            return str;\n        }, '');\n        return res;\n    }\n    matchCurrent(tagName, el, selector) {\n        // 标签选择器\n        if (selector.tag && selector.tag !== tagName)\n            return false;\n        // id 选择器\n        if (selector.id && selector.id !== el.id)\n            return false;\n        // class 选择器\n        if (selector.class.length) {\n            const classList = el.className.split(' ');\n            for (let i = 0; i < selector.class.length; i++) {\n                const cls = selector.class[i];\n                if (classList.indexOf(cls) === -1) {\n                    return false;\n                }\n            }\n        }\n        // 属性选择器\n        if (selector.attrs.length) {\n            for (let i = 0; i < selector.attrs.length; i++) {\n                const { all, key, value } = selector.attrs[i];\n                if (all && !el.hasAttribute(key)) {\n                    return false;\n                }\n                else {\n                    const attr = el.getAttribute(key);\n                    if (attr !== unquote(value || '')) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\nfunction getPreviousElement(el) {\n    const parent = el.parentElement;\n    if (!parent)\n        return null;\n    const prev = el.previousSibling;\n    if (!prev)\n        return null;\n    if (prev.nodeType === 1 /* NodeType.ELEMENT_NODE */) {\n        return prev;\n    }\n    else {\n        return getPreviousElement(prev);\n    }\n}\n// 根据 css selector 权重排序: 权重大的靠后\n// @WARN 不考虑伪类\n// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#specificity_2\nfunction sortStyles(styles) {\n    return styles.sort((s1, s2) => {\n        const hundreds1 = getHundredsWeight(s1.selectorList);\n        const hundreds2 = getHundredsWeight(s2.selectorList);\n        if (hundreds1 !== hundreds2)\n            return hundreds1 - hundreds2;\n        const tens1 = getTensWeight(s1.selectorList);\n        const tens2 = getTensWeight(s2.selectorList);\n        if (tens1 !== tens2)\n            return tens1 - tens2;\n        const ones1 = getOnesWeight(s1.selectorList);\n        const ones2 = getOnesWeight(s2.selectorList);\n        return ones1 - ones2;\n    });\n}\nfunction getHundredsWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + (cur.id ? 1 : 0), 0);\n}\nfunction getTensWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + cur.class.length + cur.attrs.length, 0);\n}\nfunction getOnesWeight(selectors) {\n    return selectors.reduce((pre, cur) => pre + (cur.tag ? 1 : 0), 0);\n}\n\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\nconst specialMiniElements = {\n    img: 'image',\n    iframe: 'web-view'\n};\nconst internalCompsList = Object.keys(internalComponents)\n    .map(i => i.toLowerCase())\n    .join(',');\n// https://developers.weixin.qq.com/miniprogram/dev/component\nconst isMiniElements = makeMap(internalCompsList, true);\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst isInlineElements = makeMap('a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b', true);\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst isBlockElements = makeMap('address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt', true);\n\nconst closingTagAncestorBreakers = {\n    li: ['ul', 'ol', 'menu'],\n    dt: ['dl'],\n    dd: ['dl'],\n    tbody: ['table'],\n    thead: ['table'],\n    tfoot: ['table'],\n    tr: ['table'],\n    td: ['table']\n};\nfunction hasTerminalParent(tagName, stack) {\n    const tagParents = closingTagAncestorBreakers[tagName];\n    if (tagParents) {\n        let currentIndex = stack.length - 1;\n        while (currentIndex >= 0) {\n            const parentTagName = stack[currentIndex].tagName;\n            if (parentTagName === tagName) {\n                break;\n            }\n            if (tagParents && tagParents.includes(parentTagName)) {\n                return true;\n            }\n            currentIndex--;\n        }\n    }\n    return false;\n}\nfunction getTagName(tag) {\n    if (options.html.renderHTMLTag) {\n        return tag;\n    }\n    if (specialMiniElements[tag]) {\n        return specialMiniElements[tag];\n    }\n    else if (isMiniElements(tag)) {\n        return tag;\n    }\n    else if (isBlockElements(tag)) {\n        return 'view';\n    }\n    else if (isInlineElements(tag)) {\n        return 'text';\n    }\n    return 'view';\n}\nfunction splitEqual(str) {\n    const sep = '=';\n    const idx = str.indexOf(sep);\n    if (idx === -1)\n        return [str];\n    const key = str.slice(0, idx).trim();\n    const value = str.slice(idx + sep.length).trim();\n    return [key, value];\n}\nfunction format(children, document, styleOptions, parent) {\n    return children\n        .filter(child => {\n        // 过滤注释和空文本节点\n        if (child.type === 'comment') {\n            return false;\n        }\n        else if (child.type === 'text') {\n            return child.content !== '';\n        }\n        return true;\n    })\n        .map((child) => {\n        // 文本节点\n        if (child.type === 'text') {\n            let text = document.createTextNode(child.content);\n            if (isFunction(options.html.transformText)) {\n                text = options.html.transformText(text, child);\n            }\n            parent === null || parent === void 0 ? void 0 : parent.appendChild(text);\n            return text;\n        }\n        const el = document.createElement(getTagName(child.tagName));\n        el.h5tagName = child.tagName;\n        parent === null || parent === void 0 ? void 0 : parent.appendChild(el);\n        if (!options.html.renderHTMLTag) {\n            el.className = `h5-${child.tagName}`;\n        }\n        for (let i = 0; i < child.attributes.length; i++) {\n            const attr = child.attributes[i];\n            const [key, value] = splitEqual(attr);\n            if (key === 'class') {\n                el.className += ' ' + unquote(value);\n            }\n            else if (key[0] === 'o' && key[1] === 'n') {\n                continue;\n            }\n            else {\n                el.setAttribute(key, value == null ? true : unquote(value));\n            }\n        }\n        const { styleTagParser, descendantList } = styleOptions;\n        const list = descendantList.slice();\n        const style = styleTagParser.matchStyle(child.tagName, el, list);\n        el.setAttribute('style', style + el.style.cssText);\n        // console.log('style, ', style)\n        format(child.children, document, {\n            styleTagParser,\n            descendantList: list\n        }, el);\n        if (isFunction(options.html.transformElement)) {\n            return options.html.transformElement(el, child);\n        }\n        return el;\n    });\n}\nfunction parser(html, document) {\n    const styleTagParser = new StyleTagParser();\n    html = styleTagParser.extractStyle(html);\n    const tokens = new Scaner(html).scan();\n    const root = { tagName: '', children: [], type: 'element', attributes: [] };\n    const state = { tokens, options, cursor: 0, stack: [root] };\n    parse(state);\n    return format(root.children, document, {\n        styleTagParser,\n        descendantList: Array(styleTagParser.styles.length).fill(0)\n    });\n}\nfunction parse(state) {\n    const { tokens, stack } = state;\n    let { cursor } = state;\n    const len = tokens.length;\n    let nodes = stack[stack.length - 1].children;\n    while (cursor < len) {\n        const token = tokens[cursor];\n        if (token.type !== 'tag-start') {\n            // comment or text\n            nodes.push(token);\n            cursor++;\n            continue;\n        }\n        const tagToken = tokens[++cursor];\n        cursor++;\n        const tagName = tagToken.content.toLowerCase();\n        if (token.close) {\n            let index = stack.length;\n            let shouldRewind = false;\n            while (--index > -1) {\n                if (stack[index].tagName === tagName) {\n                    shouldRewind = true;\n                    break;\n                }\n            }\n            while (cursor < len) {\n                const endToken = tokens[cursor];\n                if (endToken.type !== 'tag-end')\n                    break;\n                cursor++;\n            }\n            if (shouldRewind) {\n                stack.splice(index);\n                break;\n            }\n            else {\n                continue;\n            }\n        }\n        const isClosingTag = options.html.closingElements.has(tagName);\n        let shouldRewindToAutoClose = isClosingTag;\n        if (shouldRewindToAutoClose) {\n            shouldRewindToAutoClose = !hasTerminalParent(tagName, stack);\n        }\n        if (shouldRewindToAutoClose) {\n            let currentIndex = stack.length - 1;\n            while (currentIndex > 0) {\n                if (tagName === stack[currentIndex].tagName) {\n                    stack.splice(currentIndex);\n                    const previousIndex = currentIndex - 1;\n                    nodes = stack[previousIndex].children;\n                    break;\n                }\n                currentIndex = currentIndex - 1;\n            }\n        }\n        const attributes = [];\n        let attrToken;\n        while (cursor < len) {\n            attrToken = tokens[cursor];\n            if (attrToken.type === 'tag-end')\n                break;\n            attributes.push(attrToken.content);\n            cursor++;\n        }\n        cursor++;\n        const children = [];\n        const element = {\n            type: 'element',\n            tagName: tagToken.content,\n            attributes,\n            children\n        };\n        nodes.push(element);\n        const hasChildren = !(attrToken.close || options.html.voidElements.has(tagName));\n        if (hasChildren) {\n            stack.push({ tagName, children });\n            const innerState = { tokens, cursor, stack };\n            parse(innerState);\n            cursor = innerState.cursor;\n        }\n    }\n    state.cursor = cursor;\n}\n\noptions.html = {\n    skipElements: new Set(['style', 'script']),\n    voidElements: new Set([\n        '!doctype', 'area', 'base', 'br', 'col', 'command',\n        'embed', 'hr', 'img', 'input', 'keygen', 'link',\n        'meta', 'param', 'source', 'track', 'wbr'\n    ]),\n    closingElements: new Set([\n        'html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option',\n        'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'\n    ]),\n    renderHTMLTag: false\n};\nfunction setInnerHTML(element, html) {\n    while (element.firstChild) {\n        element.removeChild(element.firstChild);\n    }\n    const children = parser(html, element.ownerDocument);\n    for (let i = 0; i < children.length; i++) {\n        element.appendChild(children[i]);\n    }\n}\n\nfunction getBoundingClientRectImpl() {\n    if (!options.miniGlobal)\n        return Promise.resolve(null);\n    return new Promise(resolve => {\n        const query = options.miniGlobal.createSelectorQuery();\n        query.select(`#${this.uid}`).boundingClientRect(res => {\n            resolve(res);\n        }).exec();\n    });\n}\nfunction getTemplateContent(ctx) {\n    if (ctx.nodeName === 'template') {\n        const document = ctx.ownerDocument;\n        const content = document.createElement(DOCUMENT_FRAGMENT);\n        content.childNodes = ctx.childNodes;\n        ctx.childNodes = [content];\n        content.parentNode = ctx;\n        content.childNodes.forEach(nodes => {\n            nodes.parentNode = content;\n        });\n        return content;\n    }\n}\n\n/**\n * An implementation of `Element.insertAdjacentHTML()`\n * to support Vue 3 with a version of or greater than `vue@3.1.2`\n */\nfunction insertAdjacentHTML(position, html) {\n    var _a, _b;\n    const parsedNodes = parser(html, this.ownerDocument);\n    for (let i = 0; i < parsedNodes.length; i++) {\n        const n = parsedNodes[i];\n        switch (position) {\n            case 'beforebegin':\n                (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(n, this);\n                break;\n            case 'afterbegin':\n                if (this.hasChildNodes()) {\n                    this.insertBefore(n, this.childNodes[0]);\n                }\n                else {\n                    this.appendChild(n);\n                }\n                break;\n            case 'beforeend':\n                this.appendChild(n);\n                break;\n            case 'afterend':\n                (_b = this.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(n);\n                break;\n        }\n    }\n}\nfunction cloneNode(isDeep = false) {\n    const document = this.ownerDocument;\n    let newNode;\n    if (this.nodeType === 1 /* NodeType.ELEMENT_NODE */) {\n        newNode = document.createElement(this.nodeName);\n    }\n    else if (this.nodeType === 3 /* NodeType.TEXT_NODE */) {\n        newNode = document.createTextNode('');\n    }\n    for (const key in this) {\n        const value = this[key];\n        if ([PROPS, DATASET].includes(key) && typeof value === OBJECT) {\n            newNode[key] = Object.assign({}, value);\n        }\n        else if (key === '_value') {\n            newNode[key] = value;\n        }\n        else if (key === STYLE) {\n            newNode.style._value = Object.assign({}, value._value);\n            newNode.style._usedStyleProp = new Set(Array.from(value._usedStyleProp));\n        }\n    }\n    if (isDeep) {\n        newNode.childNodes = this.childNodes.map(node => node.cloneNode(true));\n    }\n    return newNode;\n}\nfunction contains(node) {\n    let isContains = false;\n    this.childNodes.some(childNode => {\n        const { uid } = childNode;\n        if (uid === node.uid || uid === node.id || childNode.contains(node)) {\n            isContains = true;\n            return true;\n        }\n    });\n    return isContains;\n}\n\nif (process.env.TARO_ENV !== 'h5') {\n    if (ENABLE_INNER_HTML) {\n        TaroNode.extend('innerHTML', {\n            set(html) {\n                setInnerHTML.call(this, this, html);\n            },\n            get() {\n                return '';\n            }\n        });\n        if (ENABLE_ADJACENT_HTML) {\n            TaroNode.extend('insertAdjacentHTML', insertAdjacentHTML);\n        }\n    }\n    if (ENABLE_CLONE_NODE) {\n        TaroNode.extend('cloneNode', cloneNode);\n    }\n    if (ENABLE_CONTAINS) {\n        TaroNode.extend('contains', contains);\n    }\n    if (ENABLE_SIZE_APIS) {\n        TaroElement.extend('getBoundingClientRect', getBoundingClientRectImpl);\n    }\n    if (ENABLE_TEMPLATE_CONTENT) {\n        TaroElement.extend('content', {\n            get() {\n                return getTemplateContent(this);\n            }\n        });\n    }\n}\n\n// Taro 事件对象。以 Web 标准的事件对象为基础，加入小程序事件对象中携带的部分信息，并模拟实现事件冒泡。\nclass TaroEvent {\n    constructor(type, opts, event) {\n        this._stop = false;\n        this._end = false;\n        this.defaultPrevented = false;\n        // Mouse Event botton property, it's used in 3rd lib, like react-router. default 0 in general\n        this.button = 0;\n        // timestamp can either be hi-res ( relative to page load) or low-res (relative to UNIX epoch)\n        // here use hi-res timestamp\n        this.timeStamp = Date.now();\n        this.type = type.toLowerCase();\n        this.mpEvent = event;\n        this.bubbles = Boolean(opts && opts.bubbles);\n        this.cancelable = Boolean(opts && opts.cancelable);\n    }\n    stopPropagation() {\n        this._stop = true;\n    }\n    stopImmediatePropagation() {\n        this._end = this._stop = true;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n    }\n    get target() {\n        var _a, _b;\n        const cacheTarget = this.cacheTarget;\n        if (!cacheTarget) {\n            const target = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.target) || null);\n            const element = env.document.getElementById(target.id);\n            target.dataset = element !== null ? element.dataset : EMPTY_OBJ;\n            for (const key in (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.detail) {\n                target[key] = this.mpEvent.detail[key];\n            }\n            this.cacheTarget = target;\n            return target;\n        }\n        else {\n            return cacheTarget;\n        }\n    }\n    get currentTarget() {\n        var _a, _b, _c, _d;\n        const cacheCurrentTarget = this.cacheCurrentTarget;\n        if (!cacheCurrentTarget) {\n            const doc = env.document;\n            const currentTarget = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.currentTarget) || null);\n            const element = doc.getElementById(currentTarget.id);\n            const targetElement = doc.getElementById(((_c = (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.target) === null || _c === void 0 ? void 0 : _c.id) || null);\n            if (element === null || (element && element === targetElement)) {\n                this.cacheCurrentTarget = this.target;\n                return this.target;\n            }\n            currentTarget.dataset = element.dataset;\n            for (const key in (_d = this.mpEvent) === null || _d === void 0 ? void 0 : _d.detail) {\n                currentTarget[key] = this.mpEvent.detail[key];\n            }\n            this.cacheCurrentTarget = currentTarget;\n            return currentTarget;\n        }\n        else {\n            return cacheCurrentTarget;\n        }\n    }\n}\nfunction createEvent(event, node) {\n    if (typeof event === 'string') {\n        // For Vue3 using document.createEvent\n        return new TaroEvent(event, { bubbles: true, cancelable: true });\n    }\n    const domEv = new TaroEvent(event.type, { bubbles: true, cancelable: true }, event);\n    for (const key in event) {\n        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {\n            continue;\n        }\n        else {\n            domEv[key] = event[key];\n        }\n    }\n    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {\n        // eslint-disable-next-line dot-notation\n        domEv[KEY_CODE] = 13;\n    }\n    return domEv;\n}\nconst eventsBatch = {};\nfunction getEventCBResult(event) {\n    const result = event[EVENT_CALLBACK_RESULT];\n    if (!isUndefined(result)) {\n        delete event[EVENT_CALLBACK_RESULT];\n    }\n    return result;\n}\n// 小程序的事件代理回调函数\nfunction eventHandler(event) {\n    var _a, _b;\n    // Note: ohos 上事件没有设置 type、detail 类型 setter 方法，且部分事件（例如 load 等）缺失 target 导致事件错误\n    !event.type && Object.defineProperty(event, 'type', {\n        value: event._type // ohos only\n    });\n    !event.detail && Object.defineProperty(event, 'detail', {\n        value: event._detail || Object.assign({}, event) // ohos only\n    });\n    event.currentTarget = event.currentTarget || event.target || Object.assign({}, event);\n    hooks.call('modifyMpEventImpl', event);\n    const currentTarget = event.currentTarget;\n    const id = ((_a = currentTarget.dataset) === null || _a === void 0 ? void 0 : _a.sid /** sid */) || currentTarget.id /** uid */ || ((_b = event.detail) === null || _b === void 0 ? void 0 : _b.id) || '';\n    const node = env.document.getElementById(id);\n    if (node) {\n        const dispatch = () => {\n            const e = createEvent(event, node);\n            hooks.call('modifyTaroEvent', e, node);\n            node.dispatchEvent(e);\n        };\n        if (hooks.isExist('batchedEventUpdates')) {\n            const type = event.type;\n            if (!hooks.call('isBubbleEvents', type) ||\n                !isParentBinded(node, type) ||\n                (type === TOUCHMOVE && !!node.props.catchMove)) {\n                // 最上层组件统一 batchUpdate\n                hooks.call('batchedEventUpdates', () => {\n                    if (eventsBatch[type]) {\n                        eventsBatch[type].forEach(fn => fn());\n                        delete eventsBatch[type];\n                    }\n                    dispatch();\n                });\n                return getEventCBResult(event);\n            }\n            else {\n                // 如果上层组件也有绑定同类型的组件，委托给上层组件调用事件回调\n                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);\n            }\n        }\n        else {\n            dispatch();\n            return getEventCBResult(event);\n        }\n    }\n}\n\nclass FormElement extends TaroElement {\n    get value() {\n        // eslint-disable-next-line dot-notation\n        const val = this.props[VALUE];\n        return val == null ? '' : val;\n    }\n    set value(val) {\n        this.setAttribute(VALUE, val);\n    }\n    dispatchEvent(event) {\n        if (event.mpEvent) {\n            const val = event.mpEvent.detail.value;\n            if (event.type === CHANGE) {\n                this.props.value = val;\n            }\n            else if (event.type === INPUT) {\n                // Web 规范中表单组件的 value 应该跟着输入改变\n                // 只是改 this.props.value 的话不会进行 setData，因此这里修改 this.value。\n                // 只测试了 React、Vue、Vue3 input 组件的 onInput 事件，onChange 事件不确定有没有副作用，所以暂不修改。\n                this.value = val;\n            }\n        }\n        return super.dispatchEvent(event);\n    }\n}\n\nclass Performance {\n    constructor() {\n        this.recorder = new Map();\n    }\n    start(id) {\n        if (!options.debug) {\n            return;\n        }\n        this.recorder.set(id, Date.now());\n    }\n    stop(id) {\n        if (!options.debug) {\n            return;\n        }\n        const now = Date.now();\n        const prev = this.recorder.get(id);\n        this.recorder.delete(id);\n        const time = now - prev;\n        // eslint-disable-next-line no-console\n        console.log(`${id} 时长： ${time}ms`);\n    }\n}\nconst perf = new Performance();\n\nfunction findCustomWrapper(root, dataPathArr) {\n    // ['root', 'cn', '[0]'] remove 'root' => ['cn', '[0]']\n    const list = dataPathArr.slice(1);\n    let currentData = root;\n    let customWrapper;\n    let splitedPath = '';\n    list.some((item, i) => {\n        const key = item\n            // '[0]' => '0'\n            .replace(/^\\[(.+)\\]$/, '$1')\n            // 'cn' => 'childNodes'\n            .replace(/\\bcn\\b/g, 'childNodes');\n        currentData = currentData[key];\n        if (isUndefined(currentData))\n            return true;\n        if (currentData.nodeName === CUSTOM_WRAPPER) {\n            const res = customWrapperCache.get(currentData.sid);\n            if (res) {\n                customWrapper = res;\n                splitedPath = dataPathArr.slice(i + 2).join('.');\n            }\n        }\n    });\n    if (customWrapper) {\n        return {\n            customWrapper,\n            splitedPath\n        };\n    }\n}\nclass TaroRootElement extends TaroElement {\n    constructor() {\n        super();\n        this.updatePayloads = [];\n        this.updateCallbacks = [];\n        this.pendingUpdate = false;\n        this.ctx = null;\n        this.nodeName = ROOT_STR;\n        this.tagName = ROOT_STR.toUpperCase();\n    }\n    get _path() {\n        return ROOT_STR;\n    }\n    get _root() {\n        return this;\n    }\n    enqueueUpdate(payload) {\n        this.updatePayloads.push(payload);\n        if (!this.pendingUpdate && this.ctx) {\n            this.performUpdate();\n        }\n    }\n    performUpdate(initRender = false, prerender) {\n        this.pendingUpdate = true;\n        const ctx = this.ctx;\n        setTimeout(() => {\n            const setDataMark = `${SET_DATA} 开始时间戳 ${Date.now()}`;\n            perf.start(setDataMark);\n            const data = Object.create(null);\n            const resetPaths = new Set(initRender\n                ? ['root.cn.[0]', 'root.cn[0]']\n                : []);\n            while (this.updatePayloads.length > 0) {\n                const { path, value } = this.updatePayloads.shift();\n                if (path.endsWith(\"cn\" /* Shortcuts.Childnodes */)) {\n                    resetPaths.add(path);\n                }\n                data[path] = value;\n            }\n            for (const path in data) {\n                resetPaths.forEach(p => {\n                    // 已经重置了数组，就不需要分别再设置了\n                    if (path.includes(p) && path !== p) {\n                        delete data[path];\n                    }\n                });\n                const value = data[path];\n                if (isFunction(value)) {\n                    data[path] = value();\n                }\n            }\n            // 预渲染\n            if (isFunction(prerender))\n                return prerender(data);\n            // 正常渲染\n            this.pendingUpdate = false;\n            let normalUpdate = {};\n            const customWrapperMap = new Map();\n            if (initRender) {\n                // 初次渲染，使用页面级别的 setData\n                normalUpdate = data;\n            }\n            else {\n                // 更新渲染，区分 CustomWrapper 与页面级别的 setData\n                for (const p in data) {\n                    const dataPathArr = p.split('.');\n                    const found = findCustomWrapper(this, dataPathArr);\n                    if (found) {\n                        // 此项数据使用 CustomWrapper 去更新\n                        const { customWrapper, splitedPath } = found;\n                        // 合并同一个 customWrapper 的相关更新到一次 setData 中\n                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, (customWrapperMap.get(customWrapper) || {})), { [`i.${splitedPath}`]: data[p] }));\n                    }\n                    else {\n                        // 此项数据使用页面去更新\n                        normalUpdate[p] = data[p];\n                    }\n                }\n            }\n            const customWrapperCount = customWrapperMap.size;\n            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;\n            const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);\n            let executeTime = 0;\n            const cb = () => {\n                if (++executeTime === updateArrLen) {\n                    perf.stop(setDataMark);\n                    this.flushUpdateCallback();\n                    initRender && perf.stop(PAGE_INIT);\n                }\n            };\n            // custom-wrapper setData\n            if (customWrapperCount) {\n                customWrapperMap.forEach((data, ctx) => {\n                    if (process.env.NODE_ENV !== 'production' && options.debug) {\n                        // eslint-disable-next-line no-console\n                        console.log('custom wrapper setData: ', data);\n                    }\n                    ctx.setData(data, cb);\n                });\n            }\n            // page setData\n            if (isNeedNormalUpdate) {\n                if (process.env.NODE_ENV !== 'production' && options.debug) {\n                    // eslint-disable-next-line no-console\n                    console.log('page setData:', normalUpdate);\n                }\n                ctx.setData(normalUpdate, cb);\n            }\n        }, 0);\n    }\n    enqueueUpdateCallback(cb, ctx) {\n        this.updateCallbacks.push(() => {\n            ctx ? cb.call(ctx) : cb();\n        });\n    }\n    flushUpdateCallback() {\n        const updateCallbacks = this.updateCallbacks;\n        if (!updateCallbacks.length)\n            return;\n        const copies = updateCallbacks.slice(0);\n        this.updateCallbacks.length = 0;\n        for (let i = 0; i < copies.length; i++) {\n            copies[i]();\n        }\n    }\n}\n\nclass TaroText extends TaroNode {\n    constructor(value) {\n        super();\n        this.nodeType = 3 /* NodeType.TEXT_NODE */;\n        this.nodeName = '#text';\n        this._value = value;\n    }\n    set textContent(text) {\n        MutationObserver.record({\n            target: this,\n            type: \"characterData\" /* MutationRecordType.CHARACTER_DATA */,\n            oldValue: this._value\n        });\n        this._value = text;\n        this.enqueueUpdate({\n            path: `${this._path}.${\"v\" /* Shortcuts.Text */}`,\n            value: text\n        });\n    }\n    get textContent() {\n        return this._value;\n    }\n    set nodeValue(text) {\n        this.textContent = text;\n    }\n    get nodeValue() {\n        return this._value;\n    }\n    set data(text) {\n        this.textContent = text;\n    }\n    get data() {\n        return this._value;\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\n\nvar _URLSearchParams_dict;\nconst findReg = /[!'()~]|%20|%00/g;\nconst plusReg = /\\+/g;\nconst replaceCharMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00',\n};\nfunction replacer(match) {\n    return replaceCharMap[match];\n}\nfunction appendTo(dict, name, value) {\n    const res = isArray(value) ? value.join(',') : value;\n    if (name in dict)\n        dict[name].push(res);\n    else\n        dict[name] = [res];\n}\nfunction addEach(value, key) {\n    appendTo(this, key, value);\n}\nfunction decode(str) {\n    return decodeURIComponent(str.replace(plusReg, ' '));\n}\nfunction encode(str) {\n    return encodeURIComponent(str).replace(findReg, replacer);\n}\nclass URLSearchParams {\n    constructor(query) {\n        _URLSearchParams_dict.set(this, Object.create(null));\n        if (!query)\n            return;\n        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n        if (typeof query === 'string') {\n            if (query.charAt(0) === '?') {\n                query = query.slice(1);\n            }\n            for (let pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {\n                const value = pairs[i];\n                const index = value.indexOf('=');\n                if (index > -1) {\n                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n                }\n                else if (value.length) {\n                    appendTo(dict, decode(value), '');\n                }\n            }\n        }\n        else {\n            if (isArray(query)) {\n                for (let i = 0, length = query.length; i < length; i++) {\n                    const value = query[i];\n                    appendTo(dict, value[0], value[1]);\n                }\n            }\n            else if (query.forEach) {\n                query.forEach(addEach, dict);\n            }\n            else {\n                for (const key in query) {\n                    appendTo(dict, key, query[key]);\n                }\n            }\n        }\n    }\n    append(name, value) {\n        appendTo(__classPrivateFieldGet(this, _URLSearchParams_dict, \"f\"), name, value);\n    }\n    delete(name) {\n        delete __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\")[name];\n    }\n    get(name) {\n        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n        return name in dict ? dict[name][0] : null;\n    }\n    getAll(name) {\n        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n        return name in dict ? dict[name].slice(0) : [];\n    }\n    has(name) {\n        return name in __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n    }\n    keys() {\n        return Object.keys(__classPrivateFieldGet(this, _URLSearchParams_dict, \"f\"));\n    }\n    set(name, value) {\n        __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\")[name] = ['' + value];\n    }\n    forEach(callback, thisArg) {\n        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n        Object.getOwnPropertyNames(dict).forEach(function (name) {\n            dict[name].forEach(function (value) {\n                callback.call(thisArg, value, name, this);\n            }, this);\n        }, this);\n    }\n    toJSON() {\n        return {};\n    }\n    toString() {\n        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, \"f\");\n        const query = [];\n        for (const key in dict) {\n            const name = encode(key);\n            for (let i = 0, value = dict[key]; i < value.length; i++) {\n                query.push(name + '=' + encode(value[i]));\n            }\n        }\n        return query.join('&');\n    }\n}\n_URLSearchParams_dict = new WeakMap();\n\nvar _URL_hash, _URL_hostname, _URL_pathname, _URL_port, _URL_protocol, _URL_search;\nclass URL {\n    constructor(url, base) {\n        /* private property */\n        _URL_hash.set(this, '');\n        _URL_hostname.set(this, '');\n        _URL_pathname.set(this, '');\n        _URL_port.set(this, '');\n        _URL_protocol.set(this, '');\n        _URL_search.set(this, '');\n        if (!isString(url))\n            url = String(url);\n        const parseResult = parseUrlBase(url, base);\n        const { hash, hostname, pathname, port, protocol, search } = parseResult;\n        __classPrivateFieldSet(this, _URL_hash, hash, \"f\");\n        __classPrivateFieldSet(this, _URL_hostname, hostname, \"f\");\n        __classPrivateFieldSet(this, _URL_pathname, pathname || '/', \"f\");\n        __classPrivateFieldSet(this, _URL_port, port, \"f\");\n        __classPrivateFieldSet(this, _URL_protocol, protocol, \"f\");\n        __classPrivateFieldSet(this, _URL_search, search, \"f\");\n    }\n    static createObjectURL() {\n        throw new Error('Oops, not support URL.createObjectURL() in miniprogram.');\n    }\n    static revokeObjectURL() {\n        throw new Error('Oops, not support URL.revokeObjectURL() in miniprogram.');\n    }\n    /* public property */\n    get protocol() {\n        return __classPrivateFieldGet(this, _URL_protocol, \"f\");\n    }\n    set protocol(val) {\n        isString(val) && (__classPrivateFieldSet(this, _URL_protocol, val.trim(), \"f\"));\n    }\n    get host() {\n        return this.hostname + (this.port ? ':' + this.port : '');\n    }\n    set host(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { hostname, port } = parseUrl(`//${val}`);\n            this.hostname = hostname;\n            this.port = port;\n        }\n    }\n    get hostname() {\n        return __classPrivateFieldGet(this, _URL_hostname, \"f\");\n    }\n    set hostname(val) {\n        val && isString(val) && (__classPrivateFieldSet(this, _URL_hostname, val.trim(), \"f\"));\n    }\n    get port() {\n        return __classPrivateFieldGet(this, _URL_port, \"f\");\n    }\n    set port(val) {\n        isString(val) && (__classPrivateFieldSet(this, _URL_port, val.trim(), \"f\"));\n    }\n    get pathname() {\n        return __classPrivateFieldGet(this, _URL_pathname, \"f\");\n    }\n    set pathname(val) {\n        if (isString(val)) {\n            val = val.trim();\n            const HEAD_REG = /^(\\/|\\.\\/|\\.\\.\\/)/;\n            let temp = val;\n            while (HEAD_REG.test(temp)) {\n                temp = temp.replace(HEAD_REG, '');\n            }\n            if (temp)\n                __classPrivateFieldSet(this, _URL_pathname, '/' + temp, \"f\");\n            else\n                __classPrivateFieldSet(this, _URL_pathname, '/', \"f\");\n        }\n    }\n    get search() {\n        return __classPrivateFieldGet(this, _URL_search, \"f\");\n    }\n    set search(val) {\n        if (isString(val)) {\n            val = val.trim();\n            if (val)\n                __classPrivateFieldSet(this, _URL_search, val.startsWith('?') ? val : `?${val}`, \"f\");\n            else\n                __classPrivateFieldSet(this, _URL_search, '', \"f\");\n        }\n    }\n    get hash() {\n        return __classPrivateFieldGet(this, _URL_hash, \"f\");\n    }\n    set hash(val) {\n        if (isString(val)) {\n            val = val.trim();\n            if (val)\n                __classPrivateFieldSet(this, _URL_hash, val.startsWith('#') ? val : `#${val}`, \"f\");\n            else\n                __classPrivateFieldSet(this, _URL_hash, '', \"f\");\n        }\n    }\n    get href() {\n        return `${this.protocol}//${this.host}${this.pathname}${this.search}${this.hash}`;\n    }\n    set href(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { protocol, hostname, port, hash, search, pathname } = parseUrl(val);\n            this.protocol = protocol;\n            this.hostname = hostname;\n            this.pathname = pathname;\n            this.port = port;\n            this.hash = hash;\n            this.search = search;\n        }\n    }\n    get origin() {\n        return `${this.protocol}//${this.host}`;\n    }\n    set origin(val) {\n        if (val && isString(val)) {\n            val = val.trim();\n            const { protocol, hostname, port } = parseUrl(val);\n            this.protocol = protocol;\n            this.hostname = hostname;\n            this.port = port;\n        }\n    }\n    get searchParams() {\n        return new URLSearchParams(this.search);\n    }\n    // public method\n    toString() {\n        return this.href;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    // convenient for deconstructor\n    _toRaw() {\n        return {\n            protocol: this.protocol,\n            port: this.port,\n            host: this.host,\n            hostname: this.hostname,\n            pathname: this.pathname,\n            hash: this.hash,\n            search: this.search,\n            origin: this.origin,\n            href: this.href,\n        };\n    }\n}\n_URL_hash = new WeakMap(), _URL_hostname = new WeakMap(), _URL_pathname = new WeakMap(), _URL_port = new WeakMap(), _URL_protocol = new WeakMap(), _URL_search = new WeakMap();\nfunction parseUrl(url = '') {\n    const result = {\n        href: '',\n        origin: '',\n        protocol: '',\n        hostname: '',\n        host: '',\n        port: '',\n        pathname: '',\n        search: '',\n        hash: ''\n    };\n    if (!url || !isString(url))\n        return result;\n    url = url.trim();\n    const PATTERN = /^(([^:/?#]+):)?\\/\\/(([^/?#]+):(.+)@)?([^/?#:]*)(:(\\d+))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    const matches = url.match(PATTERN);\n    if (!matches)\n        return result;\n    // TODO: username & password ?\n    result.protocol = matches[1] || 'https:';\n    result.hostname = matches[6] || 'taro.com';\n    result.port = matches[8] || '';\n    result.pathname = matches[9] || '/';\n    result.search = matches[10] || '';\n    result.hash = matches[12] || '';\n    result.href = url;\n    result.origin = result.protocol + '//' + result.hostname;\n    result.host = result.hostname + (result.port ? `:${result.port}` : '');\n    return result;\n}\nfunction parseUrlBase(url, base) {\n    const VALID_URL = /^(https?:)\\/\\//i;\n    let fullUrl = '';\n    let parsedBase = null;\n    if (!isUndefined(base)) {\n        base = String(base).trim();\n        if (!VALID_URL.test(base))\n            throw new TypeError(`Failed to construct 'URL': Invalid base URL`);\n        parsedBase = parseUrl(base);\n    }\n    url = String(url).trim();\n    if (VALID_URL.test(url)) {\n        fullUrl = url;\n    }\n    else if (parsedBase) {\n        if (url) {\n            if (url.startsWith('//')) {\n                fullUrl = parsedBase.protocol + url;\n            }\n            else {\n                fullUrl = parsedBase.origin + (url.startsWith('/') ? url : `/${url}`);\n            }\n        }\n        else {\n            fullUrl = parsedBase.href;\n        }\n    }\n    else {\n        throw new TypeError(`Failed to construct 'URL': Invalid URL`);\n    }\n    return parseUrl(fullUrl);\n}\n\nclass AnchorElement extends TaroElement {\n    get href() {\n        var _a;\n        return (_a = this.props[\"href\" /* AnchorElementAttrs.HREF */]) !== null && _a !== void 0 ? _a : '';\n    }\n    set href(val) {\n        this.setAttribute(\"href\" /* AnchorElementAttrs.HREF */, val);\n    }\n    get protocol() {\n        var _a;\n        return (_a = this.props[\"protocol\" /* AnchorElementAttrs.PROTOCOL */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get host() {\n        var _a;\n        return (_a = this.props[\"host\" /* AnchorElementAttrs.HOST */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get search() {\n        var _a;\n        return (_a = this.props[\"search\" /* AnchorElementAttrs.SEARCH */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get hash() {\n        var _a;\n        return (_a = this.props[\"hash\" /* AnchorElementAttrs.HASH */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get hostname() {\n        var _a;\n        return (_a = this.props[\"hostname\" /* AnchorElementAttrs.HOSTNAME */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get port() {\n        var _a;\n        return (_a = this.props[\"port\" /* AnchorElementAttrs.PORT */]) !== null && _a !== void 0 ? _a : '';\n    }\n    get pathname() {\n        var _a;\n        return (_a = this.props[\"pathname\" /* AnchorElementAttrs.PATHNAME */]) !== null && _a !== void 0 ? _a : '';\n    }\n    setAttribute(qualifiedName, value) {\n        if (qualifiedName === \"href\" /* AnchorElementAttrs.HREF */) {\n            const willSetAttr = parseUrl(value);\n            for (const k in willSetAttr) {\n                super.setAttribute(k, willSetAttr[k]);\n            }\n        }\n        else {\n            super.setAttribute(qualifiedName, value);\n        }\n    }\n}\n\nclass TaroDocument extends TaroElement {\n    constructor() {\n        super();\n        this.createEvent = createEvent;\n        this.nodeType = 9 /* NodeType.DOCUMENT_NODE */;\n        this.nodeName = DOCUMENT_ELEMENT_NAME;\n    }\n    createElement(type) {\n        const nodeName = type.toLowerCase();\n        let element;\n        switch (true) {\n            case nodeName === ROOT_STR:\n                element = new TaroRootElement();\n                return element;\n            case controlledComponent.has(nodeName):\n                element = new FormElement();\n                break;\n            case nodeName === A:\n                element = new AnchorElement();\n                break;\n            default:\n                element = new TaroElement();\n                break;\n        }\n        element.nodeName = nodeName;\n        element.tagName = type.toUpperCase();\n        return element;\n    }\n    // an ugly fake createElementNS to deal with @vue/runtime-dom's\n    // support mounting app to svg container since vue@3.0.8\n    createElementNS(_svgNS, type) {\n        return this.createElement(type);\n    }\n    createTextNode(text) {\n        return new TaroText(text);\n    }\n    getElementById(id) {\n        const el = eventSource.get(id);\n        return isUndefined(el) ? null : el;\n    }\n    querySelector(query) {\n        // 为了 Vue3 的乞丐版实现\n        if (/^#/.test(query)) {\n            return this.getElementById(query.slice(1));\n        }\n        return null;\n    }\n    querySelectorAll() {\n        // fake hack\n        return [];\n    }\n    // @TODO: @PERF: 在 hydrate 移除掉空的 node\n    createComment() {\n        const textnode = new TaroText('');\n        textnode.nodeName = COMMENT;\n        return textnode;\n    }\n    get defaultView() {\n        return env.window;\n    }\n}\n\nlet document$1;\nif (process.env.TARO_ENV && process.env.TARO_ENV !== 'h5') {\n    /* eslint-disable no-inner-declarations */\n    function createDocument() {\n        /**\n           * <document>\n           *   <html>\n           *     <head></head>\n           *     <body>\n           *       <container>\n           *         <app id=\"app\" />\n           *       </container>\n           *     </body>\n           *   </html>\n           * </document>\n           */\n        const doc = new TaroDocument();\n        const documentCreateElement = doc.createElement.bind(doc);\n        const html = documentCreateElement(HTML);\n        const head = documentCreateElement(HEAD);\n        const body = documentCreateElement(BODY);\n        const app = documentCreateElement(APP);\n        app.id = APP;\n        const container = documentCreateElement(CONTAINER); // 多包一层主要为了兼容 vue\n        doc.appendChild(html);\n        html.appendChild(head);\n        html.appendChild(body);\n        body.appendChild(container);\n        container.appendChild(app);\n        doc.documentElement = html;\n        doc.head = head;\n        doc.body = body;\n        return doc;\n    }\n    document$1 = env.document = createDocument();\n}\nelse {\n    document$1 = env.document;\n}\n\nfunction getComputedStyle(element) {\n    return element.style;\n}\n\nconst eventCenter = hooks.call('getEventCenter', Events);\n\n/**\n * 一个小型缓存池，用于在切换页面时，存储一些上下文信息\n */\nclass RuntimeCache {\n    constructor(name) {\n        this.cache = new Map();\n        this.name = name;\n    }\n    has(identifier) {\n        return this.cache.has(identifier);\n    }\n    set(identifier, ctx) {\n        if (identifier && ctx) {\n            this.cache.set(identifier, ctx);\n        }\n    }\n    get(identifier) {\n        if (this.has(identifier))\n            return this.cache.get(identifier);\n    }\n    delete(identifier) {\n        this.cache.delete(identifier);\n    }\n}\n\nvar _History_instances, _History_location, _History_stack, _History_cur, _History_window, _History_reset;\nconst cache$1 = new RuntimeCache('history');\nclass History extends Events {\n    constructor(location, options) {\n        super();\n        _History_instances.add(this);\n        /* private property */\n        _History_location.set(this, void 0);\n        _History_stack.set(this, []);\n        _History_cur.set(this, 0);\n        _History_window.set(this, void 0);\n        __classPrivateFieldSet(this, _History_window, options.window, \"f\");\n        __classPrivateFieldSet(this, _History_location, location, \"f\");\n        __classPrivateFieldGet(this, _History_location, \"f\").on('__record_history__', (href) => {\n            var _a;\n            __classPrivateFieldSet(this, _History_cur, (_a = __classPrivateFieldGet(this, _History_cur, \"f\"), _a++, _a), \"f\");\n            __classPrivateFieldSet(this, _History_stack, __classPrivateFieldGet(this, _History_stack, \"f\").slice(0, __classPrivateFieldGet(this, _History_cur, \"f\")), \"f\");\n            __classPrivateFieldGet(this, _History_stack, \"f\").push({\n                state: null,\n                title: '',\n                url: href\n            });\n        }, null);\n        __classPrivateFieldGet(this, _History_location, \"f\").on('__reset_history__', (href) => {\n            __classPrivateFieldGet(this, _History_instances, \"m\", _History_reset).call(this, href);\n        }, null);\n        // 切换上下文行为\n        this.on(CONTEXT_ACTIONS.INIT, () => {\n            __classPrivateFieldGet(this, _History_instances, \"m\", _History_reset).call(this);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n            cache$1.set(pageId, {\n                location: __classPrivateFieldGet(this, _History_location, \"f\"),\n                stack: __classPrivateFieldGet(this, _History_stack, \"f\").slice(),\n                cur: __classPrivateFieldGet(this, _History_cur, \"f\")\n            });\n        }, null);\n        this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n            if (cache$1.has(pageId)) {\n                const ctx = cache$1.get(pageId);\n                __classPrivateFieldSet(this, _History_location, ctx.location, \"f\");\n                __classPrivateFieldSet(this, _History_stack, ctx.stack, \"f\");\n                __classPrivateFieldSet(this, _History_cur, ctx.cur, \"f\");\n            }\n        }, null);\n        this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n            cache$1.delete(pageId);\n        }, null);\n        __classPrivateFieldGet(this, _History_instances, \"m\", _History_reset).call(this);\n    }\n    /* public property */\n    get length() {\n        return __classPrivateFieldGet(this, _History_stack, \"f\").length;\n    }\n    get state() {\n        return __classPrivateFieldGet(this, _History_stack, \"f\")[__classPrivateFieldGet(this, _History_cur, \"f\")];\n    }\n    /* public method */\n    go(delta) {\n        if (!isNumber(delta) || isNaN(delta))\n            return;\n        let targetIdx = __classPrivateFieldGet(this, _History_cur, \"f\") + delta;\n        targetIdx = Math.min(Math.max(targetIdx, 0), this.length - 1);\n        __classPrivateFieldSet(this, _History_cur, targetIdx, \"f\");\n        __classPrivateFieldGet(this, _History_location, \"f\").trigger('__set_href_without_history__', __classPrivateFieldGet(this, _History_stack, \"f\")[__classPrivateFieldGet(this, _History_cur, \"f\")].url);\n        __classPrivateFieldGet(this, _History_window, \"f\").trigger('popstate', __classPrivateFieldGet(this, _History_stack, \"f\")[__classPrivateFieldGet(this, _History_cur, \"f\")]);\n    }\n    back() {\n        this.go(-1);\n    }\n    forward() {\n        this.go(1);\n    }\n    pushState(state, title, url) {\n        if (!url || !isString(url))\n            return;\n        __classPrivateFieldSet(this, _History_stack, __classPrivateFieldGet(this, _History_stack, \"f\").slice(0, __classPrivateFieldGet(this, _History_cur, \"f\") + 1), \"f\");\n        __classPrivateFieldGet(this, _History_stack, \"f\").push({\n            state,\n            title,\n            url\n        });\n        __classPrivateFieldSet(this, _History_cur, this.length - 1, \"f\");\n        __classPrivateFieldGet(this, _History_location, \"f\").trigger('__set_href_without_history__', url);\n    }\n    replaceState(state, title, url) {\n        if (!url || !isString(url))\n            return;\n        __classPrivateFieldGet(this, _History_stack, \"f\")[__classPrivateFieldGet(this, _History_cur, \"f\")] = {\n            state,\n            title,\n            url\n        };\n        __classPrivateFieldGet(this, _History_location, \"f\").trigger('__set_href_without_history__', url);\n    }\n    // For debug\n    get cache() {\n        return cache$1;\n    }\n}\n_History_location = new WeakMap(), _History_stack = new WeakMap(), _History_cur = new WeakMap(), _History_window = new WeakMap(), _History_instances = new WeakSet(), _History_reset = function _History_reset(href = '') {\n    __classPrivateFieldSet(this, _History_stack, [\n        {\n            state: null,\n            title: '',\n            url: href || __classPrivateFieldGet(this, _History_location, \"f\").href\n        }\n    ], \"f\");\n    __classPrivateFieldSet(this, _History_cur, 0, \"f\");\n};\n\nconst Current = {\n    app: null,\n    router: null,\n    page: null\n};\nconst getCurrentInstance = () => Current;\n\nvar _Location_instances, _Location_url, _Location_noCheckUrl, _Location_window, _Location_reset, _Location_getPreValue, _Location_rollBack, _Location_recordHistory, _Location_checkUrlChange;\nconst INIT_URL = 'https://taro.com';\nconst cache = new RuntimeCache('location');\nclass Location extends Events {\n    constructor(options) {\n        super();\n        _Location_instances.add(this);\n        /* private property */\n        _Location_url.set(this, new URL(INIT_URL));\n        _Location_noCheckUrl.set(this, false);\n        _Location_window.set(this, void 0);\n        __classPrivateFieldSet(this, _Location_window, options.window, \"f\");\n        __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_reset).call(this);\n        this.on('__set_href_without_history__', (href) => {\n            __classPrivateFieldSet(this, _Location_noCheckUrl, true, \"f\");\n            const lastHash = __classPrivateFieldGet(this, _Location_url, \"f\").hash;\n            __classPrivateFieldGet(this, _Location_url, \"f\").href = generateFullUrl(href);\n            if (lastHash !== __classPrivateFieldGet(this, _Location_url, \"f\").hash) {\n                __classPrivateFieldGet(this, _Location_window, \"f\").trigger('hashchange');\n            }\n            __classPrivateFieldSet(this, _Location_noCheckUrl, false, \"f\");\n        }, null);\n        // 切换上下文行为\n        this.on(CONTEXT_ACTIONS.INIT, () => {\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_reset).call(this);\n        }, null);\n        this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n            cache.set(pageId, {\n                lastHref: this.href,\n            });\n        }, null);\n        this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n            // 数据恢复时，不需要执行跳转\n            if (cache.has(pageId)) {\n                const ctx = cache.get(pageId);\n                __classPrivateFieldSet(this, _Location_noCheckUrl, true, \"f\");\n                __classPrivateFieldGet(this, _Location_url, \"f\").href = ctx.lastHref;\n                __classPrivateFieldSet(this, _Location_noCheckUrl, false, \"f\");\n            }\n        }, null);\n        this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n            cache.delete(pageId);\n        }, null);\n    }\n    /* public property */\n    get protocol() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").protocol;\n    }\n    set protocol(val) {\n        const REG = /^(http|https):$/i;\n        if (!val || !isString(val) || !REG.test(val.trim()))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").protocol = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get host() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").host;\n    }\n    set host(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").host = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get hostname() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").hostname;\n    }\n    set hostname(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").hostname = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get port() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").port;\n    }\n    set port(val) {\n        const xVal = Number((val = val.trim()));\n        if (!isNumber(xVal) || xVal <= 0)\n            return;\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").port = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get pathname() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").pathname;\n    }\n    set pathname(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").pathname = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get search() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").search;\n    }\n    set search(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        val = val.startsWith('?') ? val : `?${val}`;\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").search = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get hash() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").hash;\n    }\n    // 小程序的navigateTo存在截断hash字符串的问题\n    set hash(val) {\n        if (!val || !isString(val))\n            return;\n        val = val.trim();\n        val = val.startsWith('#') ? val : `#${val}`;\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").hash = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get href() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").href;\n    }\n    set href(val) {\n        const REG = /^(http:|https:)?\\/\\/.+/;\n        if (!val || !isString(val) || !REG.test((val = val.trim())))\n            return;\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").href = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    get origin() {\n        return __classPrivateFieldGet(this, _Location_url, \"f\").origin;\n    }\n    set origin(val) {\n        const REG = /^(http:|https:)?\\/\\/.+/;\n        if (!val || !isString(val) || !REG.test((val = val.trim())))\n            return;\n        const preValue = __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_getPreValue).call(this);\n        __classPrivateFieldGet(this, _Location_url, \"f\").origin = val;\n        if (__classPrivateFieldGet(this, _Location_instances, \"m\", _Location_checkUrlChange).call(this, preValue))\n            __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_recordHistory).call(this);\n    }\n    /* public method */\n    assign() {\n        warn(true, '小程序环境中调用location.assign()无效.');\n    }\n    reload() {\n        warn(true, '小程序环境中调用location.reload()无效.');\n    }\n    replace(url) {\n        this.trigger('__set_href_without_history__', url);\n    }\n    toString() {\n        return this.href;\n    }\n    // For debug\n    get cache() {\n        return cache;\n    }\n}\n_Location_url = new WeakMap(), _Location_noCheckUrl = new WeakMap(), _Location_window = new WeakMap(), _Location_instances = new WeakSet(), _Location_reset = function _Location_reset() {\n    const Current = getCurrentInstance();\n    const router = Current.router;\n    if (router) {\n        const { path, params } = router;\n        const searchArr = Object.keys(params).map((key) => {\n            return `${key}=${params[key]}`;\n        });\n        const searchStr = searchArr.length > 0 ? '?' + searchArr.join('&') : '';\n        const url = `${INIT_URL}${path.startsWith('/') ? path : '/' + path}${searchStr}`;\n        __classPrivateFieldSet(this, _Location_url, new URL(url), \"f\");\n        this.trigger('__reset_history__', this.href);\n    }\n}, _Location_getPreValue = function _Location_getPreValue() {\n    return __classPrivateFieldGet(this, _Location_url, \"f\")._toRaw();\n}, _Location_rollBack = function _Location_rollBack(href) {\n    __classPrivateFieldGet(this, _Location_url, \"f\").href = href;\n}, _Location_recordHistory = function _Location_recordHistory() {\n    this.trigger('__record_history__', this.href);\n}, _Location_checkUrlChange = function _Location_checkUrlChange(preValue) {\n    if (__classPrivateFieldGet(this, _Location_noCheckUrl, \"f\")) {\n        return false;\n    }\n    const { protocol, hostname, port, pathname, search, hash } = __classPrivateFieldGet(this, _Location_url, \"f\")._toRaw();\n    // 跨域三要素不允许修改\n    if (protocol !== preValue.protocol || hostname !== preValue.hostname || port !== preValue.port) {\n        __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_rollBack).call(this, preValue.href);\n        return false;\n    }\n    // pathname\n    if (pathname !== preValue.pathname) {\n        return true;\n    }\n    // search\n    if (search !== preValue.search) {\n        return true;\n    }\n    // hashchange\n    if (hash !== preValue.hash) {\n        __classPrivateFieldGet(this, _Location_window, \"f\").trigger('hashchange');\n        return true;\n    }\n    __classPrivateFieldGet(this, _Location_instances, \"m\", _Location_rollBack).call(this, preValue.href);\n    return false;\n};\nfunction generateFullUrl(val = '') {\n    const origin = INIT_URL;\n    if (/^[/?#]/.test(val)) {\n        return origin + val;\n    }\n    return val;\n}\n\nconst machine = 'Macintosh';\nconst arch = 'Intel Mac OS X 10_14_5';\nconst engine = 'AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36';\nconst msg = '(' + machine + '; ' + arch + ') ' + engine;\nconst nav = process.env.TARO_ENV === 'h5' ? env.window.navigator : {\n    appCodeName: 'Mozilla',\n    appName: 'Netscape',\n    appVersion: '5.0 ' + msg,\n    cookieEnabled: true,\n    mimeTypes: [],\n    onLine: true,\n    platform: 'MacIntel',\n    plugins: [],\n    product: 'Taro',\n    productSub: '20030107',\n    userAgent: 'Mozilla/5.0 ' + msg,\n    vendor: 'Joyent',\n    vendorSub: ''\n};\n\n// https://github.com/myrne/performance-now\nlet now;\n(function () {\n    let loadTime;\n    if ((typeof performance !== 'undefined' && performance !== null) && performance.now) {\n        now = () => performance.now();\n    }\n    else if (Date.now) {\n        loadTime = Date.now();\n        now = () => Date.now() - loadTime;\n    }\n    else {\n        loadTime = new Date().getTime();\n        now = () => new Date().getTime() - loadTime;\n    }\n})();\nlet lastTime = 0;\n// https://gist.github.com/paulirish/1579671\n// https://gist.github.com/jalbam/5fe05443270fa6d8136238ec72accbc0\nconst _raf = typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame !== null ? requestAnimationFrame : function (callback) {\n    const _now = now();\n    const nextTime = Math.max(lastTime + 16, _now); // First time will execute it immediately but barely noticeable and performance is gained.\n    return setTimeout(function () { callback(lastTime = nextTime); }, nextTime - _now);\n};\nconst _caf = typeof cancelAnimationFrame !== 'undefined' && cancelAnimationFrame !== null\n    ? cancelAnimationFrame\n    : function (seed) {\n        // fix https://github.com/NervJS/taro/issues/7749\n        clearTimeout(seed);\n    };\n\nlet window$1;\nif (process.env.TARO_ENV && process.env.TARO_ENV !== 'h5') {\n    class Window extends Events {\n        constructor() {\n            super();\n            this.navigator = nav;\n            this.requestAnimationFrame = _raf;\n            this.cancelAnimationFrame = _caf;\n            this.getComputedStyle = getComputedStyle;\n            const globalProperties = [\n                ...Object.getOwnPropertyNames(global || {}),\n                ...Object.getOwnPropertySymbols(global || {})\n            ];\n            globalProperties.forEach(property => {\n                if (property === 'atob' || property === 'document')\n                    return;\n                if (!Object.prototype.hasOwnProperty.call(this, property)) {\n                    this[property] = global[property];\n                }\n            });\n            this.Date || (this.Date = Date);\n            // 应用启动时，提供给需要读取历史信息的库使用\n            this.location = new Location({ window: this });\n            this.history = new History(this.location, { window: this });\n            this.initEvent();\n        }\n        initEvent() {\n            const _location = this.location;\n            const _history = this.history;\n            this.on(CONTEXT_ACTIONS.INIT, (pageId) => {\n                // 页面onload，为该页面建立新的上下文信息\n                _location.trigger(CONTEXT_ACTIONS.INIT, pageId);\n            }, null);\n            this.on(CONTEXT_ACTIONS.RECOVER, (pageId) => {\n                // 页面onshow，恢复当前页面的上下文信息\n                _location.trigger(CONTEXT_ACTIONS.RECOVER, pageId);\n                _history.trigger(CONTEXT_ACTIONS.RECOVER, pageId);\n            }, null);\n            this.on(CONTEXT_ACTIONS.RESTORE, (pageId) => {\n                // 页面onhide，缓存当前页面的上下文信息\n                _location.trigger(CONTEXT_ACTIONS.RESTORE, pageId);\n                _history.trigger(CONTEXT_ACTIONS.RESTORE, pageId);\n            }, null);\n            this.on(CONTEXT_ACTIONS.DESTORY, (pageId) => {\n                // 页面onunload，清除当前页面的上下文信息\n                _location.trigger(CONTEXT_ACTIONS.DESTORY, pageId);\n                _history.trigger(CONTEXT_ACTIONS.DESTORY, pageId);\n            }, null);\n        }\n        get document() {\n            return env.document;\n        }\n        addEventListener(event, callback) {\n            if (!isString(event))\n                return;\n            this.on(event, callback, null);\n        }\n        removeEventListener(event, callback) {\n            if (!isString(event))\n                return;\n            this.off(event, callback, null);\n        }\n        setTimeout(...args) {\n            return setTimeout(...args);\n        }\n        clearTimeout(...args) {\n            return clearTimeout(...args);\n        }\n    }\n    window$1 = env.window = new Window();\n}\nelse {\n    window$1 = env.window;\n}\nconst location = window$1.location;\nconst history = window$1.history;\n\n// for Vue3\nclass SVGElement extends TaroElement {\n}\n\n/* eslint-disable dot-notation */\nconst instances = new Map();\nconst pageId = incrementId();\nfunction injectPageInstance(inst, id) {\n    hooks.call('mergePageInstance', instances.get(id), inst);\n    instances.set(id, inst);\n}\nfunction getPageInstance(id) {\n    return instances.get(id);\n}\nfunction removePageInstance(id) {\n    instances.delete(id);\n}\nfunction addLeadingSlash(path) {\n    if (path == null) {\n        return '';\n    }\n    return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction safeExecute(path, lifecycle, ...args) {\n    const instance = instances.get(path);\n    if (instance == null) {\n        return;\n    }\n    const func = hooks.call('getLifecycle', instance, lifecycle);\n    if (isArray(func)) {\n        const res = func.map(fn => fn.apply(instance, args));\n        return res[0];\n    }\n    if (!isFunction(func)) {\n        return;\n    }\n    return func.apply(instance, args);\n}\nfunction stringify(obj) {\n    if (obj == null) {\n        return '';\n    }\n    const path = Object.keys(obj).map((key) => {\n        return key + '=' + obj[key];\n    }).join('&');\n    return path === '' ? path : '?' + path;\n}\nfunction getPath(id, options) {\n    const idx = id.indexOf('?');\n    if (process.env.TARO_ENV === 'h5') {\n        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options === null || options === void 0 ? void 0 : options.stamp) ? { stamp: options.stamp } : {})}`;\n    }\n    else {\n        return `${idx > -1 ? id.substring(0, idx) : id}${stringify(options)}`;\n    }\n}\nfunction getOnReadyEventKey(path) {\n    return path + '.' + ON_READY;\n}\nfunction getOnShowEventKey(path) {\n    return path + '.' + ON_SHOW;\n}\nfunction getOnHideEventKey(path) {\n    return path + '.' + ON_HIDE;\n}\nfunction createPageConfig(component, pageName, data, pageConfig) {\n    // 小程序 Page 构造器是一个傲娇小公主，不能把复杂的对象挂载到参数上\n    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;\n    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call('getMiniLifecycleImpl').page;\n    let pageElement = null;\n    let unmounting = false;\n    let prepareMountList = [];\n    function setCurrentRouter(page) {\n        const router = process.env.TARO_ENV === 'h5' ? page.$taroPath : page.route || page.__route__ || page.$taroPath;\n        Current.router = {\n            params: page.$taroParams,\n            path: addLeadingSlash(router),\n            $taroPath: page.$taroPath,\n            onReady: getOnReadyEventKey(id),\n            onShow: getOnShowEventKey(id),\n            onHide: getOnHideEventKey(id)\n        };\n        if (!isUndefined(page.exitState)) {\n            Current.router.exitState = page.exitState;\n        }\n    }\n    let loadResolver;\n    let hasLoaded;\n    const config = {\n        [ONLOAD](options = {}, cb) {\n            hasLoaded = new Promise(resolve => { loadResolver = resolve; });\n            perf.start(PAGE_INIT);\n            Current.page = this;\n            this.config = pageConfig || {};\n            // this.$taroPath 是页面唯一标识\n            const uniqueOptions = Object.assign({}, options, { $taroTimestamp: Date.now() });\n            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);\n            if (process.env.TARO_ENV === 'h5') {\n                config.path = $taroPath;\n            }\n            // this.$taroParams 作为暴露给开发者的页面参数对象，可以被随意修改\n            if (this.$taroParams == null) {\n                this.$taroParams = uniqueOptions;\n            }\n            setCurrentRouter(this);\n            // 初始化当前页面的上下文信息\n            if (process.env.TARO_ENV !== 'h5') {\n                window$1.trigger(CONTEXT_ACTIONS.INIT, $taroPath);\n            }\n            const mount = () => {\n                Current.app.mount(component, $taroPath, () => {\n                    pageElement = env.document.getElementById($taroPath);\n                    ensure(pageElement !== null, '没有找到页面实例。');\n                    safeExecute($taroPath, ON_LOAD, this.$taroParams);\n                    loadResolver();\n                    if (process.env.TARO_ENV !== 'h5') {\n                        pageElement.ctx = this;\n                        pageElement.performUpdate(true, cb);\n                    }\n                    else {\n                        isFunction(cb) && cb();\n                    }\n                });\n            };\n            if (unmounting) {\n                prepareMountList.push(mount);\n            }\n            else {\n                mount();\n            }\n        },\n        [ONUNLOAD]() {\n            const $taroPath = this.$taroPath;\n            // 销毁当前页面的上下文信息\n            if (process.env.TARO_ENV !== 'h5') {\n                window$1.trigger(CONTEXT_ACTIONS.DESTORY, $taroPath);\n            }\n            // 触发onUnload生命周期\n            safeExecute($taroPath, ONUNLOAD);\n            unmounting = true;\n            Current.app.unmount($taroPath, () => {\n                unmounting = false;\n                instances.delete($taroPath);\n                if (pageElement) {\n                    pageElement.ctx = null;\n                    pageElement = null;\n                }\n                if (prepareMountList.length) {\n                    prepareMountList.forEach(fn => fn());\n                    prepareMountList = [];\n                }\n            });\n        },\n        [ONREADY]() {\n            hasLoaded.then(() => {\n                // 触发生命周期\n                safeExecute(this.$taroPath, ON_READY);\n                // 通过事件触发子组件的生命周期\n                _raf(() => eventCenter.trigger(getOnReadyEventKey(id)));\n                this.onReady.called = true;\n            });\n        },\n        [ONSHOW](options = {}) {\n            hasLoaded.then(() => {\n                // 设置 Current 的 page 和 router\n                Current.page = this;\n                setCurrentRouter(this);\n                // 恢复上下文信息\n                if (process.env.TARO_ENV !== 'h5') {\n                    window$1.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);\n                }\n                // 触发生命周期\n                safeExecute(this.$taroPath, ON_SHOW, options);\n                // 通过事件触发子组件的生命周期\n                _raf(() => eventCenter.trigger(getOnShowEventKey(id)));\n            });\n        },\n        [ONHIDE]() {\n            // 缓存当前页面上下文信息\n            if (process.env.TARO_ENV !== 'h5') {\n                window$1.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);\n            }\n            // 设置 Current 的 page 和 router\n            if (Current.page === this) {\n                Current.page = null;\n                Current.router = null;\n            }\n            // 触发生命周期\n            safeExecute(this.$taroPath, ON_HIDE);\n            // 通过事件触发子组件的生命周期\n            eventCenter.trigger(getOnHideEventKey(id));\n        }\n    };\n    LIFECYCLES.forEach((lifecycle) => {\n        config[lifecycle] = function () {\n            return safeExecute(this.$taroPath, lifecycle, ...arguments);\n        };\n    });\n    // onShareAppMessage 和 onShareTimeline 一样，会影响小程序右上方按钮的选项，因此不能默认注册。\n    SIDE_EFFECT_LIFECYCLES.forEach(lifecycle => {\n        var _a;\n        if (component[lifecycle] ||\n            ((_a = component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) ||\n            component[lifecycle.replace(/^on/, 'enable')]) {\n            config[lifecycle] = function (...args) {\n                var _a;\n                const target = (_a = args[0]) === null || _a === void 0 ? void 0 : _a.target;\n                if (target === null || target === void 0 ? void 0 : target.id) {\n                    const id = target.id;\n                    const element = env.document.getElementById(id);\n                    if (element) {\n                        target.dataset = element.dataset;\n                    }\n                }\n                return safeExecute(this.$taroPath, lifecycle, ...args);\n            };\n        }\n    });\n    config.eh = eventHandler;\n    if (!isUndefined(data)) {\n        config.data = data;\n    }\n    hooks.call('modifyPageObject', config);\n    return config;\n}\nfunction createComponentConfig(component, componentName, data) {\n    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;\n    let componentElement = null;\n    const [ATTACHED, DETACHED] = hooks.call('getMiniLifecycleImpl').component;\n    const config = {\n        [ATTACHED]() {\n            var _a;\n            perf.start(PAGE_INIT);\n            const path = getPath(id, { id: ((_a = this.getPageId) === null || _a === void 0 ? void 0 : _a.call(this)) || pageId() });\n            Current.app.mount(component, path, () => {\n                componentElement = env.document.getElementById(path);\n                ensure(componentElement !== null, '没有找到组件实例。');\n                this.$taroInstances = instances.get(path);\n                safeExecute(path, ON_LOAD);\n                if (process.env.TARO_ENV !== 'h5') {\n                    componentElement.ctx = this;\n                    componentElement.performUpdate(true);\n                }\n            });\n        },\n        [DETACHED]() {\n            const path = getPath(id, { id: this.getPageId() });\n            Current.app.unmount(path, () => {\n                instances.delete(path);\n                if (componentElement) {\n                    componentElement.ctx = null;\n                }\n            });\n        },\n        methods: {\n            eh: eventHandler\n        }\n    };\n    if (!isUndefined(data)) {\n        config.data = data;\n    }\n    [OPTIONS, EXTERNAL_CLASSES, BEHAVIORS].forEach(key => {\n        var _a;\n        config[key] = (_a = component[key]) !== null && _a !== void 0 ? _a : EMPTY_OBJ;\n    });\n    return config;\n}\nfunction createRecursiveComponentConfig(componentName) {\n    const isCustomWrapper = componentName === CUSTOM_WRAPPER;\n    const [ATTACHED, DETACHED] = hooks.call('getMiniLifecycleImpl').component;\n    const lifeCycles = isCustomWrapper\n        ? {\n            [ATTACHED]() {\n                var _a, _b;\n                const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);\n                if (isString(componentId)) {\n                    customWrapperCache.set(componentId, this);\n                }\n            },\n            [DETACHED]() {\n                var _a, _b;\n                const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);\n                if (isString(componentId)) {\n                    customWrapperCache.delete(componentId);\n                }\n            }\n        }\n        : EMPTY_OBJ;\n    return Object.assign({ properties: {\n            i: {\n                type: Object,\n                value: {\n                    [\"nn\" /* Shortcuts.NodeName */]: getComponentsAlias$1(internalComponents)[VIEW]._num\n                }\n            },\n            l: {\n                type: String,\n                value: ''\n            }\n        }, options: {\n            addGlobalClass: true,\n            virtualHost: !isCustomWrapper\n        }, methods: {\n            eh: eventHandler\n        } }, lifeCycles);\n}\n\nconst nextTick = (cb, ctx) => {\n    var _a, _b, _c;\n    const router = Current.router;\n    const timerFunc = () => {\n        setTimeout(function () {\n            ctx ? cb.call(ctx) : cb();\n        }, 1);\n    };\n    if (router !== null) {\n        let pageElement = null;\n        const path = router.$taroPath;\n        pageElement = env.document.getElementById(path);\n        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {\n            if (process.env.TARO_ENV === 'h5') {\n                // eslint-disable-next-line dot-notation\n                (_c = (_b = (_a = pageElement.firstChild) === null || _a === void 0 ? void 0 : _a['componentOnReady']) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => {\n                    timerFunc();\n                })) !== null && _c !== void 0 ? _c : timerFunc();\n            }\n            else {\n                pageElement.enqueueUpdateCallback(cb, ctx);\n            }\n        }\n        else {\n            timerFunc();\n        }\n    }\n    else {\n        timerFunc();\n    }\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'Current', { enumerable: true, configurable: true, get: function() { return Current; } });Object.defineProperty(exports, 'FormElement', { enumerable: true, configurable: true, get: function() { return FormElement; } });Object.defineProperty(exports, 'History', { enumerable: true, configurable: true, get: function() { return History; } });Object.defineProperty(exports, 'Location', { enumerable: true, configurable: true, get: function() { return Location; } });Object.defineProperty(exports, 'MutationObserver', { enumerable: true, configurable: true, get: function() { return MutationObserver; } });Object.defineProperty(exports, 'SVGElement', { enumerable: true, configurable: true, get: function() { return SVGElement; } });Object.defineProperty(exports, 'Style', { enumerable: true, configurable: true, get: function() { return Style; } });Object.defineProperty(exports, 'TaroElement', { enumerable: true, configurable: true, get: function() { return TaroElement; } });Object.defineProperty(exports, 'TaroEvent', { enumerable: true, configurable: true, get: function() { return TaroEvent; } });Object.defineProperty(exports, 'TaroNode', { enumerable: true, configurable: true, get: function() { return TaroNode; } });Object.defineProperty(exports, 'TaroRootElement', { enumerable: true, configurable: true, get: function() { return TaroRootElement; } });Object.defineProperty(exports, 'TaroText', { enumerable: true, configurable: true, get: function() { return TaroText; } });Object.defineProperty(exports, 'URL', { enumerable: true, configurable: true, get: function() { return URL; } });Object.defineProperty(exports, 'URLSearchParams', { enumerable: true, configurable: true, get: function() { return URLSearchParams; } });Object.defineProperty(exports, 'addLeadingSlash', { enumerable: true, configurable: true, get: function() { return addLeadingSlash; } });Object.defineProperty(exports, 'cancelAnimationFrame', { enumerable: true, configurable: true, get: function() { return _caf; } });Object.defineProperty(exports, 'createComponentConfig', { enumerable: true, configurable: true, get: function() { return createComponentConfig; } });Object.defineProperty(exports, 'createEvent', { enumerable: true, configurable: true, get: function() { return createEvent; } });Object.defineProperty(exports, 'createPageConfig', { enumerable: true, configurable: true, get: function() { return createPageConfig; } });Object.defineProperty(exports, 'createRecursiveComponentConfig', { enumerable: true, configurable: true, get: function() { return createRecursiveComponentConfig; } });Object.defineProperty(exports, 'document', { enumerable: true, configurable: true, get: function() { return document$1; } });Object.defineProperty(exports, 'eventCenter', { enumerable: true, configurable: true, get: function() { return eventCenter; } });Object.defineProperty(exports, 'eventHandler', { enumerable: true, configurable: true, get: function() { return eventHandler; } });Object.defineProperty(exports, 'eventSource', { enumerable: true, configurable: true, get: function() { return eventSource; } });Object.defineProperty(exports, 'getComputedStyle', { enumerable: true, configurable: true, get: function() { return getComputedStyle; } });Object.defineProperty(exports, 'getCurrentInstance', { enumerable: true, configurable: true, get: function() { return getCurrentInstance; } });Object.defineProperty(exports, 'getPageInstance', { enumerable: true, configurable: true, get: function() { return getPageInstance; } });Object.defineProperty(exports, 'history', { enumerable: true, configurable: true, get: function() { return history; } });Object.defineProperty(exports, 'hydrate', { enumerable: true, configurable: true, get: function() { return hydrate; } });Object.defineProperty(exports, 'incrementId', { enumerable: true, configurable: true, get: function() { return incrementId; } });Object.defineProperty(exports, 'injectPageInstance', { enumerable: true, configurable: true, get: function() { return injectPageInstance; } });Object.defineProperty(exports, 'location', { enumerable: true, configurable: true, get: function() { return location; } });Object.defineProperty(exports, 'navigator', { enumerable: true, configurable: true, get: function() { return nav; } });Object.defineProperty(exports, 'nextTick', { enumerable: true, configurable: true, get: function() { return nextTick; } });Object.defineProperty(exports, 'now', { enumerable: true, configurable: true, get: function() { return now; } });Object.defineProperty(exports, 'options', { enumerable: true, configurable: true, get: function() { return options; } });Object.defineProperty(exports, 'parseUrl', { enumerable: true, configurable: true, get: function() { return parseUrl; } });Object.defineProperty(exports, 'removePageInstance', { enumerable: true, configurable: true, get: function() { return removePageInstance; } });Object.defineProperty(exports, 'requestAnimationFrame', { enumerable: true, configurable: true, get: function() { return _raf; } });Object.defineProperty(exports, 'safeExecute', { enumerable: true, configurable: true, get: function() { return safeExecute; } });Object.defineProperty(exports, 'stringify', { enumerable: true, configurable: true, get: function() { return stringify; } });Object.defineProperty(exports, 'window', { enumerable: true, configurable: true, get: function() { return window$1; } });\n//# sourceMappingURL=runtime.esm.js.map\n"]}