{"version":3,"sources":["gen-mapping.umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec));\n})(this, (function (exports, setArray, sourcemapCodec) { \n\n    /**\n     * A low-level API to associate a generated position with an original source position. Line and\n     * column here are 0-based, unlike `addMapping`.\n     */\n    exports.addSegment = void 0;\n    /**\n     * A high-level API to associate a generated position with an original source position. Line is\n     * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n     */\n    exports.addMapping = void 0;\n    /**\n     * Adds/removes the content of the source file to the source map.\n     */\n    exports.setSourceContent = void 0;\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.decodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.encodedMap = void 0;\n    /**\n     * Returns an array of high-level mapping objects for every recorded segment, which could then be\n     * passed to the `source-map` library.\n     */\n    exports.allMappings = void 0;\n    /**\n     * Provides the state to generate a sourcemap.\n     */\n    class GenMapping {\n        constructor({ file, sourceRoot } = {}) {\n            this._names = new setArray.SetArray();\n            this._sources = new setArray.SetArray();\n            this._sourcesContent = [];\n            this._mappings = [];\n            this.file = file;\n            this.sourceRoot = sourceRoot;\n        }\n    }\n    (() => {\n        exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n            const line = getLine(mappings, genLine);\n            if (source == null) {\n                const seg = [genColumn];\n                const index = getColumnIndex(line, genColumn, seg);\n                return insert(line, index, seg);\n            }\n            const sourcesIndex = setArray.put(sources, source);\n            const seg = name\n                ? [genColumn, sourcesIndex, sourceLine, sourceColumn, setArray.put(names, name)]\n                : [genColumn, sourcesIndex, sourceLine, sourceColumn];\n            const index = getColumnIndex(line, genColumn, seg);\n            if (sourcesIndex === sourcesContent.length)\n                sourcesContent[sourcesIndex] = null;\n            insert(line, index, seg);\n        };\n        exports.addMapping = (map, mapping) => {\n            const { generated, source, original, name } = mapping;\n            return exports.addSegment(map, generated.line - 1, generated.column, source, original == null ? undefined : original.line - 1, original === null || original === void 0 ? void 0 : original.column, name);\n        };\n        exports.setSourceContent = (map, source, content) => {\n            const { _sources: sources, _sourcesContent: sourcesContent } = map;\n            sourcesContent[setArray.put(sources, source)] = content;\n        };\n        exports.decodedMap = (map) => {\n            const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n            return {\n                version: 3,\n                file,\n                names: names.array,\n                sourceRoot: sourceRoot || undefined,\n                sources: sources.array,\n                sourcesContent,\n                mappings,\n            };\n        };\n        exports.encodedMap = (map) => {\n            const decoded = exports.decodedMap(map);\n            return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });\n        };\n        exports.allMappings = (map) => {\n            const out = [];\n            const { _mappings: mappings, _sources: sources, _names: names } = map;\n            for (let i = 0; i < mappings.length; i++) {\n                const line = mappings[i];\n                for (let j = 0; j < line.length; j++) {\n                    const seg = line[j];\n                    const generated = { line: i + 1, column: seg[0] };\n                    let source = undefined;\n                    let original = undefined;\n                    let name = undefined;\n                    if (seg.length !== 1) {\n                        source = sources.array[seg[1]];\n                        original = { line: seg[2] + 1, column: seg[3] };\n                        if (seg.length === 5)\n                            name = names.array[seg[4]];\n                    }\n                    out.push({ generated, source, original, name });\n                }\n            }\n            return out;\n        };\n    })();\n    function getLine(mappings, index) {\n        for (let i = mappings.length; i <= index; i++) {\n            mappings[i] = [];\n        }\n        return mappings[index];\n    }\n    function getColumnIndex(line, column, seg) {\n        let index = line.length;\n        for (let i = index - 1; i >= 0; i--, index--) {\n            const current = line[i];\n            const col = current[0];\n            if (col > column)\n                continue;\n            if (col < column)\n                break;\n            const cmp = compare(current, seg);\n            if (cmp === 0)\n                return index;\n            if (cmp < 0)\n                break;\n        }\n        return index;\n    }\n    function compare(a, b) {\n        let cmp = compareNum(a.length, b.length);\n        if (cmp !== 0)\n            return cmp;\n        // We've already checked genColumn\n        if (a.length === 1)\n            return 0;\n        cmp = compareNum(a[1], b[1]);\n        if (cmp !== 0)\n            return cmp;\n        cmp = compareNum(a[2], b[2]);\n        if (cmp !== 0)\n            return cmp;\n        cmp = compareNum(a[3], b[3]);\n        if (cmp !== 0)\n            return cmp;\n        if (a.length === 4)\n            return 0;\n        return compareNum(a[4], b[4]);\n    }\n    function compareNum(a, b) {\n        return a - b;\n    }\n    function insert(array, index, value) {\n        if (index === -1)\n            return;\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n\n    exports.GenMapping = GenMapping;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n"]}