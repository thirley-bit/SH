{"version":3,"sources":["index.js","const-enum.js","enum.js","namespace.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA,AGTA;ADIA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxTypescript = require(\"@babel/plugin-syntax-typescript\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _constEnum = require(\"./const-enum\");\nvar _enum = require(\"./enum\");\nvar _namespace = require(\"./namespace\");\nfunction isInType(path) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return path.parentPath.findParent(path => path.type !== \"TSQualifiedName\").type !== \"TSImportEqualsDeclaration\";\n    case \"ExportSpecifier\":\n      return path.parent.exportKind === \"type\" || path.parentPath.parent.exportKind === \"type\";\n    default:\n      return false;\n  }\n}\nconst GLOBAL_TYPES = new WeakMap();\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\nfunction isGlobalType({\n  scope\n}, name) {\n  if (scope.hasBinding(name)) return false;\n  if (GLOBAL_TYPES.get(scope).has(name)) return true;\n  console.warn(`The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` + `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` + `never encountered it as a TypeScript type declaration.\\n` + `It will be treated as a JavaScript value.\\n\\n` + `This problem is likely caused by another plugin injecting\\n` + `\"${name}\" without registering it in the scope tracker. If you are the author\\n` + ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`);\n  return false;\n}\nfunction registerGlobalType(programScope, name) {\n  GLOBAL_TYPES.get(programScope).add(name);\n}\nfunction safeRemove(path) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  const {\n    types: t,\n    template\n  } = api;\n  api.assertVersion(7);\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+([^\\s]+)/;\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false\n  } = opts;\n  {\n    var {\n      allowDeclareFields = false\n    } = opts;\n  }\n  const classMemberVisitors = {\n    field(path) {\n      const {\n        node\n      } = path;\n      {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);\n        }\n      }\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);\n        }\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);\n        }\n        {\n          if (!allowDeclareFields && !node.decorators && !t.isClassPrivateProperty(node)) {\n            path.remove();\n          }\n        }\n      } else if (node.abstract) {\n        path.remove();\n      } else {\n        if (!allowDeclareFields && !node.value && !node.decorators && !t.isClassPrivateProperty(node)) {\n          path.remove();\n        }\n      }\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n    method({\n      node\n    }) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n    },\n    constructor(path, classPath) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      const assigns = [];\n      const {\n        scope\n      } = path;\n      for (const paramPath of path.get(\"params\")) {\n        const param = paramPath.node;\n        if (param.type === \"TSParameterProperty\") {\n          const parameter = param.parameter;\n          if (PARSED_PARAMS.has(parameter)) continue;\n          PARSED_PARAMS.add(parameter);\n          let id;\n          if (t.isIdentifier(parameter)) {\n            id = parameter;\n          } else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) {\n            id = parameter.left;\n          } else {\n            throw paramPath.buildCodeFrameError(\"Parameter properties can not be destructuring patterns.\");\n          }\n          assigns.push(template.statement.ast`\n          this.${t.cloneNode(id)} = ${t.cloneNode(id)}`);\n          paramPath.replaceWith(paramPath.get(\"parameter\"));\n          scope.registerBinding(\"param\", paramPath);\n        }\n      }\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);\n    }\n  };\n  return {\n    name: \"transform-typescript\",\n    inherits: _pluginSyntaxTypescript.default,\n    visitor: {\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n      Program: {\n        enter(path, state) {\n          const {\n            file\n          } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programScope = path.scope;\n          if (!GLOBAL_TYPES.has(programScope)) {\n            GLOBAL_TYPES.set(programScope, new Set());\n          }\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n          for (let stmt of path.get(\"body\")) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programScope, specifier.local.name);\n                }\n                stmt.remove();\n                continue;\n              }\n              const importsToRemove = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n              const isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;\n              for (const specifier of stmt.node.specifiers) {\n                if (specifier.type === \"ImportSpecifier\" && specifier.importKind === \"type\") {\n                  registerGlobalType(programScope, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (isImportTypeOnly({\n                      binding,\n                      programPath: path,\n                      pragmaImportName,\n                      pragmaFragImportName\n                    })) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n              continue;\n            }\n            if (stmt.isExportDeclaration()) {\n              stmt = stmt.get(\"declaration\");\n            }\n            if (stmt.isVariableDeclaration({\n              declare: true\n            })) {\n              for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n                registerGlobalType(programScope, name);\n              }\n            } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get(\"id\").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({\n              declare: true\n            }) || stmt.isTSEnumDeclaration({\n              declare: true\n            }) || stmt.isTSModuleDeclaration({\n              declare: true\n            }) && stmt.get(\"id\").isIdentifier()) {\n              registerGlobalType(programScope, stmt.node.id.name);\n            }\n          }\n        },\n        exit(path) {\n          if (path.node.sourceType === \"module\" && NEEDS_EXPLICIT_ESM.get(path.node)) {\n            path.pushContainer(\"body\", t.exportNamedDeclaration());\n          }\n        }\n      },\n      ExportNamedDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n        if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => specifier.type === \"ExportSpecifier\" && specifier.exportKind === \"type\")) {\n          path.remove();\n          return;\n        }\n        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => t.isExportSpecifier(specifier) && isGlobalType(path, specifier.local.name))) {\n          path.remove();\n          return;\n        }\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n      ExportAllDeclaration(path) {\n        if (path.node.exportKind === \"type\") path.remove();\n      },\n      ExportSpecifier(path) {\n        const parent = path.parent;\n        if (!parent.source && isGlobalType(path, path.node.local.name) || path.node.exportKind === \"type\") {\n          path.remove();\n        }\n      },\n      ExportDefaultDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n        if (t.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {\n          path.remove();\n          return;\n        }\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n      TSDeclareFunction(path) {\n        safeRemove(path);\n      },\n      TSDeclareMethod(path) {\n        safeRemove(path);\n      },\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          safeRemove(path);\n        }\n      },\n      VariableDeclarator({\n        node\n      }) {\n        if (node.definite) node.definite = null;\n      },\n      TSIndexSignature(path) {\n        path.remove();\n      },\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n        if (node.declare) {\n          safeRemove(path);\n        }\n      },\n      Class(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(child, path);\n            } else {\n              classMemberVisitors.method(child);\n            }\n          } else if (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) {\n            classMemberVisitors.field(child);\n          }\n        });\n      },\n      Function(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n        const params = node.params;\n        if (params.length > 0 && t.isIdentifier(params[0], {\n          name: \"this\"\n        })) {\n          params.shift();\n        }\n      },\n      TSModuleDeclaration(path) {\n        (0, _namespace.default)(path, allowNamespaces);\n      },\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n      TSEnumDeclaration(path) {\n        if (optimizeConstEnums && path.node.const) {\n          (0, _constEnum.default)(path, t);\n        } else {\n          (0, _enum.default)(path, t);\n        }\n      },\n      TSImportEqualsDeclaration(path) {\n        if (t.isTSExternalModuleReference(path.node.moduleReference)) {\n          throw path.buildCodeFrameError(`\\`import ${path.node.id.name} = require('${path.node.moduleReference.expression.value}')\\` ` + \"is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using \" + `\\`import ${path.node.id.name} from '${path.node.moduleReference.expression.value}';\\` alongside ` + \"Typescript's --allowSyntheticDefaultImports option.\");\n        }\n        path.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, entityNameToExpr(path.node.moduleReference))]));\n        path.scope.registerDeclaration(path);\n      },\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\"`export =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using `export <value>;`.\");\n      },\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n      [`TSAsExpression${t.tsSatisfiesExpression ? \"|TSSatisfiesExpression\" : \"\"}`](path) {\n        let {\n          node\n        } = path;\n        do {\n          node = node.expression;\n        } while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node));\n        path.replaceWith(node);\n      },\n      [api.types.tsInstantiationExpression ? \"TSNonNullExpression|TSInstantiationExpression\" : \"TSNonNullExpression\"](path) {\n        path.replaceWith(path.node.expression);\n      },\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n      OptionalCallExpression(path) {\n        path.node.typeParameters = null;\n      },\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      }\n    }\n  };\n  function entityNameToExpr(node) {\n    if (t.isTSQualifiedName(node)) {\n      return t.memberExpression(entityNameToExpr(node.left), node.right);\n    }\n    return node;\n  }\n  function visitPattern({\n    node\n  }) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (t.isIdentifier(node) && node.optional) node.optional = null;\n  }\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    pragmaImportName,\n    pragmaFragImportName\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {\n      return true;\n    }\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        sourceFileHasJsx = true;\n        path.stop();\n      }\n    });\n    return !sourceFileHasJsx;\n  }\n});\nexports.default = _default;\n\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileConstEnum;\nvar _enum = require(\"./enum\");\nfunction transpileConstEnum(path, t) {\n  const {\n    name\n  } = path.node.id;\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(stmt => t.isExportNamedDeclaration(stmt) && stmt.exportKind !== \"type\" && !stmt.source && stmt.specifiers.some(spec => t.isExportSpecifier(spec) && spec.exportKind !== \"type\" && spec.local.name === name));\n  }\n  const {\n    enumValues: entries\n  } = (0, _enum.translateEnumValues)(path, t);\n  if (isExported) {\n    const obj = t.objectExpression(entries.map(([name, value]) => t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value)));\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), [path.node.id, obj])));\n    } else {\n      path.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]));\n      path.scope.registerDeclaration(path);\n    }\n    return;\n  }\n  const entriesMap = new Map(entries);\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, {\n        name\n      })) return;\n      let key;\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n      if (!entriesMap.has(key)) return;\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    }\n  });\n  path.remove();\n}\n\n//# sourceMappingURL=const-enum.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\nexports.translateEnumValues = translateEnumValues;\nvar _core = require(\"@babel/core\");\nvar _assert = require(\"assert\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nconst ENUMS = new WeakMap();\nconst buildEnumWrapper = _core.template.expression(`\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `);\nfunction transpileEnum(path, t) {\n  const {\n    node,\n    parentPath\n  } = path;\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n  const name = node.id.name;\n  const {\n    fill,\n    data,\n    isPure\n  } = enumFill(path, t, node.id);\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        const isGlobal = t.isProgram(path.parent);\n        const isSeen = seen(parentPath);\n        let init = t.objectExpression([]);\n        if (isSeen || isGlobal) {\n          init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n        }\n        const enumIIFE = buildEnumWrapper(Object.assign({}, fill, {\n          INIT: init\n        }));\n        if (isPure) (0, _helperAnnotateAsPure.default)(enumIIFE);\n        if (isSeen) {\n          const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n          toReplace.replaceWith(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE)));\n        } else {\n          path.scope.registerDeclaration(path.replaceWith(t.variableDeclaration(isGlobal ? \"var\" : \"let\", [t.variableDeclarator(node.id, enumIIFE)]))[0]);\n        }\n        ENUMS.set(path.scope.getBindingIdentifier(name), data);\n        break;\n      }\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\nfunction enumFill(path, t, id) {\n  const {\n    enumValues: x,\n    data,\n    isPure\n  } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {\n    ENUM: t.cloneNode(id),\n    NAME: memberName,\n    VALUE: memberValue\n  }));\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments\n    },\n    data,\n    isPure\n  };\n}\nfunction ReferencedIdentifier(expr, state) {\n  const {\n    seen,\n    path,\n    t\n  } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));\n    expr.skip();\n  }\n}\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier\n};\nfunction translateEnumValues(path, t) {\n  const seen = new Map();\n  let constValue = -1;\n  let lastName;\n  let isPure = true;\n  const enumValues = path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializerPath = memberPath.get(\"initializer\");\n    const initializer = member.initializer;\n    let value;\n    if (initializer) {\n      constValue = computeConstantValue(initializerPath, seen);\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          _assert(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        isPure && (isPure = initializerPath.isPure());\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, {\n            t,\n            seen,\n            path\n          });\n        }\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n    lastName = name;\n    return [name, value];\n  });\n  return {\n    isPure,\n    data: seen,\n    enumValues\n  };\n}\nfunction computeConstantValue(path, prevMembers, seen = new Set()) {\n  return evaluate(path);\n  function evaluate(path) {\n    const expr = path.node;\n    switch (expr.type) {\n      case \"MemberExpression\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(path);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(path);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evaluate(path.get(\"expression\"));\n      case \"Identifier\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"TemplateLiteral\":\n        {\n          if (expr.quasis.length === 1) {\n            return expr.quasis[0].value.cooked;\n          }\n          const paths = path.get(\"expressions\");\n          const quasis = expr.quasis;\n          let str = \"\";\n          for (let i = 0; i < quasis.length; i++) {\n            str += quasis[i].value.cooked;\n            if (i + 1 < quasis.length) {\n              const value = evaluateRef(paths[i], prevMembers, seen);\n              if (value === undefined) return undefined;\n              str += value;\n            }\n          }\n          return str;\n        }\n      default:\n        return undefined;\n    }\n  }\n  function evaluateRef(path, prevMembers, seen) {\n    if (path.isMemberExpression()) {\n      const expr = path.node;\n      const obj = expr.object;\n      const prop = expr.property;\n      if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop))) {\n        return;\n      }\n      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);\n      const data = ENUMS.get(bindingIdentifier);\n      if (!data) return;\n      return data.get(prop.computed ? prop.value : prop.name);\n    } else if (path.isIdentifier()) {\n      const name = path.node.name;\n      let value = prevMembers == null ? void 0 : prevMembers.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n      if (seen.has(path.node)) return;\n      const bindingInitPath = path.resolve();\n      if (bindingInitPath) {\n        seen.add(path.node);\n        value = computeConstantValue(bindingInitPath, undefined, seen);\n        prevMembers == null ? void 0 : prevMembers.set(name, value);\n        return value;\n      }\n    }\n  }\n  function evalUnaryExpression(path) {\n    const value = evaluate(path.get(\"argument\"));\n    if (value === undefined) {\n      return undefined;\n    }\n    switch (path.node.operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n  function evalBinaryExpression(path) {\n    const left = evaluate(path.get(\"left\"));\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evaluate(path.get(\"right\"));\n    if (right === undefined) {\n      return undefined;\n    }\n    switch (path.node.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return Math.pow(left, right);\n      default:\n        return undefined;\n    }\n  }\n}\n\n//# sourceMappingURL=enum.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileNamespace;\nvar _core = require(\"@babel/core\");\nfunction transpileNamespace(path, allowNamespaces) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n  if (!allowNamespaces) {\n    throw path.get(\"id\").buildCodeFrameError(\"Namespace not marked type-only declare.\" + \" Non-declarative namespaces are only supported experimentally in Babel.\" + \" To enable and review caveats see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n  const name = path.node.id.name;\n  const value = handleNested(path, _core.types.cloneNode(path.node, true));\n  const bound = path.scope.hasOwnBinding(name);\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(name), value])[0]);\n  }\n}\nfunction getDeclaration(name) {\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(_core.types.identifier(name))]);\n}\nfunction getMemberExpression(name, itemName) {\n  return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));\n}\nfunction handleVariableDeclaration(node, name, hub) {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(node, \"Namespaces exporting non-const are not supported by Babel.\" + \" Change to const or see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n  const {\n    declarations\n  } = node;\n  if (declarations.every(declarator => _core.types.isIdentifier(declarator.id))) {\n    for (const declarator of declarations) {\n      declarator.init = _core.types.assignmentExpression(\"=\", getMemberExpression(name, declarator.id.name), declarator.init);\n    }\n    return [node];\n  }\n  const bindingIdentifiers = _core.types.getBindingIdentifiers(node);\n  const assignments = [];\n  for (const idName in bindingIdentifiers) {\n    assignments.push(_core.types.assignmentExpression(\"=\", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));\n  }\n  return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];\n}\nfunction buildNestedAmbientModuleError(path, node) {\n  return path.hub.buildError(node, \"Ambient modules cannot be nested in other modules or namespaces.\", Error);\n}\nfunction handleNested(path, node, parentExport) {\n  const names = new Set();\n  const realName = node.id;\n  _core.types.assertIdentifier(realName);\n  const name = path.scope.generateUid(realName.name);\n  const namespaceTopLevel = _core.types.isTSModuleBlock(node.body) ? node.body.body : [_core.types.exportNamedDeclaration(node.body)];\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\":\n        {\n          if (!_core.types.isIdentifier(subNode.id)) {\n            throw buildNestedAmbientModuleError(path, subNode);\n          }\n          const transformed = handleNested(path, subNode);\n          const moduleName = subNode.id.name;\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);\n          }\n          continue;\n        }\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n      case \"VariableDeclaration\":\n        {\n          for (const name in _core.types.getBindingIdentifiers(subNode)) {\n            names.add(name);\n          }\n          continue;\n        }\n      default:\n        continue;\n      case \"ExportNamedDeclaration\":\n    }\n    if (\"declare\" in subNode.declaration && subNode.declaration.declare) {\n      continue;\n    }\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        {\n          const itemName = subNode.declaration.id.name;\n          names.add(itemName);\n          namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", getMemberExpression(name, itemName), _core.types.identifier(itemName))));\n          break;\n        }\n      case \"VariableDeclaration\":\n        {\n          const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);\n          namespaceTopLevel.splice(i, nodes.length, ...nodes);\n          i += nodes.length - 1;\n          break;\n        }\n      case \"TSModuleDeclaration\":\n        {\n          if (!_core.types.isIdentifier(subNode.declaration.id)) {\n            throw buildNestedAmbientModuleError(path, subNode.declaration);\n          }\n          const transformed = handleNested(path, subNode.declaration, _core.types.identifier(name));\n          const moduleName = subNode.declaration.id.name;\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);\n          }\n        }\n    }\n  }\n  let fallthroughValue = _core.types.objectExpression([]);\n  if (parentExport) {\n    const memberExpr = _core.types.memberExpression(parentExport, realName);\n    fallthroughValue = _core.template.expression.ast`\n      ${_core.types.cloneNode(memberExpr)} ||\n        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n  return _core.template.statement.ast`\n    (function (${_core.types.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}\n\n//# sourceMappingURL=namespace.js.map\n"]}